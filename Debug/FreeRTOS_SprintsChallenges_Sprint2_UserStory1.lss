
FreeRTOS_SprintsChallenges_Sprint2_UserStory1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000539a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000060  00800060  0000539a  0000542e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000657  008000c0  008000c0  0000548e  2**0
                  ALLOC
  3 .stab         00008cb8  00000000  00000000  00005490  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000491e  00000000  00000000  0000e148  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 e9 0d 	jmp	0x1bd2	; 0x1bd2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e9       	ldi	r30, 0x9A	; 154
      68:	f3 e5       	ldi	r31, 0x53	; 83
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 3c       	cpi	r26, 0xC0	; 192
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a0 ec       	ldi	r26, 0xC0	; 192
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 31       	cpi	r26, 0x17	; 23
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <main>
      8a:	0c 94 cb 29 	jmp	0x5396	; 0x5396 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <PushButton_Init>:
 * Outputs:         NULL
 *
 * Return:          NULL
 *******************************************************************************/
void PushButton_Init(void)
{
     532:	df 93       	push	r29
     534:	cf 93       	push	r28
     536:	cd b7       	in	r28, 0x3d	; 61
     538:	de b7       	in	r29, 0x3e	; 62
    /*set Pins Of Push Button*/
    DIO_SetPinDirection(DIO_PIN10 , INPUT);
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	60 e0       	ldi	r22, 0x00	; 0
     53e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
    DIO_SetPinDirection(DIO_PIN20 , INPUT);
     542:	84 e1       	ldi	r24, 0x14	; 20
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>


}
     54a:	cf 91       	pop	r28
     54c:	df 91       	pop	r29
     54e:	08 95       	ret

00000550 <Buttons_getPressedButton>:
 * Outputs:         NULL
 *
 * Return:          pressed Push Button (uint8_t)
 *******************************************************************************/
uint8 Buttons_getPressedButton(void)
{
     550:	df 93       	push	r29
     552:	cf 93       	push	r28
     554:	0f 92       	push	r0
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
    /*return value*/
    uint8 ReturnVal=10;
     55a:	8a e0       	ldi	r24, 0x0A	; 10
     55c:	89 83       	std	Y+1, r24	; 0x01


    /*Loop to check if button is pressed to return its value*/

    if(DIO_ReadPin(DIO_PIN10) == 0)
     55e:	8a e0       	ldi	r24, 0x0A	; 10
     560:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     564:	88 23       	and	r24, r24
     566:	19 f4       	brne	.+6      	; 0x56e <Buttons_getPressedButton+0x1e>
    {
        ReturnVal = 2;
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	07 c0       	rjmp	.+14     	; 0x57c <Buttons_getPressedButton+0x2c>
    }
    else if(DIO_ReadPin(DIO_PIN20) == 0)
     56e:	84 e1       	ldi	r24, 0x14	; 20
     570:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     574:	88 23       	and	r24, r24
     576:	11 f4       	brne	.+4      	; 0x57c <Buttons_getPressedButton+0x2c>
    {
        ReturnVal = 1;
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	89 83       	std	Y+1, r24	; 0x01
    }
    else
    {
        /*Do Nothing*/
    }
    return ReturnVal;
     57c:	89 81       	ldd	r24, Y+1	; 0x01
}
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	df 93       	push	r29
     58e:	cf 93       	push	r28
     590:	00 d0       	rcall	.+0      	; 0x592 <init_Task+0xc>
     592:	cd b7       	in	r28, 0x3d	; 61
     594:	de b7       	in	r29, 0x3e	; 62
     596:	9a 83       	std	Y+2, r25	; 0x02
     598:	89 83       	std	Y+1, r24	; 0x01
	/*Create Queues*/
	MessageQueue_PushButton= xQueueCreate( 3 , sizeof(uint8));
     59a:	83 e0       	ldi	r24, 0x03	; 3
     59c:	61 e0       	ldi	r22, 0x01	; 1
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xQueueGenericCreate>
     5a4:	90 93 c5 00 	sts	0x00C5, r25
     5a8:	80 93 c4 00 	sts	0x00C4, r24
	MessageQueue_Hello= xQueueCreate( 3 , sizeof(uint8));
     5ac:	83 e0       	ldi	r24, 0x03	; 3
     5ae:	61 e0       	ldi	r22, 0x01	; 1
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xQueueGenericCreate>
     5b6:	90 93 c7 00 	sts	0x00C7, r25
     5ba:	80 93 c6 00 	sts	0x00C6, r24

	/*Create 3 Tasks*/
	xTaskCreate(All_Hardware_Init_Task  , "InitTasks" , configMINIMAL_STACK_SIZE ,
     5be:	86 e2       	ldi	r24, 0x26	; 38
     5c0:	93 e0       	ldi	r25, 0x03	; 3
     5c2:	20 e6       	ldi	r18, 0x60	; 96
     5c4:	30 e0       	ldi	r19, 0x00	; 0
     5c6:	e0 ec       	ldi	r30, 0xC0	; 192
     5c8:	f0 e0       	ldi	r31, 0x00	; 0
     5ca:	b9 01       	movw	r22, r18
     5cc:	46 e9       	ldi	r20, 0x96	; 150
     5ce:	50 e0       	ldi	r21, 0x00	; 0
     5d0:	20 e0       	ldi	r18, 0x00	; 0
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	05 e0       	ldi	r16, 0x05	; 5
     5d6:	7f 01       	movw	r14, r30
     5d8:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xTaskCreate>
			NULL , (5 | portPRIVILEGE_BIT) , &AllHardwareInit_Flag);
	xTaskCreate(PushButton_Task  , "PushButton_Task" , configMINIMAL_STACK_SIZE ,
     5dc:	88 e3       	ldi	r24, 0x38	; 56
     5de:	93 e0       	ldi	r25, 0x03	; 3
     5e0:	2a e6       	ldi	r18, 0x6A	; 106
     5e2:	30 e0       	ldi	r19, 0x00	; 0
     5e4:	b9 01       	movw	r22, r18
     5e6:	46 e9       	ldi	r20, 0x96	; 150
     5e8:	50 e0       	ldi	r21, 0x00	; 0
     5ea:	20 e0       	ldi	r18, 0x00	; 0
     5ec:	30 e0       	ldi	r19, 0x00	; 0
     5ee:	03 e0       	ldi	r16, 0x03	; 3
     5f0:	ee 24       	eor	r14, r14
     5f2:	ff 24       	eor	r15, r15
     5f4:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE ,
     5f8:	82 ea       	ldi	r24, 0xA2	; 162
     5fa:	93 e0       	ldi	r25, 0x03	; 3
     5fc:	2a e7       	ldi	r18, 0x7A	; 122
     5fe:	30 e0       	ldi	r19, 0x00	; 0
     600:	b9 01       	movw	r22, r18
     602:	46 e9       	ldi	r20, 0x96	; 150
     604:	50 e0       	ldi	r21, 0x00	; 0
     606:	20 e0       	ldi	r18, 0x00	; 0
     608:	30 e0       	ldi	r19, 0x00	; 0
     60a:	01 e0       	ldi	r16, 0x01	; 1
     60c:	ee 24       	eor	r14, r14
     60e:	ff 24       	eor	r15, r15
     610:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xTaskCreate>
			NULL , (1 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(SendHallo_Task  , "SendHallo_Task" , configMINIMAL_STACK_SIZE ,
     614:	83 e6       	ldi	r24, 0x63	; 99
     616:	94 e0       	ldi	r25, 0x04	; 4
     618:	23 e8       	ldi	r18, 0x83	; 131
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	b9 01       	movw	r22, r18
     61e:	46 e9       	ldi	r20, 0x96	; 150
     620:	50 e0       	ldi	r21, 0x00	; 0
     622:	20 e0       	ldi	r18, 0x00	; 0
     624:	30 e0       	ldi	r19, 0x00	; 0
     626:	02 e0       	ldi	r16, 0x02	; 2
     628:	ee 24       	eor	r14, r14
     62a:	ff 24       	eor	r15, r15
     62c:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);
	vTaskSuspend( InitTask_Flag);
     630:	80 91 c2 00 	lds	r24, 0x00C2
     634:	90 91 c3 00 	lds	r25, 0x00C3
     638:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <vTaskSuspend>
}
     63c:	0f 90       	pop	r0
     63e:	0f 90       	pop	r0
     640:	cf 91       	pop	r28
     642:	df 91       	pop	r29
     644:	0f 91       	pop	r16
     646:	ff 90       	pop	r15
     648:	ef 90       	pop	r14
     64a:	08 95       	ret

0000064c <All_Hardware_Init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void All_Hardware_Init_Task(void * a_Task_ptr)
{
     64c:	df 93       	push	r29
     64e:	cf 93       	push	r28
     650:	00 d0       	rcall	.+0      	; 0x652 <All_Hardware_Init_Task+0x6>
     652:	cd b7       	in	r28, 0x3d	; 61
     654:	de b7       	in	r29, 0x3e	; 62
     656:	9a 83       	std	Y+2, r25	; 0x02
     658:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		PushButton_Init();
     65a:	0e 94 99 02 	call	0x532	; 0x532 <PushButton_Init>
		LCD_init();
     65e:	0e 94 40 08 	call	0x1080	; 0x1080 <LCD_init>
		vTaskSuspend( AllHardwareInit_Flag);
     662:	80 91 c0 00 	lds	r24, 0x00C0
     666:	90 91 c1 00 	lds	r25, 0x00C1
     66a:	0e 94 e2 1e 	call	0x3dc4	; 0x3dc4 <vTaskSuspend>
     66e:	f5 cf       	rjmp	.-22     	; 0x65a <All_Hardware_Init_Task+0xe>

00000670 <PushButton_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButton_Task(void * a_Task_ptr)
{
     670:	df 93       	push	r29
     672:	cf 93       	push	r28
     674:	00 d0       	rcall	.+0      	; 0x676 <PushButton_Task+0x6>
     676:	00 d0       	rcall	.+0      	; 0x678 <PushButton_Task+0x8>
     678:	0f 92       	push	r0
     67a:	cd b7       	in	r28, 0x3d	; 61
     67c:	de b7       	in	r29, 0x3e	; 62
     67e:	9d 83       	std	Y+5, r25	; 0x05
     680:	8c 83       	std	Y+4, r24	; 0x04
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     682:	81 e0       	ldi	r24, 0x01	; 1
     684:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     686:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     688:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==1)
     68a:	8a 81       	ldd	r24, Y+2	; 0x02
     68c:	88 23       	and	r24, r24
     68e:	79 f4       	brne	.+30     	; 0x6ae <PushButton_Task+0x3e>
     690:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     694:	81 30       	cpi	r24, 0x01	; 1
     696:	59 f4       	brne	.+22     	; 0x6ae <PushButton_Task+0x3e>
		{
			OldPressedValue =  Buttons_getPressedButton();
     698:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     69c:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     69e:	8a 81       	ldd	r24, Y+2	; 0x02
     6a0:	8f 5f       	subi	r24, 0xFF	; 255
     6a2:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     6a4:	8a e0       	ldi	r24, 0x0A	; 10
     6a6:	90 e0       	ldi	r25, 0x00	; 0
     6a8:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
     6ac:	ee cf       	rjmp	.-36     	; 0x68a <PushButton_Task+0x1a>
		}
		else if(Debouncing == 1)
     6ae:	8a 81       	ldd	r24, Y+2	; 0x02
     6b0:	81 30       	cpi	r24, 0x01	; 1
     6b2:	09 f5       	brne	.+66     	; 0x6f6 <PushButton_Task+0x86>
     6b4:	13 c0       	rjmp	.+38     	; 0x6dc <PushButton_Task+0x6c>
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{
				SendData = 1;
     6b6:	81 e0       	ldi	r24, 0x01	; 1
     6b8:	8b 83       	std	Y+3, r24	; 0x03
				/*Send push Button was pressed to Lcd by queue*/
				xQueueSend(MessageQueue_PushButton , &SendData , 100);
     6ba:	80 91 c4 00 	lds	r24, 0x00C4
     6be:	90 91 c5 00 	lds	r25, 0x00C5
     6c2:	9e 01       	movw	r18, r28
     6c4:	2d 5f       	subi	r18, 0xFD	; 253
     6c6:	3f 4f       	sbci	r19, 0xFF	; 255
     6c8:	b9 01       	movw	r22, r18
     6ca:	44 e6       	ldi	r20, 0x64	; 100
     6cc:	50 e0       	ldi	r21, 0x00	; 0
     6ce:	20 e0       	ldi	r18, 0x00	; 0
     6d0:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xQueueGenericSend>
				vTaskDelay(100);
     6d4:	84 e6       	ldi	r24, 0x64	; 100
     6d6:	90 e0       	ldi	r25, 0x00	; 0
     6d8:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
			vTaskDelay(10);
		}
		else if(Debouncing == 1)
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
     6dc:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6e0:	98 2f       	mov	r25, r24
     6e2:	89 81       	ldd	r24, Y+1	; 0x01
     6e4:	98 17       	cp	r25, r24
     6e6:	39 f3       	breq	.-50     	; 0x6b6 <PushButton_Task+0x46>
				SendData = 1;
				/*Send push Button was pressed to Lcd by queue*/
				xQueueSend(MessageQueue_PushButton , &SendData , 100);
				vTaskDelay(100);
			}
			Debouncing = 2;
     6e8:	82 e0       	ldi	r24, 0x02	; 2
     6ea:	8a 83       	std	Y+2, r24	; 0x02
			vTaskDelay(100);
     6ec:	84 e6       	ldi	r24, 0x64	; 100
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
     6f4:	ca cf       	rjmp	.-108    	; 0x68a <PushButton_Task+0x1a>
		}
		else if(Debouncing == 2)
     6f6:	8a 81       	ldd	r24, Y+2	; 0x02
     6f8:	82 30       	cpi	r24, 0x02	; 2
     6fa:	81 f4       	brne	.+32     	; 0x71c <PushButton_Task+0xac>
		{
			SendData = 0;
     6fc:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(MessageQueue_PushButton , &SendData , 100);
     6fe:	80 91 c4 00 	lds	r24, 0x00C4
     702:	90 91 c5 00 	lds	r25, 0x00C5
     706:	9e 01       	movw	r18, r28
     708:	2d 5f       	subi	r18, 0xFD	; 253
     70a:	3f 4f       	sbci	r19, 0xFF	; 255
     70c:	b9 01       	movw	r22, r18
     70e:	44 e6       	ldi	r20, 0x64	; 100
     710:	50 e0       	ldi	r21, 0x00	; 0
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xQueueGenericSend>
			Debouncing = 0;
     718:	1a 82       	std	Y+2, r1	; 0x02
     71a:	b7 cf       	rjmp	.-146    	; 0x68a <PushButton_Task+0x1a>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     71c:	83 e0       	ldi	r24, 0x03	; 3
     71e:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(MessageQueue_PushButton , &SendData , 100);
     720:	80 91 c4 00 	lds	r24, 0x00C4
     724:	90 91 c5 00 	lds	r25, 0x00C5
     728:	9e 01       	movw	r18, r28
     72a:	2d 5f       	subi	r18, 0xFD	; 253
     72c:	3f 4f       	sbci	r19, 0xFF	; 255
     72e:	b9 01       	movw	r22, r18
     730:	44 e6       	ldi	r20, 0x64	; 100
     732:	50 e0       	ldi	r21, 0x00	; 0
     734:	20 e0       	ldi	r18, 0x00	; 0
     736:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xQueueGenericSend>
			vTaskDelay(100);
     73a:	84 e6       	ldi	r24, 0x64	; 100
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
     742:	a3 cf       	rjmp	.-186    	; 0x68a <PushButton_Task+0x1a>

00000744 <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     744:	df 93       	push	r29
     746:	cf 93       	push	r28
     748:	cd b7       	in	r28, 0x3d	; 61
     74a:	de b7       	in	r29, 0x3e	; 62
     74c:	af 97       	sbiw	r28, 0x2f	; 47
     74e:	0f b6       	in	r0, 0x3f	; 63
     750:	f8 94       	cli
     752:	de bf       	out	0x3e, r29	; 62
     754:	0f be       	out	0x3f, r0	; 63
     756:	cd bf       	out	0x3d, r28	; 61
     758:	9d a3       	std	Y+37, r25	; 0x25
     75a:	8c a3       	std	Y+36, r24	; 0x24
	vTaskDelay(100);
     75c:	84 e6       	ldi	r24, 0x64	; 100
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>

	/*received message from Hello Task to display button state on LCD*/
	uint8 HelloTask_Data;

	/*Push Button "Pressed" message*/
	uint8 ButtonPressedString[] = "Over Written!!!!";
     764:	ce 01       	movw	r24, r28
     766:	06 96       	adiw	r24, 0x06	; 6
     768:	9f a3       	std	Y+39, r25	; 0x27
     76a:	8e a3       	std	Y+38, r24	; 0x26
     76c:	e2 e9       	ldi	r30, 0x92	; 146
     76e:	f0 e0       	ldi	r31, 0x00	; 0
     770:	f9 a7       	std	Y+41, r31	; 0x29
     772:	e8 a7       	std	Y+40, r30	; 0x28
     774:	f1 e1       	ldi	r31, 0x11	; 17
     776:	fa a7       	std	Y+42, r31	; 0x2a
     778:	e8 a5       	ldd	r30, Y+40	; 0x28
     77a:	f9 a5       	ldd	r31, Y+41	; 0x29
     77c:	00 80       	ld	r0, Z
     77e:	88 a5       	ldd	r24, Y+40	; 0x28
     780:	99 a5       	ldd	r25, Y+41	; 0x29
     782:	01 96       	adiw	r24, 0x01	; 1
     784:	99 a7       	std	Y+41, r25	; 0x29
     786:	88 a7       	std	Y+40, r24	; 0x28
     788:	ee a1       	ldd	r30, Y+38	; 0x26
     78a:	ff a1       	ldd	r31, Y+39	; 0x27
     78c:	00 82       	st	Z, r0
     78e:	8e a1       	ldd	r24, Y+38	; 0x26
     790:	9f a1       	ldd	r25, Y+39	; 0x27
     792:	01 96       	adiw	r24, 0x01	; 1
     794:	9f a3       	std	Y+39, r25	; 0x27
     796:	8e a3       	std	Y+38, r24	; 0x26
     798:	9a a5       	ldd	r25, Y+42	; 0x2a
     79a:	91 50       	subi	r25, 0x01	; 1
     79c:	9a a7       	std	Y+42, r25	; 0x2a
     79e:	ea a5       	ldd	r30, Y+42	; 0x2a
     7a0:	ee 23       	and	r30, r30
     7a2:	51 f7       	brne	.-44     	; 0x778 <LCD_Task+0x34>

	/*Hello message*/
	uint8 MessageString[] = "Hello LCD !!";
     7a4:	ce 01       	movw	r24, r28
     7a6:	47 96       	adiw	r24, 0x17	; 23
     7a8:	9c a7       	std	Y+44, r25	; 0x2c
     7aa:	8b a7       	std	Y+43, r24	; 0x2b
     7ac:	e3 ea       	ldi	r30, 0xA3	; 163
     7ae:	f0 e0       	ldi	r31, 0x00	; 0
     7b0:	fe a7       	std	Y+46, r31	; 0x2e
     7b2:	ed a7       	std	Y+45, r30	; 0x2d
     7b4:	fd e0       	ldi	r31, 0x0D	; 13
     7b6:	ff a7       	std	Y+47, r31	; 0x2f
     7b8:	ed a5       	ldd	r30, Y+45	; 0x2d
     7ba:	fe a5       	ldd	r31, Y+46	; 0x2e
     7bc:	00 80       	ld	r0, Z
     7be:	8d a5       	ldd	r24, Y+45	; 0x2d
     7c0:	9e a5       	ldd	r25, Y+46	; 0x2e
     7c2:	01 96       	adiw	r24, 0x01	; 1
     7c4:	9e a7       	std	Y+46, r25	; 0x2e
     7c6:	8d a7       	std	Y+45, r24	; 0x2d
     7c8:	eb a5       	ldd	r30, Y+43	; 0x2b
     7ca:	fc a5       	ldd	r31, Y+44	; 0x2c
     7cc:	00 82       	st	Z, r0
     7ce:	8b a5       	ldd	r24, Y+43	; 0x2b
     7d0:	9c a5       	ldd	r25, Y+44	; 0x2c
     7d2:	01 96       	adiw	r24, 0x01	; 1
     7d4:	9c a7       	std	Y+44, r25	; 0x2c
     7d6:	8b a7       	std	Y+43, r24	; 0x2b
     7d8:	9f a5       	ldd	r25, Y+47	; 0x2f
     7da:	91 50       	subi	r25, 0x01	; 1
     7dc:	9f a7       	std	Y+47, r25	; 0x2f
     7de:	ef a5       	ldd	r30, Y+47	; 0x2f
     7e0:	ee 23       	and	r30, r30
     7e2:	51 f7       	brne	.-44     	; 0x7b8 <LCD_Task+0x74>

	/*counter to hundle displaying of hello message*/
	uint8 Counter = 0;
     7e4:	1b 82       	std	Y+3, r1	; 0x03

	/*Synchronize between displaying of Push Button task and hello task*/
	uint8 Flag = 0;
     7e6:	1a 82       	std	Y+2, r1	; 0x02
	uint8 Flag2 = 0;
     7e8:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*receive messages fro other tasks by queues*/
		xQueueReceive(MessageQueue_PushButton , &PushButtonTask_Data , 10);
     7ea:	80 91 c4 00 	lds	r24, 0x00C4
     7ee:	90 91 c5 00 	lds	r25, 0x00C5
     7f2:	9e 01       	movw	r18, r28
     7f4:	2c 5f       	subi	r18, 0xFC	; 252
     7f6:	3f 4f       	sbci	r19, 0xFF	; 255
     7f8:	b9 01       	movw	r22, r18
     7fa:	4a e0       	ldi	r20, 0x0A	; 10
     7fc:	50 e0       	ldi	r21, 0x00	; 0
     7fe:	0e 94 53 10 	call	0x20a6	; 0x20a6 <xQueueReceive>
		xQueueReceive(MessageQueue_Hello , &HelloTask_Data , 10);
     802:	80 91 c6 00 	lds	r24, 0x00C6
     806:	90 91 c7 00 	lds	r25, 0x00C7
     80a:	9e 01       	movw	r18, r28
     80c:	2b 5f       	subi	r18, 0xFB	; 251
     80e:	3f 4f       	sbci	r19, 0xFF	; 255
     810:	b9 01       	movw	r22, r18
     812:	4a e0       	ldi	r20, 0x0A	; 10
     814:	50 e0       	ldi	r21, 0x00	; 0
     816:	0e 94 53 10 	call	0x20a6	; 0x20a6 <xQueueReceive>

		/*Increment counter to Display Hello message for specific time*/
		if(Counter != 0)
     81a:	8b 81       	ldd	r24, Y+3	; 0x03
     81c:	88 23       	and	r24, r24
     81e:	19 f0       	breq	.+6      	; 0x826 <LCD_Task+0xe2>
		{
			Counter++;
     820:	8b 81       	ldd	r24, Y+3	; 0x03
     822:	8f 5f       	subi	r24, 0xFF	; 255
     824:	8b 83       	std	Y+3, r24	; 0x03
		{
			/*Do Nothing*/
		}

		/*check on Push Button Message is received*/
		if(PushButtonTask_Data == 1)
     826:	8c 81       	ldd	r24, Y+4	; 0x04
     828:	81 30       	cpi	r24, 0x01	; 1
     82a:	59 f4       	brne	.+22     	; 0x842 <LCD_Task+0xfe>
		{
			LCD_displayStringRowColumn(1 , 0 , ButtonPressedString);
     82c:	9e 01       	movw	r18, r28
     82e:	2a 5f       	subi	r18, 0xFA	; 250
     830:	3f 4f       	sbci	r19, 0xFF	; 255
     832:	81 e0       	ldi	r24, 0x01	; 1
     834:	60 e0       	ldi	r22, 0x00	; 0
     836:	a9 01       	movw	r20, r18
     838:	0e 94 a6 09 	call	0x134c	; 0x134c <LCD_displayStringRowColumn>
			Flag = 1;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	8a 83       	std	Y+2, r24	; 0x02
     840:	14 c0       	rjmp	.+40     	; 0x86a <__stack+0xb>
		}
		else if(PushButtonTask_Data == 0)
     842:	8c 81       	ldd	r24, Y+4	; 0x04
     844:	88 23       	and	r24, r24
     846:	89 f4       	brne	.+34     	; 0x86a <__stack+0xb>
		{
			Flag = 0;
     848:	1a 82       	std	Y+2, r1	; 0x02
			if(Flag2 == 1)
     84a:	89 81       	ldd	r24, Y+1	; 0x01
     84c:	81 30       	cpi	r24, 0x01	; 1
     84e:	59 f4       	brne	.+22     	; 0x866 <__stack+0x7>
			{
				LCD_clearScreen();
     850:	0e 94 bf 09 	call	0x137e	; 0x137e <LCD_clearScreen>
				LCD_displayStringRowColumn(0 , 0 , MessageString);
     854:	9e 01       	movw	r18, r28
     856:	29 5e       	subi	r18, 0xE9	; 233
     858:	3f 4f       	sbci	r19, 0xFF	; 255
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	60 e0       	ldi	r22, 0x00	; 0
     85e:	a9 01       	movw	r20, r18
     860:	0e 94 a6 09 	call	0x134c	; 0x134c <LCD_displayStringRowColumn>
     864:	02 c0       	rjmp	.+4      	; 0x86a <__stack+0xb>
			}
			else
			{
				LCD_clearScreen();
     866:	0e 94 bf 09 	call	0x137e	; 0x137e <LCD_clearScreen>
			}
		}

		/*check on Hello Message is received*/
		if(HelloTask_Data == 2)
     86a:	8d 81       	ldd	r24, Y+5	; 0x05
     86c:	82 30       	cpi	r24, 0x02	; 2
     86e:	89 f4       	brne	.+34     	; 0x892 <__stack+0x33>
		{
			LCD_displayStringRowColumn(0 , 0 , MessageString);
     870:	9e 01       	movw	r18, r28
     872:	29 5e       	subi	r18, 0xE9	; 233
     874:	3f 4f       	sbci	r19, 0xFF	; 255
     876:	80 e0       	ldi	r24, 0x00	; 0
     878:	60 e0       	ldi	r22, 0x00	; 0
     87a:	a9 01       	movw	r20, r18
     87c:	0e 94 a6 09 	call	0x134c	; 0x134c <LCD_displayStringRowColumn>
			if(Counter == 0)
     880:	8b 81       	ldd	r24, Y+3	; 0x03
     882:	88 23       	and	r24, r24
     884:	19 f4       	brne	.+6      	; 0x88c <__stack+0x2d>
			{
				Counter++;
     886:	8b 81       	ldd	r24, Y+3	; 0x03
     888:	8f 5f       	subi	r24, 0xFF	; 255
     88a:	8b 83       	std	Y+3, r24	; 0x03
			}

			Flag2 = 1;
     88c:	81 e0       	ldi	r24, 0x01	; 1
     88e:	89 83       	std	Y+1, r24	; 0x01
			HelloTask_Data = 0;
     890:	1d 82       	std	Y+5, r1	; 0x05
		{
			/*Do Nothing*/
		}

		/*Reset counter to Display off Hello message for specific time*/
		if(Counter == 10)
     892:	8b 81       	ldd	r24, Y+3	; 0x03
     894:	8a 30       	cpi	r24, 0x0A	; 10
     896:	91 f4       	brne	.+36     	; 0x8bc <__stack+0x5d>
		{
			Counter = 0;
     898:	1b 82       	std	Y+3, r1	; 0x03
			Flag2 = 0;
     89a:	19 82       	std	Y+1, r1	; 0x01
			if(Flag == 1)
     89c:	8a 81       	ldd	r24, Y+2	; 0x02
     89e:	81 30       	cpi	r24, 0x01	; 1
     8a0:	59 f4       	brne	.+22     	; 0x8b8 <__stack+0x59>
			{
				LCD_clearScreen();
     8a2:	0e 94 bf 09 	call	0x137e	; 0x137e <LCD_clearScreen>
				LCD_displayStringRowColumn(1 , 0 , ButtonPressedString);
     8a6:	9e 01       	movw	r18, r28
     8a8:	2a 5f       	subi	r18, 0xFA	; 250
     8aa:	3f 4f       	sbci	r19, 0xFF	; 255
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	60 e0       	ldi	r22, 0x00	; 0
     8b0:	a9 01       	movw	r20, r18
     8b2:	0e 94 a6 09 	call	0x134c	; 0x134c <LCD_displayStringRowColumn>
     8b6:	02 c0       	rjmp	.+4      	; 0x8bc <__stack+0x5d>
			}
			else
			{
				LCD_clearScreen();
     8b8:	0e 94 bf 09 	call	0x137e	; 0x137e <LCD_clearScreen>
		}
		else
		{
			/*Do Nothing*/
		}
		vTaskDelay(20);
     8bc:	84 e1       	ldi	r24, 0x14	; 20
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
     8c4:	92 cf       	rjmp	.-220    	; 0x7ea <LCD_Task+0xa6>

000008c6 <SendHallo_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void SendHallo_Task(void * a_Task_ptr)
{
     8c6:	df 93       	push	r29
     8c8:	cf 93       	push	r28
     8ca:	00 d0       	rcall	.+0      	; 0x8cc <SendHallo_Task+0x6>
     8cc:	0f 92       	push	r0
     8ce:	cd b7       	in	r28, 0x3d	; 61
     8d0:	de b7       	in	r29, 0x3e	; 62
     8d2:	9b 83       	std	Y+3, r25	; 0x03
     8d4:	8a 83       	std	Y+2, r24	; 0x02
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 2;
     8d6:	82 e0       	ldi	r24, 0x02	; 2
     8d8:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		xQueueSend(MessageQueue_Hello , &SendData , 10);
     8da:	80 91 c6 00 	lds	r24, 0x00C6
     8de:	90 91 c7 00 	lds	r25, 0x00C7
     8e2:	9e 01       	movw	r18, r28
     8e4:	2f 5f       	subi	r18, 0xFF	; 255
     8e6:	3f 4f       	sbci	r19, 0xFF	; 255
     8e8:	b9 01       	movw	r22, r18
     8ea:	4a e0       	ldi	r20, 0x0A	; 10
     8ec:	50 e0       	ldi	r21, 0x00	; 0
     8ee:	20 e0       	ldi	r18, 0x00	; 0
     8f0:	0e 94 fe 0e 	call	0x1dfc	; 0x1dfc <xQueueGenericSend>
		vTaskDelay(400);
     8f4:	80 e9       	ldi	r24, 0x90	; 144
     8f6:	91 e0       	ldi	r25, 0x01	; 1
     8f8:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
     8fc:	ee cf       	rjmp	.-36     	; 0x8da <SendHallo_Task+0x14>

000008fe <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     8fe:	df 93       	push	r29
     900:	cf 93       	push	r28
     902:	00 d0       	rcall	.+0      	; 0x904 <xEventGroupCreate+0x6>
     904:	cd b7       	in	r28, 0x3d	; 61
     906:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     908:	8b e0       	ldi	r24, 0x0B	; 11
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
     910:	9a 83       	std	Y+2, r25	; 0x02
     912:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     914:	89 81       	ldd	r24, Y+1	; 0x01
     916:	9a 81       	ldd	r25, Y+2	; 0x02
     918:	00 97       	sbiw	r24, 0x00	; 0
     91a:	49 f0       	breq	.+18     	; 0x92e <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     91c:	e9 81       	ldd	r30, Y+1	; 0x01
     91e:	fa 81       	ldd	r31, Y+2	; 0x02
     920:	11 82       	std	Z+1, r1	; 0x01
     922:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     924:	89 81       	ldd	r24, Y+1	; 0x01
     926:	9a 81       	ldd	r25, Y+2	; 0x02
     928:	02 96       	adiw	r24, 0x02	; 2
     92a:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     932:	0f 90       	pop	r0
     934:	0f 90       	pop	r0
     936:	cf 91       	pop	r28
     938:	df 91       	pop	r29
     93a:	08 95       	ret

0000093c <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     93c:	df 93       	push	r29
     93e:	cf 93       	push	r28
     940:	cd b7       	in	r28, 0x3d	; 61
     942:	de b7       	in	r29, 0x3e	; 62
     944:	60 97       	sbiw	r28, 0x10	; 16
     946:	0f b6       	in	r0, 0x3f	; 63
     948:	f8 94       	cli
     94a:	de bf       	out	0x3e, r29	; 62
     94c:	0f be       	out	0x3f, r0	; 63
     94e:	cd bf       	out	0x3d, r28	; 61
     950:	9a 87       	std	Y+10, r25	; 0x0a
     952:	89 87       	std	Y+9, r24	; 0x09
     954:	7c 87       	std	Y+12, r23	; 0x0c
     956:	6b 87       	std	Y+11, r22	; 0x0b
     958:	5e 87       	std	Y+14, r21	; 0x0e
     95a:	4d 87       	std	Y+13, r20	; 0x0d
     95c:	38 8b       	std	Y+16, r19	; 0x10
     95e:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     960:	89 85       	ldd	r24, Y+9	; 0x09
     962:	9a 85       	ldd	r25, Y+10	; 0x0a
     964:	9c 83       	std	Y+4, r25	; 0x04
     966:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     968:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     96a:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     96e:	eb 81       	ldd	r30, Y+3	; 0x03
     970:	fc 81       	ldd	r31, Y+4	; 0x04
     972:	80 81       	ld	r24, Z
     974:	91 81       	ldd	r25, Z+1	; 0x01
     976:	98 87       	std	Y+8, r25	; 0x08
     978:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     97a:	89 85       	ldd	r24, Y+9	; 0x09
     97c:	9a 85       	ldd	r25, Y+10	; 0x0a
     97e:	2b 85       	ldd	r18, Y+11	; 0x0b
     980:	3c 85       	ldd	r19, Y+12	; 0x0c
     982:	b9 01       	movw	r22, r18
     984:	0e 94 75 06 	call	0xcea	; 0xcea <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     988:	2f 81       	ldd	r18, Y+7	; 0x07
     98a:	38 85       	ldd	r19, Y+8	; 0x08
     98c:	8b 85       	ldd	r24, Y+11	; 0x0b
     98e:	9c 85       	ldd	r25, Y+12	; 0x0c
     990:	28 2b       	or	r18, r24
     992:	39 2b       	or	r19, r25
     994:	8d 85       	ldd	r24, Y+13	; 0x0d
     996:	9e 85       	ldd	r25, Y+14	; 0x0e
     998:	28 23       	and	r18, r24
     99a:	39 23       	and	r19, r25
     99c:	8d 85       	ldd	r24, Y+13	; 0x0d
     99e:	9e 85       	ldd	r25, Y+14	; 0x0e
     9a0:	28 17       	cp	r18, r24
     9a2:	39 07       	cpc	r19, r25
     9a4:	c9 f4       	brne	.+50     	; 0x9d8 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     9a6:	2f 81       	ldd	r18, Y+7	; 0x07
     9a8:	38 85       	ldd	r19, Y+8	; 0x08
     9aa:	8b 85       	ldd	r24, Y+11	; 0x0b
     9ac:	9c 85       	ldd	r25, Y+12	; 0x0c
     9ae:	82 2b       	or	r24, r18
     9b0:	93 2b       	or	r25, r19
     9b2:	9e 83       	std	Y+6, r25	; 0x06
     9b4:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9b6:	eb 81       	ldd	r30, Y+3	; 0x03
     9b8:	fc 81       	ldd	r31, Y+4	; 0x04
     9ba:	20 81       	ld	r18, Z
     9bc:	31 81       	ldd	r19, Z+1	; 0x01
     9be:	8d 85       	ldd	r24, Y+13	; 0x0d
     9c0:	9e 85       	ldd	r25, Y+14	; 0x0e
     9c2:	80 95       	com	r24
     9c4:	90 95       	com	r25
     9c6:	82 23       	and	r24, r18
     9c8:	93 23       	and	r25, r19
     9ca:	eb 81       	ldd	r30, Y+3	; 0x03
     9cc:	fc 81       	ldd	r31, Y+4	; 0x04
     9ce:	91 83       	std	Z+1, r25	; 0x01
     9d0:	80 83       	st	Z, r24

			xTicksToWait = 0;
     9d2:	18 8a       	std	Y+16, r1	; 0x10
     9d4:	1f 86       	std	Y+15, r1	; 0x0f
     9d6:	1e c0       	rjmp	.+60     	; 0xa14 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     9d8:	8f 85       	ldd	r24, Y+15	; 0x0f
     9da:	98 89       	ldd	r25, Y+16	; 0x10
     9dc:	00 97       	sbiw	r24, 0x00	; 0
     9de:	91 f0       	breq	.+36     	; 0xa04 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     9e0:	8b 81       	ldd	r24, Y+3	; 0x03
     9e2:	9c 81       	ldd	r25, Y+4	; 0x04
     9e4:	bc 01       	movw	r22, r24
     9e6:	6e 5f       	subi	r22, 0xFE	; 254
     9e8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ea:	8d 85       	ldd	r24, Y+13	; 0x0d
     9ec:	9e 85       	ldd	r25, Y+14	; 0x0e
     9ee:	9c 01       	movw	r18, r24
     9f0:	35 60       	ori	r19, 0x05	; 5
     9f2:	4f 85       	ldd	r20, Y+15	; 0x0f
     9f4:	58 89       	ldd	r21, Y+16	; 0x10
     9f6:	cb 01       	movw	r24, r22
     9f8:	b9 01       	movw	r22, r18
     9fa:	0e 94 fd 22 	call	0x45fa	; 0x45fa <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     9fe:	1e 82       	std	Y+6, r1	; 0x06
     a00:	1d 82       	std	Y+5, r1	; 0x05
     a02:	08 c0       	rjmp	.+16     	; 0xa14 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     a04:	eb 81       	ldd	r30, Y+3	; 0x03
     a06:	fc 81       	ldd	r31, Y+4	; 0x04
     a08:	80 81       	ld	r24, Z
     a0a:	91 81       	ldd	r25, Z+1	; 0x01
     a0c:	9e 83       	std	Y+6, r25	; 0x06
     a0e:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     a14:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
     a18:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     a1a:	8f 85       	ldd	r24, Y+15	; 0x0f
     a1c:	98 89       	ldd	r25, Y+16	; 0x10
     a1e:	00 97       	sbiw	r24, 0x00	; 0
     a20:	09 f4       	brne	.+2      	; 0xa24 <xEventGroupSync+0xe8>
     a22:	3a c0       	rjmp	.+116    	; 0xa98 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     a24:	8a 81       	ldd	r24, Y+2	; 0x02
     a26:	88 23       	and	r24, r24
     a28:	11 f4       	brne	.+4      	; 0xa2e <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     a2a:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     a2e:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <uxTaskResetEventItemValue>
     a32:	9e 83       	std	Y+6, r25	; 0x06
     a34:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     a36:	8d 81       	ldd	r24, Y+5	; 0x05
     a38:	9e 81       	ldd	r25, Y+6	; 0x06
     a3a:	80 70       	andi	r24, 0x00	; 0
     a3c:	92 70       	andi	r25, 0x02	; 2
     a3e:	00 97       	sbiw	r24, 0x00	; 0
     a40:	31 f5       	brne	.+76     	; 0xa8e <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     a42:	0f b6       	in	r0, 0x3f	; 63
     a44:	f8 94       	cli
     a46:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     a48:	eb 81       	ldd	r30, Y+3	; 0x03
     a4a:	fc 81       	ldd	r31, Y+4	; 0x04
     a4c:	80 81       	ld	r24, Z
     a4e:	91 81       	ldd	r25, Z+1	; 0x01
     a50:	9e 83       	std	Y+6, r25	; 0x06
     a52:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     a54:	2d 81       	ldd	r18, Y+5	; 0x05
     a56:	3e 81       	ldd	r19, Y+6	; 0x06
     a58:	8d 85       	ldd	r24, Y+13	; 0x0d
     a5a:	9e 85       	ldd	r25, Y+14	; 0x0e
     a5c:	28 23       	and	r18, r24
     a5e:	39 23       	and	r19, r25
     a60:	8d 85       	ldd	r24, Y+13	; 0x0d
     a62:	9e 85       	ldd	r25, Y+14	; 0x0e
     a64:	28 17       	cp	r18, r24
     a66:	39 07       	cpc	r19, r25
     a68:	71 f4       	brne	.+28     	; 0xa86 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a6a:	eb 81       	ldd	r30, Y+3	; 0x03
     a6c:	fc 81       	ldd	r31, Y+4	; 0x04
     a6e:	20 81       	ld	r18, Z
     a70:	31 81       	ldd	r19, Z+1	; 0x01
     a72:	8d 85       	ldd	r24, Y+13	; 0x0d
     a74:	9e 85       	ldd	r25, Y+14	; 0x0e
     a76:	80 95       	com	r24
     a78:	90 95       	com	r25
     a7a:	82 23       	and	r24, r18
     a7c:	93 23       	and	r25, r19
     a7e:	eb 81       	ldd	r30, Y+3	; 0x03
     a80:	fc 81       	ldd	r31, Y+4	; 0x04
     a82:	91 83       	std	Z+1, r25	; 0x01
     a84:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     a86:	0f 90       	pop	r0
     a88:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     a8a:	81 e0       	ldi	r24, 0x01	; 1
     a8c:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     a8e:	8d 81       	ldd	r24, Y+5	; 0x05
     a90:	9e 81       	ldd	r25, Y+6	; 0x06
     a92:	90 70       	andi	r25, 0x00	; 0
     a94:	9e 83       	std	Y+6, r25	; 0x06
     a96:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     a98:	8d 81       	ldd	r24, Y+5	; 0x05
     a9a:	9e 81       	ldd	r25, Y+6	; 0x06
}
     a9c:	60 96       	adiw	r28, 0x10	; 16
     a9e:	0f b6       	in	r0, 0x3f	; 63
     aa0:	f8 94       	cli
     aa2:	de bf       	out	0x3e, r29	; 62
     aa4:	0f be       	out	0x3f, r0	; 63
     aa6:	cd bf       	out	0x3d, r28	; 61
     aa8:	cf 91       	pop	r28
     aaa:	df 91       	pop	r29
     aac:	08 95       	ret

00000aae <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     aae:	0f 93       	push	r16
     ab0:	1f 93       	push	r17
     ab2:	df 93       	push	r29
     ab4:	cf 93       	push	r28
     ab6:	cd b7       	in	r28, 0x3d	; 61
     ab8:	de b7       	in	r29, 0x3e	; 62
     aba:	63 97       	sbiw	r28, 0x13	; 19
     abc:	0f b6       	in	r0, 0x3f	; 63
     abe:	f8 94       	cli
     ac0:	de bf       	out	0x3e, r29	; 62
     ac2:	0f be       	out	0x3f, r0	; 63
     ac4:	cd bf       	out	0x3d, r28	; 61
     ac6:	9d 87       	std	Y+13, r25	; 0x0d
     ac8:	8c 87       	std	Y+12, r24	; 0x0c
     aca:	7f 87       	std	Y+15, r23	; 0x0f
     acc:	6e 87       	std	Y+14, r22	; 0x0e
     ace:	48 8b       	std	Y+16, r20	; 0x10
     ad0:	29 8b       	std	Y+17, r18	; 0x11
     ad2:	1b 8b       	std	Y+19, r17	; 0x13
     ad4:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     ad6:	8c 85       	ldd	r24, Y+12	; 0x0c
     ad8:	9d 85       	ldd	r25, Y+13	; 0x0d
     ada:	9b 87       	std	Y+11, r25	; 0x0b
     adc:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     ade:	1f 82       	std	Y+7, r1	; 0x07
     ae0:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     ae2:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     ae4:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     ae8:	ea 85       	ldd	r30, Y+10	; 0x0a
     aea:	fb 85       	ldd	r31, Y+11	; 0x0b
     aec:	80 81       	ld	r24, Z
     aee:	91 81       	ldd	r25, Z+1	; 0x01
     af0:	9a 83       	std	Y+2, r25	; 0x02
     af2:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     af4:	89 81       	ldd	r24, Y+1	; 0x01
     af6:	9a 81       	ldd	r25, Y+2	; 0x02
     af8:	2e 85       	ldd	r18, Y+14	; 0x0e
     afa:	3f 85       	ldd	r19, Y+15	; 0x0f
     afc:	b9 01       	movw	r22, r18
     afe:	49 89       	ldd	r20, Y+17	; 0x11
     b00:	0e 94 92 07 	call	0xf24	; 0xf24 <prvTestWaitCondition>
     b04:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     b06:	8d 81       	ldd	r24, Y+5	; 0x05
     b08:	88 23       	and	r24, r24
     b0a:	c1 f0       	breq	.+48     	; 0xb3c <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     b0c:	89 81       	ldd	r24, Y+1	; 0x01
     b0e:	9a 81       	ldd	r25, Y+2	; 0x02
     b10:	99 87       	std	Y+9, r25	; 0x09
     b12:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     b14:	1b 8a       	std	Y+19, r1	; 0x13
     b16:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     b18:	88 89       	ldd	r24, Y+16	; 0x10
     b1a:	88 23       	and	r24, r24
     b1c:	e9 f1       	breq	.+122    	; 0xb98 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     b1e:	ea 85       	ldd	r30, Y+10	; 0x0a
     b20:	fb 85       	ldd	r31, Y+11	; 0x0b
     b22:	20 81       	ld	r18, Z
     b24:	31 81       	ldd	r19, Z+1	; 0x01
     b26:	8e 85       	ldd	r24, Y+14	; 0x0e
     b28:	9f 85       	ldd	r25, Y+15	; 0x0f
     b2a:	80 95       	com	r24
     b2c:	90 95       	com	r25
     b2e:	82 23       	and	r24, r18
     b30:	93 23       	and	r25, r19
     b32:	ea 85       	ldd	r30, Y+10	; 0x0a
     b34:	fb 85       	ldd	r31, Y+11	; 0x0b
     b36:	91 83       	std	Z+1, r25	; 0x01
     b38:	80 83       	st	Z, r24
     b3a:	2e c0       	rjmp	.+92     	; 0xb98 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     b3c:	8a 89       	ldd	r24, Y+18	; 0x12
     b3e:	9b 89       	ldd	r25, Y+19	; 0x13
     b40:	00 97       	sbiw	r24, 0x00	; 0
     b42:	39 f4       	brne	.+14     	; 0xb52 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     b44:	89 81       	ldd	r24, Y+1	; 0x01
     b46:	9a 81       	ldd	r25, Y+2	; 0x02
     b48:	99 87       	std	Y+9, r25	; 0x09
     b4a:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	8b 83       	std	Y+3, r24	; 0x03
     b50:	23 c0       	rjmp	.+70     	; 0xb98 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     b52:	88 89       	ldd	r24, Y+16	; 0x10
     b54:	88 23       	and	r24, r24
     b56:	29 f0       	breq	.+10     	; 0xb62 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     b58:	8e 81       	ldd	r24, Y+6	; 0x06
     b5a:	9f 81       	ldd	r25, Y+7	; 0x07
     b5c:	91 60       	ori	r25, 0x01	; 1
     b5e:	9f 83       	std	Y+7, r25	; 0x07
     b60:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     b62:	89 89       	ldd	r24, Y+17	; 0x11
     b64:	88 23       	and	r24, r24
     b66:	29 f0       	breq	.+10     	; 0xb72 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     b68:	8e 81       	ldd	r24, Y+6	; 0x06
     b6a:	9f 81       	ldd	r25, Y+7	; 0x07
     b6c:	94 60       	ori	r25, 0x04	; 4
     b6e:	9f 83       	std	Y+7, r25	; 0x07
     b70:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     b72:	8a 85       	ldd	r24, Y+10	; 0x0a
     b74:	9b 85       	ldd	r25, Y+11	; 0x0b
     b76:	bc 01       	movw	r22, r24
     b78:	6e 5f       	subi	r22, 0xFE	; 254
     b7a:	7f 4f       	sbci	r23, 0xFF	; 255
     b7c:	2e 85       	ldd	r18, Y+14	; 0x0e
     b7e:	3f 85       	ldd	r19, Y+15	; 0x0f
     b80:	8e 81       	ldd	r24, Y+6	; 0x06
     b82:	9f 81       	ldd	r25, Y+7	; 0x07
     b84:	28 2b       	or	r18, r24
     b86:	39 2b       	or	r19, r25
     b88:	4a 89       	ldd	r20, Y+18	; 0x12
     b8a:	5b 89       	ldd	r21, Y+19	; 0x13
     b8c:	cb 01       	movw	r24, r22
     b8e:	b9 01       	movw	r22, r18
     b90:	0e 94 fd 22 	call	0x45fa	; 0x45fa <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     b94:	19 86       	std	Y+9, r1	; 0x09
     b96:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     b98:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
     b9c:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     b9e:	8a 89       	ldd	r24, Y+18	; 0x12
     ba0:	9b 89       	ldd	r25, Y+19	; 0x13
     ba2:	00 97       	sbiw	r24, 0x00	; 0
     ba4:	09 f4       	brne	.+2      	; 0xba8 <xEventGroupWaitBits+0xfa>
     ba6:	3c c0       	rjmp	.+120    	; 0xc20 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     ba8:	8c 81       	ldd	r24, Y+4	; 0x04
     baa:	88 23       	and	r24, r24
     bac:	11 f4       	brne	.+4      	; 0xbb2 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     bae:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     bb2:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <uxTaskResetEventItemValue>
     bb6:	99 87       	std	Y+9, r25	; 0x09
     bb8:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     bba:	88 85       	ldd	r24, Y+8	; 0x08
     bbc:	99 85       	ldd	r25, Y+9	; 0x09
     bbe:	80 70       	andi	r24, 0x00	; 0
     bc0:	92 70       	andi	r25, 0x02	; 2
     bc2:	00 97       	sbiw	r24, 0x00	; 0
     bc4:	41 f5       	brne	.+80     	; 0xc16 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     bcc:	ea 85       	ldd	r30, Y+10	; 0x0a
     bce:	fb 85       	ldd	r31, Y+11	; 0x0b
     bd0:	80 81       	ld	r24, Z
     bd2:	91 81       	ldd	r25, Z+1	; 0x01
     bd4:	99 87       	std	Y+9, r25	; 0x09
     bd6:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     bd8:	88 85       	ldd	r24, Y+8	; 0x08
     bda:	99 85       	ldd	r25, Y+9	; 0x09
     bdc:	2e 85       	ldd	r18, Y+14	; 0x0e
     bde:	3f 85       	ldd	r19, Y+15	; 0x0f
     be0:	b9 01       	movw	r22, r18
     be2:	49 89       	ldd	r20, Y+17	; 0x11
     be4:	0e 94 92 07 	call	0xf24	; 0xf24 <prvTestWaitCondition>
     be8:	88 23       	and	r24, r24
     bea:	89 f0       	breq	.+34     	; 0xc0e <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     bec:	88 89       	ldd	r24, Y+16	; 0x10
     bee:	88 23       	and	r24, r24
     bf0:	71 f0       	breq	.+28     	; 0xc0e <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     bf2:	ea 85       	ldd	r30, Y+10	; 0x0a
     bf4:	fb 85       	ldd	r31, Y+11	; 0x0b
     bf6:	20 81       	ld	r18, Z
     bf8:	31 81       	ldd	r19, Z+1	; 0x01
     bfa:	8e 85       	ldd	r24, Y+14	; 0x0e
     bfc:	9f 85       	ldd	r25, Y+15	; 0x0f
     bfe:	80 95       	com	r24
     c00:	90 95       	com	r25
     c02:	82 23       	and	r24, r18
     c04:	93 23       	and	r25, r19
     c06:	ea 85       	ldd	r30, Y+10	; 0x0a
     c08:	fb 85       	ldd	r31, Y+11	; 0x0b
     c0a:	91 83       	std	Z+1, r25	; 0x01
     c0c:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     c12:	0f 90       	pop	r0
     c14:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     c16:	88 85       	ldd	r24, Y+8	; 0x08
     c18:	99 85       	ldd	r25, Y+9	; 0x09
     c1a:	90 70       	andi	r25, 0x00	; 0
     c1c:	99 87       	std	Y+9, r25	; 0x09
     c1e:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     c20:	88 85       	ldd	r24, Y+8	; 0x08
     c22:	99 85       	ldd	r25, Y+9	; 0x09
}
     c24:	63 96       	adiw	r28, 0x13	; 19
     c26:	0f b6       	in	r0, 0x3f	; 63
     c28:	f8 94       	cli
     c2a:	de bf       	out	0x3e, r29	; 62
     c2c:	0f be       	out	0x3f, r0	; 63
     c2e:	cd bf       	out	0x3d, r28	; 61
     c30:	cf 91       	pop	r28
     c32:	df 91       	pop	r29
     c34:	1f 91       	pop	r17
     c36:	0f 91       	pop	r16
     c38:	08 95       	ret

00000c3a <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     c3a:	df 93       	push	r29
     c3c:	cf 93       	push	r28
     c3e:	cd b7       	in	r28, 0x3d	; 61
     c40:	de b7       	in	r29, 0x3e	; 62
     c42:	28 97       	sbiw	r28, 0x08	; 8
     c44:	0f b6       	in	r0, 0x3f	; 63
     c46:	f8 94       	cli
     c48:	de bf       	out	0x3e, r29	; 62
     c4a:	0f be       	out	0x3f, r0	; 63
     c4c:	cd bf       	out	0x3d, r28	; 61
     c4e:	9e 83       	std	Y+6, r25	; 0x06
     c50:	8d 83       	std	Y+5, r24	; 0x05
     c52:	78 87       	std	Y+8, r23	; 0x08
     c54:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     c56:	8d 81       	ldd	r24, Y+5	; 0x05
     c58:	9e 81       	ldd	r25, Y+6	; 0x06
     c5a:	9c 83       	std	Y+4, r25	; 0x04
     c5c:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     c5e:	0f b6       	in	r0, 0x3f	; 63
     c60:	f8 94       	cli
     c62:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     c64:	eb 81       	ldd	r30, Y+3	; 0x03
     c66:	fc 81       	ldd	r31, Y+4	; 0x04
     c68:	80 81       	ld	r24, Z
     c6a:	91 81       	ldd	r25, Z+1	; 0x01
     c6c:	9a 83       	std	Y+2, r25	; 0x02
     c6e:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     c70:	eb 81       	ldd	r30, Y+3	; 0x03
     c72:	fc 81       	ldd	r31, Y+4	; 0x04
     c74:	20 81       	ld	r18, Z
     c76:	31 81       	ldd	r19, Z+1	; 0x01
     c78:	8f 81       	ldd	r24, Y+7	; 0x07
     c7a:	98 85       	ldd	r25, Y+8	; 0x08
     c7c:	80 95       	com	r24
     c7e:	90 95       	com	r25
     c80:	82 23       	and	r24, r18
     c82:	93 23       	and	r25, r19
     c84:	eb 81       	ldd	r30, Y+3	; 0x03
     c86:	fc 81       	ldd	r31, Y+4	; 0x04
     c88:	91 83       	std	Z+1, r25	; 0x01
     c8a:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     c8c:	0f 90       	pop	r0
     c8e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     c90:	89 81       	ldd	r24, Y+1	; 0x01
     c92:	9a 81       	ldd	r25, Y+2	; 0x02
}
     c94:	28 96       	adiw	r28, 0x08	; 8
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	de bf       	out	0x3e, r29	; 62
     c9c:	0f be       	out	0x3f, r0	; 63
     c9e:	cd bf       	out	0x3d, r28	; 61
     ca0:	cf 91       	pop	r28
     ca2:	df 91       	pop	r29
     ca4:	08 95       	ret

00000ca6 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     ca6:	df 93       	push	r29
     ca8:	cf 93       	push	r28
     caa:	cd b7       	in	r28, 0x3d	; 61
     cac:	de b7       	in	r29, 0x3e	; 62
     cae:	27 97       	sbiw	r28, 0x07	; 7
     cb0:	0f b6       	in	r0, 0x3f	; 63
     cb2:	f8 94       	cli
     cb4:	de bf       	out	0x3e, r29	; 62
     cb6:	0f be       	out	0x3f, r0	; 63
     cb8:	cd bf       	out	0x3d, r28	; 61
     cba:	9f 83       	std	Y+7, r25	; 0x07
     cbc:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     cbe:	8e 81       	ldd	r24, Y+6	; 0x06
     cc0:	9f 81       	ldd	r25, Y+7	; 0x07
     cc2:	9c 83       	std	Y+4, r25	; 0x04
     cc4:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     cc6:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     cc8:	eb 81       	ldd	r30, Y+3	; 0x03
     cca:	fc 81       	ldd	r31, Y+4	; 0x04
     ccc:	80 81       	ld	r24, Z
     cce:	91 81       	ldd	r25, Z+1	; 0x01
     cd0:	9a 83       	std	Y+2, r25	; 0x02
     cd2:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     cd4:	89 81       	ldd	r24, Y+1	; 0x01
     cd6:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     cd8:	27 96       	adiw	r28, 0x07	; 7
     cda:	0f b6       	in	r0, 0x3f	; 63
     cdc:	f8 94       	cli
     cde:	de bf       	out	0x3e, r29	; 62
     ce0:	0f be       	out	0x3f, r0	; 63
     ce2:	cd bf       	out	0x3d, r28	; 61
     ce4:	cf 91       	pop	r28
     ce6:	df 91       	pop	r29
     ce8:	08 95       	ret

00000cea <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     cea:	df 93       	push	r29
     cec:	cf 93       	push	r28
     cee:	cd b7       	in	r28, 0x3d	; 61
     cf0:	de b7       	in	r29, 0x3e	; 62
     cf2:	65 97       	sbiw	r28, 0x15	; 21
     cf4:	0f b6       	in	r0, 0x3f	; 63
     cf6:	f8 94       	cli
     cf8:	de bf       	out	0x3e, r29	; 62
     cfa:	0f be       	out	0x3f, r0	; 63
     cfc:	cd bf       	out	0x3d, r28	; 61
     cfe:	9b 8b       	std	Y+19, r25	; 0x13
     d00:	8a 8b       	std	Y+18, r24	; 0x12
     d02:	7d 8b       	std	Y+21, r23	; 0x15
     d04:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     d06:	19 86       	std	Y+9, r1	; 0x09
     d08:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     d0a:	8a 89       	ldd	r24, Y+18	; 0x12
     d0c:	9b 89       	ldd	r25, Y+19	; 0x13
     d0e:	9b 83       	std	Y+3, r25	; 0x03
     d10:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     d12:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     d14:	8a 81       	ldd	r24, Y+2	; 0x02
     d16:	9b 81       	ldd	r25, Y+3	; 0x03
     d18:	02 96       	adiw	r24, 0x02	; 2
     d1a:	9b 87       	std	Y+11, r25	; 0x0b
     d1c:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     d1e:	8a 85       	ldd	r24, Y+10	; 0x0a
     d20:	9b 85       	ldd	r25, Y+11	; 0x0b
     d22:	03 96       	adiw	r24, 0x03	; 3
     d24:	9d 87       	std	Y+13, r25	; 0x0d
     d26:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     d28:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     d2c:	ea 85       	ldd	r30, Y+10	; 0x0a
     d2e:	fb 85       	ldd	r31, Y+11	; 0x0b
     d30:	85 81       	ldd	r24, Z+5	; 0x05
     d32:	96 81       	ldd	r25, Z+6	; 0x06
     d34:	99 8b       	std	Y+17, r25	; 0x11
     d36:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     d38:	ea 81       	ldd	r30, Y+2	; 0x02
     d3a:	fb 81       	ldd	r31, Y+3	; 0x03
     d3c:	20 81       	ld	r18, Z
     d3e:	31 81       	ldd	r19, Z+1	; 0x01
     d40:	8c 89       	ldd	r24, Y+20	; 0x14
     d42:	9d 89       	ldd	r25, Y+21	; 0x15
     d44:	82 2b       	or	r24, r18
     d46:	93 2b       	or	r25, r19
     d48:	ea 81       	ldd	r30, Y+2	; 0x02
     d4a:	fb 81       	ldd	r31, Y+3	; 0x03
     d4c:	91 83       	std	Z+1, r25	; 0x01
     d4e:	80 83       	st	Z, r24
     d50:	59 c0       	rjmp	.+178    	; 0xe04 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     d52:	e8 89       	ldd	r30, Y+16	; 0x10
     d54:	f9 89       	ldd	r31, Y+17	; 0x11
     d56:	82 81       	ldd	r24, Z+2	; 0x02
     d58:	93 81       	ldd	r25, Z+3	; 0x03
     d5a:	9f 87       	std	Y+15, r25	; 0x0f
     d5c:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     d5e:	e8 89       	ldd	r30, Y+16	; 0x10
     d60:	f9 89       	ldd	r31, Y+17	; 0x11
     d62:	80 81       	ld	r24, Z
     d64:	91 81       	ldd	r25, Z+1	; 0x01
     d66:	9f 83       	std	Y+7, r25	; 0x07
     d68:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     d6a:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     d6c:	8e 81       	ldd	r24, Y+6	; 0x06
     d6e:	9f 81       	ldd	r25, Y+7	; 0x07
     d70:	80 70       	andi	r24, 0x00	; 0
     d72:	9d 83       	std	Y+5, r25	; 0x05
     d74:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     d76:	8e 81       	ldd	r24, Y+6	; 0x06
     d78:	9f 81       	ldd	r25, Y+7	; 0x07
     d7a:	90 70       	andi	r25, 0x00	; 0
     d7c:	9f 83       	std	Y+7, r25	; 0x07
     d7e:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     d80:	8c 81       	ldd	r24, Y+4	; 0x04
     d82:	9d 81       	ldd	r25, Y+5	; 0x05
     d84:	80 70       	andi	r24, 0x00	; 0
     d86:	94 70       	andi	r25, 0x04	; 4
     d88:	00 97       	sbiw	r24, 0x00	; 0
     d8a:	69 f4       	brne	.+26     	; 0xda6 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     d8c:	ea 81       	ldd	r30, Y+2	; 0x02
     d8e:	fb 81       	ldd	r31, Y+3	; 0x03
     d90:	20 81       	ld	r18, Z
     d92:	31 81       	ldd	r19, Z+1	; 0x01
     d94:	8e 81       	ldd	r24, Y+6	; 0x06
     d96:	9f 81       	ldd	r25, Y+7	; 0x07
     d98:	82 23       	and	r24, r18
     d9a:	93 23       	and	r25, r19
     d9c:	00 97       	sbiw	r24, 0x00	; 0
     d9e:	91 f0       	breq	.+36     	; 0xdc4 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     da0:	81 e0       	ldi	r24, 0x01	; 1
     da2:	89 83       	std	Y+1, r24	; 0x01
     da4:	0f c0       	rjmp	.+30     	; 0xdc4 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     da6:	ea 81       	ldd	r30, Y+2	; 0x02
     da8:	fb 81       	ldd	r31, Y+3	; 0x03
     daa:	20 81       	ld	r18, Z
     dac:	31 81       	ldd	r19, Z+1	; 0x01
     dae:	8e 81       	ldd	r24, Y+6	; 0x06
     db0:	9f 81       	ldd	r25, Y+7	; 0x07
     db2:	28 23       	and	r18, r24
     db4:	39 23       	and	r19, r25
     db6:	8e 81       	ldd	r24, Y+6	; 0x06
     db8:	9f 81       	ldd	r25, Y+7	; 0x07
     dba:	28 17       	cp	r18, r24
     dbc:	39 07       	cpc	r19, r25
     dbe:	11 f4       	brne	.+4      	; 0xdc4 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     dc0:	81 e0       	ldi	r24, 0x01	; 1
     dc2:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     dc4:	89 81       	ldd	r24, Y+1	; 0x01
     dc6:	88 23       	and	r24, r24
     dc8:	c9 f0       	breq	.+50     	; 0xdfc <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     dca:	8c 81       	ldd	r24, Y+4	; 0x04
     dcc:	9d 81       	ldd	r25, Y+5	; 0x05
     dce:	80 70       	andi	r24, 0x00	; 0
     dd0:	91 70       	andi	r25, 0x01	; 1
     dd2:	00 97       	sbiw	r24, 0x00	; 0
     dd4:	41 f0       	breq	.+16     	; 0xde6 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     dd6:	88 85       	ldd	r24, Y+8	; 0x08
     dd8:	99 85       	ldd	r25, Y+9	; 0x09
     dda:	2e 81       	ldd	r18, Y+6	; 0x06
     ddc:	3f 81       	ldd	r19, Y+7	; 0x07
     dde:	82 2b       	or	r24, r18
     de0:	93 2b       	or	r25, r19
     de2:	99 87       	std	Y+9, r25	; 0x09
     de4:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     de6:	ea 81       	ldd	r30, Y+2	; 0x02
     de8:	fb 81       	ldd	r31, Y+3	; 0x03
     dea:	80 81       	ld	r24, Z
     dec:	91 81       	ldd	r25, Z+1	; 0x01
     dee:	9c 01       	movw	r18, r24
     df0:	32 60       	ori	r19, 0x02	; 2
     df2:	88 89       	ldd	r24, Y+16	; 0x10
     df4:	99 89       	ldd	r25, Y+17	; 0x11
     df6:	b9 01       	movw	r22, r18
     df8:	0e 94 98 23 	call	0x4730	; 0x4730 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     dfc:	8e 85       	ldd	r24, Y+14	; 0x0e
     dfe:	9f 85       	ldd	r25, Y+15	; 0x0f
     e00:	99 8b       	std	Y+17, r25	; 0x11
     e02:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     e04:	28 89       	ldd	r18, Y+16	; 0x10
     e06:	39 89       	ldd	r19, Y+17	; 0x11
     e08:	8c 85       	ldd	r24, Y+12	; 0x0c
     e0a:	9d 85       	ldd	r25, Y+13	; 0x0d
     e0c:	28 17       	cp	r18, r24
     e0e:	39 07       	cpc	r19, r25
     e10:	09 f0       	breq	.+2      	; 0xe14 <xEventGroupSetBits+0x12a>
     e12:	9f cf       	rjmp	.-194    	; 0xd52 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     e14:	ea 81       	ldd	r30, Y+2	; 0x02
     e16:	fb 81       	ldd	r31, Y+3	; 0x03
     e18:	20 81       	ld	r18, Z
     e1a:	31 81       	ldd	r19, Z+1	; 0x01
     e1c:	88 85       	ldd	r24, Y+8	; 0x08
     e1e:	99 85       	ldd	r25, Y+9	; 0x09
     e20:	80 95       	com	r24
     e22:	90 95       	com	r25
     e24:	82 23       	and	r24, r18
     e26:	93 23       	and	r25, r19
     e28:	ea 81       	ldd	r30, Y+2	; 0x02
     e2a:	fb 81       	ldd	r31, Y+3	; 0x03
     e2c:	91 83       	std	Z+1, r25	; 0x01
     e2e:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     e30:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     e34:	ea 81       	ldd	r30, Y+2	; 0x02
     e36:	fb 81       	ldd	r31, Y+3	; 0x03
     e38:	80 81       	ld	r24, Z
     e3a:	91 81       	ldd	r25, Z+1	; 0x01
}
     e3c:	65 96       	adiw	r28, 0x15	; 21
     e3e:	0f b6       	in	r0, 0x3f	; 63
     e40:	f8 94       	cli
     e42:	de bf       	out	0x3e, r29	; 62
     e44:	0f be       	out	0x3f, r0	; 63
     e46:	cd bf       	out	0x3d, r28	; 61
     e48:	cf 91       	pop	r28
     e4a:	df 91       	pop	r29
     e4c:	08 95       	ret

00000e4e <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     e4e:	df 93       	push	r29
     e50:	cf 93       	push	r28
     e52:	00 d0       	rcall	.+0      	; 0xe54 <vEventGroupDelete+0x6>
     e54:	00 d0       	rcall	.+0      	; 0xe56 <vEventGroupDelete+0x8>
     e56:	00 d0       	rcall	.+0      	; 0xe58 <vEventGroupDelete+0xa>
     e58:	cd b7       	in	r28, 0x3d	; 61
     e5a:	de b7       	in	r29, 0x3e	; 62
     e5c:	9e 83       	std	Y+6, r25	; 0x06
     e5e:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     e60:	8d 81       	ldd	r24, Y+5	; 0x05
     e62:	9e 81       	ldd	r25, Y+6	; 0x06
     e64:	9c 83       	std	Y+4, r25	; 0x04
     e66:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     e68:	8b 81       	ldd	r24, Y+3	; 0x03
     e6a:	9c 81       	ldd	r25, Y+4	; 0x04
     e6c:	02 96       	adiw	r24, 0x02	; 2
     e6e:	9a 83       	std	Y+2, r25	; 0x02
     e70:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     e72:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
     e76:	08 c0       	rjmp	.+16     	; 0xe88 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     e78:	e9 81       	ldd	r30, Y+1	; 0x01
     e7a:	fa 81       	ldd	r31, Y+2	; 0x02
     e7c:	85 81       	ldd	r24, Z+5	; 0x05
     e7e:	96 81       	ldd	r25, Z+6	; 0x06
     e80:	60 e0       	ldi	r22, 0x00	; 0
     e82:	72 e0       	ldi	r23, 0x02	; 2
     e84:	0e 94 98 23 	call	0x4730	; 0x4730 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     e88:	e9 81       	ldd	r30, Y+1	; 0x01
     e8a:	fa 81       	ldd	r31, Y+2	; 0x02
     e8c:	80 81       	ld	r24, Z
     e8e:	88 23       	and	r24, r24
     e90:	99 f7       	brne	.-26     	; 0xe78 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     e92:	8b 81       	ldd	r24, Y+3	; 0x03
     e94:	9c 81       	ldd	r25, Y+4	; 0x04
     e96:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     e9a:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
}
     e9e:	26 96       	adiw	r28, 0x06	; 6
     ea0:	0f b6       	in	r0, 0x3f	; 63
     ea2:	f8 94       	cli
     ea4:	de bf       	out	0x3e, r29	; 62
     ea6:	0f be       	out	0x3f, r0	; 63
     ea8:	cd bf       	out	0x3d, r28	; 61
     eaa:	cf 91       	pop	r28
     eac:	df 91       	pop	r29
     eae:	08 95       	ret

00000eb0 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     eb0:	df 93       	push	r29
     eb2:	cf 93       	push	r28
     eb4:	00 d0       	rcall	.+0      	; 0xeb6 <vEventGroupSetBitsCallback+0x6>
     eb6:	00 d0       	rcall	.+0      	; 0xeb8 <vEventGroupSetBitsCallback+0x8>
     eb8:	00 d0       	rcall	.+0      	; 0xeba <vEventGroupSetBitsCallback+0xa>
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62
     ebe:	9a 83       	std	Y+2, r25	; 0x02
     ec0:	89 83       	std	Y+1, r24	; 0x01
     ec2:	4b 83       	std	Y+3, r20	; 0x03
     ec4:	5c 83       	std	Y+4, r21	; 0x04
     ec6:	6d 83       	std	Y+5, r22	; 0x05
     ec8:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     eca:	89 81       	ldd	r24, Y+1	; 0x01
     ecc:	9a 81       	ldd	r25, Y+2	; 0x02
     ece:	2b 81       	ldd	r18, Y+3	; 0x03
     ed0:	3c 81       	ldd	r19, Y+4	; 0x04
     ed2:	b9 01       	movw	r22, r18
     ed4:	0e 94 75 06 	call	0xcea	; 0xcea <xEventGroupSetBits>
}
     ed8:	26 96       	adiw	r28, 0x06	; 6
     eda:	0f b6       	in	r0, 0x3f	; 63
     edc:	f8 94       	cli
     ede:	de bf       	out	0x3e, r29	; 62
     ee0:	0f be       	out	0x3f, r0	; 63
     ee2:	cd bf       	out	0x3d, r28	; 61
     ee4:	cf 91       	pop	r28
     ee6:	df 91       	pop	r29
     ee8:	08 95       	ret

00000eea <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     eea:	df 93       	push	r29
     eec:	cf 93       	push	r28
     eee:	00 d0       	rcall	.+0      	; 0xef0 <vEventGroupClearBitsCallback+0x6>
     ef0:	00 d0       	rcall	.+0      	; 0xef2 <vEventGroupClearBitsCallback+0x8>
     ef2:	00 d0       	rcall	.+0      	; 0xef4 <vEventGroupClearBitsCallback+0xa>
     ef4:	cd b7       	in	r28, 0x3d	; 61
     ef6:	de b7       	in	r29, 0x3e	; 62
     ef8:	9a 83       	std	Y+2, r25	; 0x02
     efa:	89 83       	std	Y+1, r24	; 0x01
     efc:	4b 83       	std	Y+3, r20	; 0x03
     efe:	5c 83       	std	Y+4, r21	; 0x04
     f00:	6d 83       	std	Y+5, r22	; 0x05
     f02:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     f04:	89 81       	ldd	r24, Y+1	; 0x01
     f06:	9a 81       	ldd	r25, Y+2	; 0x02
     f08:	2b 81       	ldd	r18, Y+3	; 0x03
     f0a:	3c 81       	ldd	r19, Y+4	; 0x04
     f0c:	b9 01       	movw	r22, r18
     f0e:	0e 94 1d 06 	call	0xc3a	; 0xc3a <xEventGroupClearBits>
}
     f12:	26 96       	adiw	r28, 0x06	; 6
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	f8 94       	cli
     f18:	de bf       	out	0x3e, r29	; 62
     f1a:	0f be       	out	0x3f, r0	; 63
     f1c:	cd bf       	out	0x3d, r28	; 61
     f1e:	cf 91       	pop	r28
     f20:	df 91       	pop	r29
     f22:	08 95       	ret

00000f24 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     f24:	df 93       	push	r29
     f26:	cf 93       	push	r28
     f28:	00 d0       	rcall	.+0      	; 0xf2a <prvTestWaitCondition+0x6>
     f2a:	00 d0       	rcall	.+0      	; 0xf2c <prvTestWaitCondition+0x8>
     f2c:	00 d0       	rcall	.+0      	; 0xf2e <prvTestWaitCondition+0xa>
     f2e:	cd b7       	in	r28, 0x3d	; 61
     f30:	de b7       	in	r29, 0x3e	; 62
     f32:	9b 83       	std	Y+3, r25	; 0x03
     f34:	8a 83       	std	Y+2, r24	; 0x02
     f36:	7d 83       	std	Y+5, r23	; 0x05
     f38:	6c 83       	std	Y+4, r22	; 0x04
     f3a:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     f3c:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     f3e:	8e 81       	ldd	r24, Y+6	; 0x06
     f40:	88 23       	and	r24, r24
     f42:	59 f4       	brne	.+22     	; 0xf5a <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     f44:	8a 81       	ldd	r24, Y+2	; 0x02
     f46:	9b 81       	ldd	r25, Y+3	; 0x03
     f48:	2c 81       	ldd	r18, Y+4	; 0x04
     f4a:	3d 81       	ldd	r19, Y+5	; 0x05
     f4c:	82 23       	and	r24, r18
     f4e:	93 23       	and	r25, r19
     f50:	00 97       	sbiw	r24, 0x00	; 0
     f52:	81 f0       	breq	.+32     	; 0xf74 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	89 83       	std	Y+1, r24	; 0x01
     f58:	0d c0       	rjmp	.+26     	; 0xf74 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     f5a:	2a 81       	ldd	r18, Y+2	; 0x02
     f5c:	3b 81       	ldd	r19, Y+3	; 0x03
     f5e:	8c 81       	ldd	r24, Y+4	; 0x04
     f60:	9d 81       	ldd	r25, Y+5	; 0x05
     f62:	28 23       	and	r18, r24
     f64:	39 23       	and	r19, r25
     f66:	8c 81       	ldd	r24, Y+4	; 0x04
     f68:	9d 81       	ldd	r25, Y+5	; 0x05
     f6a:	28 17       	cp	r18, r24
     f6c:	39 07       	cpc	r19, r25
     f6e:	11 f4       	brne	.+4      	; 0xf74 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     f70:	81 e0       	ldi	r24, 0x01	; 1
     f72:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     f74:	89 81       	ldd	r24, Y+1	; 0x01
}
     f76:	26 96       	adiw	r28, 0x06	; 6
     f78:	0f b6       	in	r0, 0x3f	; 63
     f7a:	f8 94       	cli
     f7c:	de bf       	out	0x3e, r29	; 62
     f7e:	0f be       	out	0x3f, r0	; 63
     f80:	cd bf       	out	0x3d, r28	; 61
     f82:	cf 91       	pop	r28
     f84:	df 91       	pop	r29
     f86:	08 95       	ret

00000f88 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     f88:	df 93       	push	r29
     f8a:	cf 93       	push	r28
     f8c:	00 d0       	rcall	.+0      	; 0xf8e <pvPortMalloc+0x6>
     f8e:	00 d0       	rcall	.+0      	; 0xf90 <pvPortMalloc+0x8>
     f90:	cd b7       	in	r28, 0x3d	; 61
     f92:	de b7       	in	r29, 0x3e	; 62
     f94:	9c 83       	std	Y+4, r25	; 0x04
     f96:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     f98:	1a 82       	std	Y+2, r1	; 0x02
     f9a:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     f9c:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     fa0:	80 91 ca 00 	lds	r24, 0x00CA
     fa4:	90 91 cb 00 	lds	r25, 0x00CB
     fa8:	00 97       	sbiw	r24, 0x00	; 0
     faa:	31 f4       	brne	.+12     	; 0xfb8 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     fac:	8d ec       	ldi	r24, 0xCD	; 205
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	90 93 cb 00 	sts	0x00CB, r25
     fb4:	80 93 ca 00 	sts	0x00CA, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     fb8:	80 91 c8 00 	lds	r24, 0x00C8
     fbc:	90 91 c9 00 	lds	r25, 0x00C9
     fc0:	2b 81       	ldd	r18, Y+3	; 0x03
     fc2:	3c 81       	ldd	r19, Y+4	; 0x04
     fc4:	82 0f       	add	r24, r18
     fc6:	93 1f       	adc	r25, r19
     fc8:	25 e0       	ldi	r18, 0x05	; 5
     fca:	8b 3d       	cpi	r24, 0xDB	; 219
     fcc:	92 07       	cpc	r25, r18
     fce:	38 f5       	brcc	.+78     	; 0x101e <pvPortMalloc+0x96>
     fd0:	20 91 c8 00 	lds	r18, 0x00C8
     fd4:	30 91 c9 00 	lds	r19, 0x00C9
     fd8:	8b 81       	ldd	r24, Y+3	; 0x03
     fda:	9c 81       	ldd	r25, Y+4	; 0x04
     fdc:	28 0f       	add	r18, r24
     fde:	39 1f       	adc	r19, r25
     fe0:	80 91 c8 00 	lds	r24, 0x00C8
     fe4:	90 91 c9 00 	lds	r25, 0x00C9
     fe8:	82 17       	cp	r24, r18
     fea:	93 07       	cpc	r25, r19
     fec:	c0 f4       	brcc	.+48     	; 0x101e <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     fee:	20 91 ca 00 	lds	r18, 0x00CA
     ff2:	30 91 cb 00 	lds	r19, 0x00CB
     ff6:	80 91 c8 00 	lds	r24, 0x00C8
     ffa:	90 91 c9 00 	lds	r25, 0x00C9
     ffe:	82 0f       	add	r24, r18
    1000:	93 1f       	adc	r25, r19
    1002:	9a 83       	std	Y+2, r25	; 0x02
    1004:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1006:	20 91 c8 00 	lds	r18, 0x00C8
    100a:	30 91 c9 00 	lds	r19, 0x00C9
    100e:	8b 81       	ldd	r24, Y+3	; 0x03
    1010:	9c 81       	ldd	r25, Y+4	; 0x04
    1012:	82 0f       	add	r24, r18
    1014:	93 1f       	adc	r25, r19
    1016:	90 93 c9 00 	sts	0x00C9, r25
    101a:	80 93 c8 00 	sts	0x00C8, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    101e:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1022:	89 81       	ldd	r24, Y+1	; 0x01
    1024:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1026:	0f 90       	pop	r0
    1028:	0f 90       	pop	r0
    102a:	0f 90       	pop	r0
    102c:	0f 90       	pop	r0
    102e:	cf 91       	pop	r28
    1030:	df 91       	pop	r29
    1032:	08 95       	ret

00001034 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1034:	df 93       	push	r29
    1036:	cf 93       	push	r28
    1038:	00 d0       	rcall	.+0      	; 0x103a <vPortFree+0x6>
    103a:	cd b7       	in	r28, 0x3d	; 61
    103c:	de b7       	in	r29, 0x3e	; 62
    103e:	9a 83       	std	Y+2, r25	; 0x02
    1040:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1042:	0f 90       	pop	r0
    1044:	0f 90       	pop	r0
    1046:	cf 91       	pop	r28
    1048:	df 91       	pop	r29
    104a:	08 95       	ret

0000104c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    104c:	df 93       	push	r29
    104e:	cf 93       	push	r28
    1050:	cd b7       	in	r28, 0x3d	; 61
    1052:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1054:	10 92 c9 00 	sts	0x00C9, r1
    1058:	10 92 c8 00 	sts	0x00C8, r1
}
    105c:	cf 91       	pop	r28
    105e:	df 91       	pop	r29
    1060:	08 95       	ret

00001062 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1062:	df 93       	push	r29
    1064:	cf 93       	push	r28
    1066:	cd b7       	in	r28, 0x3d	; 61
    1068:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    106a:	20 91 c8 00 	lds	r18, 0x00C8
    106e:	30 91 c9 00 	lds	r19, 0x00C9
    1072:	8b ed       	ldi	r24, 0xDB	; 219
    1074:	95 e0       	ldi	r25, 0x05	; 5
    1076:	82 1b       	sub	r24, r18
    1078:	93 0b       	sbc	r25, r19
}
    107a:	cf 91       	pop	r28
    107c:	df 91       	pop	r29
    107e:	08 95       	ret

00001080 <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    1080:	df 93       	push	r29
    1082:	cf 93       	push	r28
    1084:	cd b7       	in	r28, 0x3d	; 61
    1086:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1088:	aa e3       	ldi	r26, 0x3A	; 58
    108a:	b0 e0       	ldi	r27, 0x00	; 0
    108c:	ea e3       	ldi	r30, 0x3A	; 58
    108e:	f0 e0       	ldi	r31, 0x00	; 0
    1090:	80 81       	ld	r24, Z
    1092:	8e 60       	ori	r24, 0x0E	; 14
    1094:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    1096:	aa e3       	ldi	r26, 0x3A	; 58
    1098:	b0 e0       	ldi	r27, 0x00	; 0
    109a:	ea e3       	ldi	r30, 0x3A	; 58
    109c:	f0 e0       	ldi	r31, 0x00	; 0
    109e:	80 81       	ld	r24, Z
    10a0:	80 6f       	ori	r24, 0xF0	; 240
    10a2:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    10a4:	82 e0       	ldi	r24, 0x02	; 2
    10a6:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    10aa:	88 e2       	ldi	r24, 0x28	; 40
    10ac:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    10b0:	8c e0       	ldi	r24, 0x0C	; 12
    10b2:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    10b6:	81 e0       	ldi	r24, 0x01	; 1
    10b8:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>

}
    10bc:	cf 91       	pop	r28
    10be:	df 91       	pop	r29
    10c0:	08 95       	ret

000010c2 <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    10c2:	df 93       	push	r29
    10c4:	cf 93       	push	r28
    10c6:	0f 92       	push	r0
    10c8:	cd b7       	in	r28, 0x3d	; 61
    10ca:	de b7       	in	r29, 0x3e	; 62
    10cc:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    10ce:	ab e3       	ldi	r26, 0x3B	; 59
    10d0:	b0 e0       	ldi	r27, 0x00	; 0
    10d2:	eb e3       	ldi	r30, 0x3B	; 59
    10d4:	f0 e0       	ldi	r31, 0x00	; 0
    10d6:	80 81       	ld	r24, Z
    10d8:	8d 7f       	andi	r24, 0xFD	; 253
    10da:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    10dc:	ab e3       	ldi	r26, 0x3B	; 59
    10de:	b0 e0       	ldi	r27, 0x00	; 0
    10e0:	eb e3       	ldi	r30, 0x3B	; 59
    10e2:	f0 e0       	ldi	r31, 0x00	; 0
    10e4:	80 81       	ld	r24, Z
    10e6:	8b 7f       	andi	r24, 0xFB	; 251
    10e8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    10ea:	81 e0       	ldi	r24, 0x01	; 1
    10ec:	90 e0       	ldi	r25, 0x00	; 0
    10ee:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    10f2:	ab e3       	ldi	r26, 0x3B	; 59
    10f4:	b0 e0       	ldi	r27, 0x00	; 0
    10f6:	eb e3       	ldi	r30, 0x3B	; 59
    10f8:	f0 e0       	ldi	r31, 0x00	; 0
    10fa:	80 81       	ld	r24, Z
    10fc:	88 60       	ori	r24, 0x08	; 8
    10fe:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1100:	81 e0       	ldi	r24, 0x01	; 1
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    1108:	ab e3       	ldi	r26, 0x3B	; 59
    110a:	b0 e0       	ldi	r27, 0x00	; 0
    110c:	eb e3       	ldi	r30, 0x3B	; 59
    110e:	f0 e0       	ldi	r31, 0x00	; 0
    1110:	80 81       	ld	r24, Z
    1112:	98 2f       	mov	r25, r24
    1114:	9f 70       	andi	r25, 0x0F	; 15
    1116:	89 81       	ldd	r24, Y+1	; 0x01
    1118:	80 7f       	andi	r24, 0xF0	; 240
    111a:	89 2b       	or	r24, r25
    111c:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1126:	ab e3       	ldi	r26, 0x3B	; 59
    1128:	b0 e0       	ldi	r27, 0x00	; 0
    112a:	eb e3       	ldi	r30, 0x3B	; 59
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
    1130:	87 7f       	andi	r24, 0xF7	; 247
    1132:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1134:	81 e0       	ldi	r24, 0x01	; 1
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    113c:	ab e3       	ldi	r26, 0x3B	; 59
    113e:	b0 e0       	ldi	r27, 0x00	; 0
    1140:	eb e3       	ldi	r30, 0x3B	; 59
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	80 81       	ld	r24, Z
    1146:	88 60       	ori	r24, 0x08	; 8
    1148:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    114a:	81 e0       	ldi	r24, 0x01	; 1
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    1152:	ab e3       	ldi	r26, 0x3B	; 59
    1154:	b0 e0       	ldi	r27, 0x00	; 0
    1156:	eb e3       	ldi	r30, 0x3B	; 59
    1158:	f0 e0       	ldi	r31, 0x00	; 0
    115a:	80 81       	ld	r24, Z
    115c:	28 2f       	mov	r18, r24
    115e:	2f 70       	andi	r18, 0x0F	; 15
    1160:	89 81       	ldd	r24, Y+1	; 0x01
    1162:	88 2f       	mov	r24, r24
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	82 95       	swap	r24
    1168:	92 95       	swap	r25
    116a:	90 7f       	andi	r25, 0xF0	; 240
    116c:	98 27       	eor	r25, r24
    116e:	80 7f       	andi	r24, 0xF0	; 240
    1170:	98 27       	eor	r25, r24
    1172:	82 2b       	or	r24, r18
    1174:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1176:	81 e0       	ldi	r24, 0x01	; 1
    1178:	90 e0       	ldi	r25, 0x00	; 0
    117a:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    117e:	ab e3       	ldi	r26, 0x3B	; 59
    1180:	b0 e0       	ldi	r27, 0x00	; 0
    1182:	eb e3       	ldi	r30, 0x3B	; 59
    1184:	f0 e0       	ldi	r31, 0x00	; 0
    1186:	80 81       	ld	r24, Z
    1188:	87 7f       	andi	r24, 0xF7	; 247
    118a:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1194:	0f 90       	pop	r0
    1196:	cf 91       	pop	r28
    1198:	df 91       	pop	r29
    119a:	08 95       	ret

0000119c <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    119c:	df 93       	push	r29
    119e:	cf 93       	push	r28
    11a0:	0f 92       	push	r0
    11a2:	cd b7       	in	r28, 0x3d	; 61
    11a4:	de b7       	in	r29, 0x3e	; 62
    11a6:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    11a8:	ab e3       	ldi	r26, 0x3B	; 59
    11aa:	b0 e0       	ldi	r27, 0x00	; 0
    11ac:	eb e3       	ldi	r30, 0x3B	; 59
    11ae:	f0 e0       	ldi	r31, 0x00	; 0
    11b0:	80 81       	ld	r24, Z
    11b2:	82 60       	ori	r24, 0x02	; 2
    11b4:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    11b6:	ab e3       	ldi	r26, 0x3B	; 59
    11b8:	b0 e0       	ldi	r27, 0x00	; 0
    11ba:	eb e3       	ldi	r30, 0x3B	; 59
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	8b 7f       	andi	r24, 0xFB	; 251
    11c2:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    11c4:	81 e0       	ldi	r24, 0x01	; 1
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    11cc:	ab e3       	ldi	r26, 0x3B	; 59
    11ce:	b0 e0       	ldi	r27, 0x00	; 0
    11d0:	eb e3       	ldi	r30, 0x3B	; 59
    11d2:	f0 e0       	ldi	r31, 0x00	; 0
    11d4:	80 81       	ld	r24, Z
    11d6:	88 60       	ori	r24, 0x08	; 8
    11d8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    11e2:	ab e3       	ldi	r26, 0x3B	; 59
    11e4:	b0 e0       	ldi	r27, 0x00	; 0
    11e6:	eb e3       	ldi	r30, 0x3B	; 59
    11e8:	f0 e0       	ldi	r31, 0x00	; 0
    11ea:	80 81       	ld	r24, Z
    11ec:	98 2f       	mov	r25, r24
    11ee:	9f 70       	andi	r25, 0x0F	; 15
    11f0:	89 81       	ldd	r24, Y+1	; 0x01
    11f2:	80 7f       	andi	r24, 0xF0	; 240
    11f4:	89 2b       	or	r24, r25
    11f6:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    11f8:	81 e0       	ldi	r24, 0x01	; 1
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1200:	ab e3       	ldi	r26, 0x3B	; 59
    1202:	b0 e0       	ldi	r27, 0x00	; 0
    1204:	eb e3       	ldi	r30, 0x3B	; 59
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	80 81       	ld	r24, Z
    120a:	87 7f       	andi	r24, 0xF7	; 247
    120c:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1216:	ab e3       	ldi	r26, 0x3B	; 59
    1218:	b0 e0       	ldi	r27, 0x00	; 0
    121a:	eb e3       	ldi	r30, 0x3B	; 59
    121c:	f0 e0       	ldi	r31, 0x00	; 0
    121e:	80 81       	ld	r24, Z
    1220:	88 60       	ori	r24, 0x08	; 8
    1222:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1224:	81 e0       	ldi	r24, 0x01	; 1
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    122c:	ab e3       	ldi	r26, 0x3B	; 59
    122e:	b0 e0       	ldi	r27, 0x00	; 0
    1230:	eb e3       	ldi	r30, 0x3B	; 59
    1232:	f0 e0       	ldi	r31, 0x00	; 0
    1234:	80 81       	ld	r24, Z
    1236:	28 2f       	mov	r18, r24
    1238:	2f 70       	andi	r18, 0x0F	; 15
    123a:	89 81       	ldd	r24, Y+1	; 0x01
    123c:	88 2f       	mov	r24, r24
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	82 95       	swap	r24
    1242:	92 95       	swap	r25
    1244:	90 7f       	andi	r25, 0xF0	; 240
    1246:	98 27       	eor	r25, r24
    1248:	80 7f       	andi	r24, 0xF0	; 240
    124a:	98 27       	eor	r25, r24
    124c:	82 2b       	or	r24, r18
    124e:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1258:	ab e3       	ldi	r26, 0x3B	; 59
    125a:	b0 e0       	ldi	r27, 0x00	; 0
    125c:	eb e3       	ldi	r30, 0x3B	; 59
    125e:	f0 e0       	ldi	r31, 0x00	; 0
    1260:	80 81       	ld	r24, Z
    1262:	87 7f       	andi	r24, 0xF7	; 247
    1264:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	90 e0       	ldi	r25, 0x00	; 0
    126a:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    126e:	0f 90       	pop	r0
    1270:	cf 91       	pop	r28
    1272:	df 91       	pop	r29
    1274:	08 95       	ret

00001276 <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    1276:	df 93       	push	r29
    1278:	cf 93       	push	r28
    127a:	00 d0       	rcall	.+0      	; 0x127c <LCD_displayString+0x6>
    127c:	0f 92       	push	r0
    127e:	cd b7       	in	r28, 0x3d	; 61
    1280:	de b7       	in	r29, 0x3e	; 62
    1282:	9b 83       	std	Y+3, r25	; 0x03
    1284:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1286:	19 82       	std	Y+1, r1	; 0x01
    1288:	0e c0       	rjmp	.+28     	; 0x12a6 <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    128a:	89 81       	ldd	r24, Y+1	; 0x01
    128c:	28 2f       	mov	r18, r24
    128e:	30 e0       	ldi	r19, 0x00	; 0
    1290:	8a 81       	ldd	r24, Y+2	; 0x02
    1292:	9b 81       	ldd	r25, Y+3	; 0x03
    1294:	fc 01       	movw	r30, r24
    1296:	e2 0f       	add	r30, r18
    1298:	f3 1f       	adc	r31, r19
    129a:	80 81       	ld	r24, Z
    129c:	0e 94 ce 08 	call	0x119c	; 0x119c <LCD_displayCharacter>
		i++;
    12a0:	89 81       	ldd	r24, Y+1	; 0x01
    12a2:	8f 5f       	subi	r24, 0xFF	; 255
    12a4:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    12a6:	89 81       	ldd	r24, Y+1	; 0x01
    12a8:	28 2f       	mov	r18, r24
    12aa:	30 e0       	ldi	r19, 0x00	; 0
    12ac:	8a 81       	ldd	r24, Y+2	; 0x02
    12ae:	9b 81       	ldd	r25, Y+3	; 0x03
    12b0:	fc 01       	movw	r30, r24
    12b2:	e2 0f       	add	r30, r18
    12b4:	f3 1f       	adc	r31, r19
    12b6:	80 81       	ld	r24, Z
    12b8:	88 23       	and	r24, r24
    12ba:	39 f7       	brne	.-50     	; 0x128a <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    12bc:	0f 90       	pop	r0
    12be:	0f 90       	pop	r0
    12c0:	0f 90       	pop	r0
    12c2:	cf 91       	pop	r28
    12c4:	df 91       	pop	r29
    12c6:	08 95       	ret

000012c8 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    12c8:	df 93       	push	r29
    12ca:	cf 93       	push	r28
    12cc:	00 d0       	rcall	.+0      	; 0x12ce <LCD_goToRowColumn+0x6>
    12ce:	00 d0       	rcall	.+0      	; 0x12d0 <LCD_goToRowColumn+0x8>
    12d0:	0f 92       	push	r0
    12d2:	cd b7       	in	r28, 0x3d	; 61
    12d4:	de b7       	in	r29, 0x3e	; 62
    12d6:	8a 83       	std	Y+2, r24	; 0x02
    12d8:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    12da:	8a 81       	ldd	r24, Y+2	; 0x02
    12dc:	28 2f       	mov	r18, r24
    12de:	30 e0       	ldi	r19, 0x00	; 0
    12e0:	3d 83       	std	Y+5, r19	; 0x05
    12e2:	2c 83       	std	Y+4, r18	; 0x04
    12e4:	8c 81       	ldd	r24, Y+4	; 0x04
    12e6:	9d 81       	ldd	r25, Y+5	; 0x05
    12e8:	81 30       	cpi	r24, 0x01	; 1
    12ea:	91 05       	cpc	r25, r1
    12ec:	c1 f0       	breq	.+48     	; 0x131e <LCD_goToRowColumn+0x56>
    12ee:	2c 81       	ldd	r18, Y+4	; 0x04
    12f0:	3d 81       	ldd	r19, Y+5	; 0x05
    12f2:	22 30       	cpi	r18, 0x02	; 2
    12f4:	31 05       	cpc	r19, r1
    12f6:	2c f4       	brge	.+10     	; 0x1302 <LCD_goToRowColumn+0x3a>
    12f8:	8c 81       	ldd	r24, Y+4	; 0x04
    12fa:	9d 81       	ldd	r25, Y+5	; 0x05
    12fc:	00 97       	sbiw	r24, 0x00	; 0
    12fe:	61 f0       	breq	.+24     	; 0x1318 <LCD_goToRowColumn+0x50>
    1300:	19 c0       	rjmp	.+50     	; 0x1334 <LCD_goToRowColumn+0x6c>
    1302:	2c 81       	ldd	r18, Y+4	; 0x04
    1304:	3d 81       	ldd	r19, Y+5	; 0x05
    1306:	22 30       	cpi	r18, 0x02	; 2
    1308:	31 05       	cpc	r19, r1
    130a:	69 f0       	breq	.+26     	; 0x1326 <LCD_goToRowColumn+0x5e>
    130c:	8c 81       	ldd	r24, Y+4	; 0x04
    130e:	9d 81       	ldd	r25, Y+5	; 0x05
    1310:	83 30       	cpi	r24, 0x03	; 3
    1312:	91 05       	cpc	r25, r1
    1314:	61 f0       	breq	.+24     	; 0x132e <LCD_goToRowColumn+0x66>
    1316:	0e c0       	rjmp	.+28     	; 0x1334 <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    1318:	8b 81       	ldd	r24, Y+3	; 0x03
    131a:	89 83       	std	Y+1, r24	; 0x01
    131c:	0b c0       	rjmp	.+22     	; 0x1334 <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    131e:	8b 81       	ldd	r24, Y+3	; 0x03
    1320:	80 5c       	subi	r24, 0xC0	; 192
    1322:	89 83       	std	Y+1, r24	; 0x01
    1324:	07 c0       	rjmp	.+14     	; 0x1334 <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    1326:	8b 81       	ldd	r24, Y+3	; 0x03
    1328:	80 5f       	subi	r24, 0xF0	; 240
    132a:	89 83       	std	Y+1, r24	; 0x01
    132c:	03 c0       	rjmp	.+6      	; 0x1334 <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    132e:	8b 81       	ldd	r24, Y+3	; 0x03
    1330:	80 5b       	subi	r24, 0xB0	; 176
    1332:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    1334:	89 81       	ldd	r24, Y+1	; 0x01
    1336:	80 68       	ori	r24, 0x80	; 128
    1338:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>
}
    133c:	0f 90       	pop	r0
    133e:	0f 90       	pop	r0
    1340:	0f 90       	pop	r0
    1342:	0f 90       	pop	r0
    1344:	0f 90       	pop	r0
    1346:	cf 91       	pop	r28
    1348:	df 91       	pop	r29
    134a:	08 95       	ret

0000134c <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    134c:	df 93       	push	r29
    134e:	cf 93       	push	r28
    1350:	00 d0       	rcall	.+0      	; 0x1352 <LCD_displayStringRowColumn+0x6>
    1352:	00 d0       	rcall	.+0      	; 0x1354 <LCD_displayStringRowColumn+0x8>
    1354:	cd b7       	in	r28, 0x3d	; 61
    1356:	de b7       	in	r29, 0x3e	; 62
    1358:	89 83       	std	Y+1, r24	; 0x01
    135a:	6a 83       	std	Y+2, r22	; 0x02
    135c:	5c 83       	std	Y+4, r21	; 0x04
    135e:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    1360:	89 81       	ldd	r24, Y+1	; 0x01
    1362:	6a 81       	ldd	r22, Y+2	; 0x02
    1364:	0e 94 64 09 	call	0x12c8	; 0x12c8 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1368:	8b 81       	ldd	r24, Y+3	; 0x03
    136a:	9c 81       	ldd	r25, Y+4	; 0x04
    136c:	0e 94 3b 09 	call	0x1276	; 0x1276 <LCD_displayString>
}
    1370:	0f 90       	pop	r0
    1372:	0f 90       	pop	r0
    1374:	0f 90       	pop	r0
    1376:	0f 90       	pop	r0
    1378:	cf 91       	pop	r28
    137a:	df 91       	pop	r29
    137c:	08 95       	ret

0000137e <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    137e:	df 93       	push	r29
    1380:	cf 93       	push	r28
    1382:	cd b7       	in	r28, 0x3d	; 61
    1384:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    1386:	81 e0       	ldi	r24, 0x01	; 1
    1388:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD_sendCommand>
}
    138c:	cf 91       	pop	r28
    138e:	df 91       	pop	r29
    1390:	08 95       	ret

00001392 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1392:	df 93       	push	r29
    1394:	cf 93       	push	r28
    1396:	00 d0       	rcall	.+0      	; 0x1398 <vListInitialise+0x6>
    1398:	cd b7       	in	r28, 0x3d	; 61
    139a:	de b7       	in	r29, 0x3e	; 62
    139c:	9a 83       	std	Y+2, r25	; 0x02
    139e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13a0:	89 81       	ldd	r24, Y+1	; 0x01
    13a2:	9a 81       	ldd	r25, Y+2	; 0x02
    13a4:	03 96       	adiw	r24, 0x03	; 3
    13a6:	e9 81       	ldd	r30, Y+1	; 0x01
    13a8:	fa 81       	ldd	r31, Y+2	; 0x02
    13aa:	92 83       	std	Z+2, r25	; 0x02
    13ac:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    13ae:	e9 81       	ldd	r30, Y+1	; 0x01
    13b0:	fa 81       	ldd	r31, Y+2	; 0x02
    13b2:	8f ef       	ldi	r24, 0xFF	; 255
    13b4:	9f ef       	ldi	r25, 0xFF	; 255
    13b6:	94 83       	std	Z+4, r25	; 0x04
    13b8:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13ba:	89 81       	ldd	r24, Y+1	; 0x01
    13bc:	9a 81       	ldd	r25, Y+2	; 0x02
    13be:	03 96       	adiw	r24, 0x03	; 3
    13c0:	e9 81       	ldd	r30, Y+1	; 0x01
    13c2:	fa 81       	ldd	r31, Y+2	; 0x02
    13c4:	96 83       	std	Z+6, r25	; 0x06
    13c6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
    13ca:	9a 81       	ldd	r25, Y+2	; 0x02
    13cc:	03 96       	adiw	r24, 0x03	; 3
    13ce:	e9 81       	ldd	r30, Y+1	; 0x01
    13d0:	fa 81       	ldd	r31, Y+2	; 0x02
    13d2:	90 87       	std	Z+8, r25	; 0x08
    13d4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    13d6:	e9 81       	ldd	r30, Y+1	; 0x01
    13d8:	fa 81       	ldd	r31, Y+2	; 0x02
    13da:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    13dc:	0f 90       	pop	r0
    13de:	0f 90       	pop	r0
    13e0:	cf 91       	pop	r28
    13e2:	df 91       	pop	r29
    13e4:	08 95       	ret

000013e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    13e6:	df 93       	push	r29
    13e8:	cf 93       	push	r28
    13ea:	00 d0       	rcall	.+0      	; 0x13ec <vListInitialiseItem+0x6>
    13ec:	cd b7       	in	r28, 0x3d	; 61
    13ee:	de b7       	in	r29, 0x3e	; 62
    13f0:	9a 83       	std	Y+2, r25	; 0x02
    13f2:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    13f4:	e9 81       	ldd	r30, Y+1	; 0x01
    13f6:	fa 81       	ldd	r31, Y+2	; 0x02
    13f8:	11 86       	std	Z+9, r1	; 0x09
    13fa:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    13fc:	0f 90       	pop	r0
    13fe:	0f 90       	pop	r0
    1400:	cf 91       	pop	r28
    1402:	df 91       	pop	r29
    1404:	08 95       	ret

00001406 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1406:	df 93       	push	r29
    1408:	cf 93       	push	r28
    140a:	00 d0       	rcall	.+0      	; 0x140c <vListInsertEnd+0x6>
    140c:	00 d0       	rcall	.+0      	; 0x140e <vListInsertEnd+0x8>
    140e:	00 d0       	rcall	.+0      	; 0x1410 <vListInsertEnd+0xa>
    1410:	cd b7       	in	r28, 0x3d	; 61
    1412:	de b7       	in	r29, 0x3e	; 62
    1414:	9c 83       	std	Y+4, r25	; 0x04
    1416:	8b 83       	std	Y+3, r24	; 0x03
    1418:	7e 83       	std	Y+6, r23	; 0x06
    141a:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    141c:	eb 81       	ldd	r30, Y+3	; 0x03
    141e:	fc 81       	ldd	r31, Y+4	; 0x04
    1420:	81 81       	ldd	r24, Z+1	; 0x01
    1422:	92 81       	ldd	r25, Z+2	; 0x02
    1424:	9a 83       	std	Y+2, r25	; 0x02
    1426:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1428:	ed 81       	ldd	r30, Y+5	; 0x05
    142a:	fe 81       	ldd	r31, Y+6	; 0x06
    142c:	89 81       	ldd	r24, Y+1	; 0x01
    142e:	9a 81       	ldd	r25, Y+2	; 0x02
    1430:	93 83       	std	Z+3, r25	; 0x03
    1432:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1434:	e9 81       	ldd	r30, Y+1	; 0x01
    1436:	fa 81       	ldd	r31, Y+2	; 0x02
    1438:	84 81       	ldd	r24, Z+4	; 0x04
    143a:	95 81       	ldd	r25, Z+5	; 0x05
    143c:	ed 81       	ldd	r30, Y+5	; 0x05
    143e:	fe 81       	ldd	r31, Y+6	; 0x06
    1440:	95 83       	std	Z+5, r25	; 0x05
    1442:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1444:	e9 81       	ldd	r30, Y+1	; 0x01
    1446:	fa 81       	ldd	r31, Y+2	; 0x02
    1448:	04 80       	ldd	r0, Z+4	; 0x04
    144a:	f5 81       	ldd	r31, Z+5	; 0x05
    144c:	e0 2d       	mov	r30, r0
    144e:	8d 81       	ldd	r24, Y+5	; 0x05
    1450:	9e 81       	ldd	r25, Y+6	; 0x06
    1452:	93 83       	std	Z+3, r25	; 0x03
    1454:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1456:	e9 81       	ldd	r30, Y+1	; 0x01
    1458:	fa 81       	ldd	r31, Y+2	; 0x02
    145a:	8d 81       	ldd	r24, Y+5	; 0x05
    145c:	9e 81       	ldd	r25, Y+6	; 0x06
    145e:	95 83       	std	Z+5, r25	; 0x05
    1460:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1462:	ed 81       	ldd	r30, Y+5	; 0x05
    1464:	fe 81       	ldd	r31, Y+6	; 0x06
    1466:	8b 81       	ldd	r24, Y+3	; 0x03
    1468:	9c 81       	ldd	r25, Y+4	; 0x04
    146a:	91 87       	std	Z+9, r25	; 0x09
    146c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    146e:	eb 81       	ldd	r30, Y+3	; 0x03
    1470:	fc 81       	ldd	r31, Y+4	; 0x04
    1472:	80 81       	ld	r24, Z
    1474:	8f 5f       	subi	r24, 0xFF	; 255
    1476:	eb 81       	ldd	r30, Y+3	; 0x03
    1478:	fc 81       	ldd	r31, Y+4	; 0x04
    147a:	80 83       	st	Z, r24
}
    147c:	26 96       	adiw	r28, 0x06	; 6
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	f8 94       	cli
    1482:	de bf       	out	0x3e, r29	; 62
    1484:	0f be       	out	0x3f, r0	; 63
    1486:	cd bf       	out	0x3d, r28	; 61
    1488:	cf 91       	pop	r28
    148a:	df 91       	pop	r29
    148c:	08 95       	ret

0000148e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    148e:	df 93       	push	r29
    1490:	cf 93       	push	r28
    1492:	cd b7       	in	r28, 0x3d	; 61
    1494:	de b7       	in	r29, 0x3e	; 62
    1496:	28 97       	sbiw	r28, 0x08	; 8
    1498:	0f b6       	in	r0, 0x3f	; 63
    149a:	f8 94       	cli
    149c:	de bf       	out	0x3e, r29	; 62
    149e:	0f be       	out	0x3f, r0	; 63
    14a0:	cd bf       	out	0x3d, r28	; 61
    14a2:	9e 83       	std	Y+6, r25	; 0x06
    14a4:	8d 83       	std	Y+5, r24	; 0x05
    14a6:	78 87       	std	Y+8, r23	; 0x08
    14a8:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    14aa:	ef 81       	ldd	r30, Y+7	; 0x07
    14ac:	f8 85       	ldd	r31, Y+8	; 0x08
    14ae:	80 81       	ld	r24, Z
    14b0:	91 81       	ldd	r25, Z+1	; 0x01
    14b2:	9a 83       	std	Y+2, r25	; 0x02
    14b4:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    14b6:	89 81       	ldd	r24, Y+1	; 0x01
    14b8:	9a 81       	ldd	r25, Y+2	; 0x02
    14ba:	2f ef       	ldi	r18, 0xFF	; 255
    14bc:	8f 3f       	cpi	r24, 0xFF	; 255
    14be:	92 07       	cpc	r25, r18
    14c0:	39 f4       	brne	.+14     	; 0x14d0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    14c2:	ed 81       	ldd	r30, Y+5	; 0x05
    14c4:	fe 81       	ldd	r31, Y+6	; 0x06
    14c6:	87 81       	ldd	r24, Z+7	; 0x07
    14c8:	90 85       	ldd	r25, Z+8	; 0x08
    14ca:	9c 83       	std	Y+4, r25	; 0x04
    14cc:	8b 83       	std	Y+3, r24	; 0x03
    14ce:	18 c0       	rjmp	.+48     	; 0x1500 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    14d0:	8d 81       	ldd	r24, Y+5	; 0x05
    14d2:	9e 81       	ldd	r25, Y+6	; 0x06
    14d4:	03 96       	adiw	r24, 0x03	; 3
    14d6:	9c 83       	std	Y+4, r25	; 0x04
    14d8:	8b 83       	std	Y+3, r24	; 0x03
    14da:	06 c0       	rjmp	.+12     	; 0x14e8 <vListInsert+0x5a>
    14dc:	eb 81       	ldd	r30, Y+3	; 0x03
    14de:	fc 81       	ldd	r31, Y+4	; 0x04
    14e0:	82 81       	ldd	r24, Z+2	; 0x02
    14e2:	93 81       	ldd	r25, Z+3	; 0x03
    14e4:	9c 83       	std	Y+4, r25	; 0x04
    14e6:	8b 83       	std	Y+3, r24	; 0x03
    14e8:	eb 81       	ldd	r30, Y+3	; 0x03
    14ea:	fc 81       	ldd	r31, Y+4	; 0x04
    14ec:	02 80       	ldd	r0, Z+2	; 0x02
    14ee:	f3 81       	ldd	r31, Z+3	; 0x03
    14f0:	e0 2d       	mov	r30, r0
    14f2:	20 81       	ld	r18, Z
    14f4:	31 81       	ldd	r19, Z+1	; 0x01
    14f6:	89 81       	ldd	r24, Y+1	; 0x01
    14f8:	9a 81       	ldd	r25, Y+2	; 0x02
    14fa:	82 17       	cp	r24, r18
    14fc:	93 07       	cpc	r25, r19
    14fe:	70 f7       	brcc	.-36     	; 0x14dc <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1500:	eb 81       	ldd	r30, Y+3	; 0x03
    1502:	fc 81       	ldd	r31, Y+4	; 0x04
    1504:	82 81       	ldd	r24, Z+2	; 0x02
    1506:	93 81       	ldd	r25, Z+3	; 0x03
    1508:	ef 81       	ldd	r30, Y+7	; 0x07
    150a:	f8 85       	ldd	r31, Y+8	; 0x08
    150c:	93 83       	std	Z+3, r25	; 0x03
    150e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1510:	ef 81       	ldd	r30, Y+7	; 0x07
    1512:	f8 85       	ldd	r31, Y+8	; 0x08
    1514:	02 80       	ldd	r0, Z+2	; 0x02
    1516:	f3 81       	ldd	r31, Z+3	; 0x03
    1518:	e0 2d       	mov	r30, r0
    151a:	8f 81       	ldd	r24, Y+7	; 0x07
    151c:	98 85       	ldd	r25, Y+8	; 0x08
    151e:	95 83       	std	Z+5, r25	; 0x05
    1520:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1522:	ef 81       	ldd	r30, Y+7	; 0x07
    1524:	f8 85       	ldd	r31, Y+8	; 0x08
    1526:	8b 81       	ldd	r24, Y+3	; 0x03
    1528:	9c 81       	ldd	r25, Y+4	; 0x04
    152a:	95 83       	std	Z+5, r25	; 0x05
    152c:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    152e:	eb 81       	ldd	r30, Y+3	; 0x03
    1530:	fc 81       	ldd	r31, Y+4	; 0x04
    1532:	8f 81       	ldd	r24, Y+7	; 0x07
    1534:	98 85       	ldd	r25, Y+8	; 0x08
    1536:	93 83       	std	Z+3, r25	; 0x03
    1538:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    153a:	ef 81       	ldd	r30, Y+7	; 0x07
    153c:	f8 85       	ldd	r31, Y+8	; 0x08
    153e:	8d 81       	ldd	r24, Y+5	; 0x05
    1540:	9e 81       	ldd	r25, Y+6	; 0x06
    1542:	91 87       	std	Z+9, r25	; 0x09
    1544:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1546:	ed 81       	ldd	r30, Y+5	; 0x05
    1548:	fe 81       	ldd	r31, Y+6	; 0x06
    154a:	80 81       	ld	r24, Z
    154c:	8f 5f       	subi	r24, 0xFF	; 255
    154e:	ed 81       	ldd	r30, Y+5	; 0x05
    1550:	fe 81       	ldd	r31, Y+6	; 0x06
    1552:	80 83       	st	Z, r24
}
    1554:	28 96       	adiw	r28, 0x08	; 8
    1556:	0f b6       	in	r0, 0x3f	; 63
    1558:	f8 94       	cli
    155a:	de bf       	out	0x3e, r29	; 62
    155c:	0f be       	out	0x3f, r0	; 63
    155e:	cd bf       	out	0x3d, r28	; 61
    1560:	cf 91       	pop	r28
    1562:	df 91       	pop	r29
    1564:	08 95       	ret

00001566 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1566:	df 93       	push	r29
    1568:	cf 93       	push	r28
    156a:	00 d0       	rcall	.+0      	; 0x156c <uxListRemove+0x6>
    156c:	00 d0       	rcall	.+0      	; 0x156e <uxListRemove+0x8>
    156e:	cd b7       	in	r28, 0x3d	; 61
    1570:	de b7       	in	r29, 0x3e	; 62
    1572:	9c 83       	std	Y+4, r25	; 0x04
    1574:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1576:	eb 81       	ldd	r30, Y+3	; 0x03
    1578:	fc 81       	ldd	r31, Y+4	; 0x04
    157a:	80 85       	ldd	r24, Z+8	; 0x08
    157c:	91 85       	ldd	r25, Z+9	; 0x09
    157e:	9a 83       	std	Y+2, r25	; 0x02
    1580:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1582:	eb 81       	ldd	r30, Y+3	; 0x03
    1584:	fc 81       	ldd	r31, Y+4	; 0x04
    1586:	a2 81       	ldd	r26, Z+2	; 0x02
    1588:	b3 81       	ldd	r27, Z+3	; 0x03
    158a:	eb 81       	ldd	r30, Y+3	; 0x03
    158c:	fc 81       	ldd	r31, Y+4	; 0x04
    158e:	84 81       	ldd	r24, Z+4	; 0x04
    1590:	95 81       	ldd	r25, Z+5	; 0x05
    1592:	15 96       	adiw	r26, 0x05	; 5
    1594:	9c 93       	st	X, r25
    1596:	8e 93       	st	-X, r24
    1598:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    159a:	eb 81       	ldd	r30, Y+3	; 0x03
    159c:	fc 81       	ldd	r31, Y+4	; 0x04
    159e:	a4 81       	ldd	r26, Z+4	; 0x04
    15a0:	b5 81       	ldd	r27, Z+5	; 0x05
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	82 81       	ldd	r24, Z+2	; 0x02
    15a8:	93 81       	ldd	r25, Z+3	; 0x03
    15aa:	13 96       	adiw	r26, 0x03	; 3
    15ac:	9c 93       	st	X, r25
    15ae:	8e 93       	st	-X, r24
    15b0:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    15b2:	e9 81       	ldd	r30, Y+1	; 0x01
    15b4:	fa 81       	ldd	r31, Y+2	; 0x02
    15b6:	21 81       	ldd	r18, Z+1	; 0x01
    15b8:	32 81       	ldd	r19, Z+2	; 0x02
    15ba:	8b 81       	ldd	r24, Y+3	; 0x03
    15bc:	9c 81       	ldd	r25, Y+4	; 0x04
    15be:	28 17       	cp	r18, r24
    15c0:	39 07       	cpc	r19, r25
    15c2:	41 f4       	brne	.+16     	; 0x15d4 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    15c4:	eb 81       	ldd	r30, Y+3	; 0x03
    15c6:	fc 81       	ldd	r31, Y+4	; 0x04
    15c8:	84 81       	ldd	r24, Z+4	; 0x04
    15ca:	95 81       	ldd	r25, Z+5	; 0x05
    15cc:	e9 81       	ldd	r30, Y+1	; 0x01
    15ce:	fa 81       	ldd	r31, Y+2	; 0x02
    15d0:	92 83       	std	Z+2, r25	; 0x02
    15d2:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    15d4:	eb 81       	ldd	r30, Y+3	; 0x03
    15d6:	fc 81       	ldd	r31, Y+4	; 0x04
    15d8:	11 86       	std	Z+9, r1	; 0x09
    15da:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    15dc:	e9 81       	ldd	r30, Y+1	; 0x01
    15de:	fa 81       	ldd	r31, Y+2	; 0x02
    15e0:	80 81       	ld	r24, Z
    15e2:	81 50       	subi	r24, 0x01	; 1
    15e4:	e9 81       	ldd	r30, Y+1	; 0x01
    15e6:	fa 81       	ldd	r31, Y+2	; 0x02
    15e8:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    15ea:	e9 81       	ldd	r30, Y+1	; 0x01
    15ec:	fa 81       	ldd	r31, Y+2	; 0x02
    15ee:	80 81       	ld	r24, Z
}
    15f0:	0f 90       	pop	r0
    15f2:	0f 90       	pop	r0
    15f4:	0f 90       	pop	r0
    15f6:	0f 90       	pop	r0
    15f8:	cf 91       	pop	r28
    15fa:	df 91       	pop	r29
    15fc:	08 95       	ret

000015fe <main>:

#include "UserTasks.h"


void main(void)
{
    15fe:	ef 92       	push	r14
    1600:	ff 92       	push	r15
    1602:	0f 93       	push	r16
    1604:	df 93       	push	r29
    1606:	cf 93       	push	r28
    1608:	cd b7       	in	r28, 0x3d	; 61
    160a:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(init_Task  , "Init_Task" , configMINIMAL_STACK_SIZE ,
    160c:	83 ec       	ldi	r24, 0xC3	; 195
    160e:	92 e0       	ldi	r25, 0x02	; 2
    1610:	20 eb       	ldi	r18, 0xB0	; 176
    1612:	30 e0       	ldi	r19, 0x00	; 0
    1614:	e2 ec       	ldi	r30, 0xC2	; 194
    1616:	f0 e0       	ldi	r31, 0x00	; 0
    1618:	b9 01       	movw	r22, r18
    161a:	46 e9       	ldi	r20, 0x96	; 150
    161c:	50 e0       	ldi	r21, 0x00	; 0
    161e:	20 e0       	ldi	r18, 0x00	; 0
    1620:	30 e0       	ldi	r19, 0x00	; 0
    1622:	04 e0       	ldi	r16, 0x04	; 4
    1624:	7f 01       	movw	r14, r30
    1626:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , &InitTask_Flag);

	/* Start Scheduler */
	vTaskStartScheduler();
    162a:	0e 94 4f 20 	call	0x409e	; 0x409e <vTaskStartScheduler>
    162e:	ff cf       	rjmp	.-2      	; 0x162e <main+0x30>

00001630 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1630:	df 93       	push	r29
    1632:	cf 93       	push	r28
    1634:	cd b7       	in	r28, 0x3d	; 61
    1636:	de b7       	in	r29, 0x3e	; 62
    1638:	28 97       	sbiw	r28, 0x08	; 8
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	de bf       	out	0x3e, r29	; 62
    1640:	0f be       	out	0x3f, r0	; 63
    1642:	cd bf       	out	0x3d, r28	; 61
    1644:	9c 83       	std	Y+4, r25	; 0x04
    1646:	8b 83       	std	Y+3, r24	; 0x03
    1648:	7e 83       	std	Y+6, r23	; 0x06
    164a:	6d 83       	std	Y+5, r22	; 0x05
    164c:	58 87       	std	Y+8, r21	; 0x08
    164e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1650:	eb 81       	ldd	r30, Y+3	; 0x03
    1652:	fc 81       	ldd	r31, Y+4	; 0x04
    1654:	81 e1       	ldi	r24, 0x11	; 17
    1656:	80 83       	st	Z, r24
	pxTopOfStack--;
    1658:	8b 81       	ldd	r24, Y+3	; 0x03
    165a:	9c 81       	ldd	r25, Y+4	; 0x04
    165c:	01 97       	sbiw	r24, 0x01	; 1
    165e:	9c 83       	std	Y+4, r25	; 0x04
    1660:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1662:	eb 81       	ldd	r30, Y+3	; 0x03
    1664:	fc 81       	ldd	r31, Y+4	; 0x04
    1666:	82 e2       	ldi	r24, 0x22	; 34
    1668:	80 83       	st	Z, r24
	pxTopOfStack--;
    166a:	8b 81       	ldd	r24, Y+3	; 0x03
    166c:	9c 81       	ldd	r25, Y+4	; 0x04
    166e:	01 97       	sbiw	r24, 0x01	; 1
    1670:	9c 83       	std	Y+4, r25	; 0x04
    1672:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1674:	eb 81       	ldd	r30, Y+3	; 0x03
    1676:	fc 81       	ldd	r31, Y+4	; 0x04
    1678:	83 e3       	ldi	r24, 0x33	; 51
    167a:	80 83       	st	Z, r24
	pxTopOfStack--;
    167c:	8b 81       	ldd	r24, Y+3	; 0x03
    167e:	9c 81       	ldd	r25, Y+4	; 0x04
    1680:	01 97       	sbiw	r24, 0x01	; 1
    1682:	9c 83       	std	Y+4, r25	; 0x04
    1684:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1686:	8d 81       	ldd	r24, Y+5	; 0x05
    1688:	9e 81       	ldd	r25, Y+6	; 0x06
    168a:	9a 83       	std	Y+2, r25	; 0x02
    168c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    168e:	89 81       	ldd	r24, Y+1	; 0x01
    1690:	eb 81       	ldd	r30, Y+3	; 0x03
    1692:	fc 81       	ldd	r31, Y+4	; 0x04
    1694:	80 83       	st	Z, r24
	pxTopOfStack--;
    1696:	8b 81       	ldd	r24, Y+3	; 0x03
    1698:	9c 81       	ldd	r25, Y+4	; 0x04
    169a:	01 97       	sbiw	r24, 0x01	; 1
    169c:	9c 83       	std	Y+4, r25	; 0x04
    169e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    16a0:	89 81       	ldd	r24, Y+1	; 0x01
    16a2:	9a 81       	ldd	r25, Y+2	; 0x02
    16a4:	89 2f       	mov	r24, r25
    16a6:	99 27       	eor	r25, r25
    16a8:	9a 83       	std	Y+2, r25	; 0x02
    16aa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    16ac:	89 81       	ldd	r24, Y+1	; 0x01
    16ae:	eb 81       	ldd	r30, Y+3	; 0x03
    16b0:	fc 81       	ldd	r31, Y+4	; 0x04
    16b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    16b4:	8b 81       	ldd	r24, Y+3	; 0x03
    16b6:	9c 81       	ldd	r25, Y+4	; 0x04
    16b8:	01 97       	sbiw	r24, 0x01	; 1
    16ba:	9c 83       	std	Y+4, r25	; 0x04
    16bc:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    16be:	eb 81       	ldd	r30, Y+3	; 0x03
    16c0:	fc 81       	ldd	r31, Y+4	; 0x04
    16c2:	10 82       	st	Z, r1
	pxTopOfStack--;
    16c4:	8b 81       	ldd	r24, Y+3	; 0x03
    16c6:	9c 81       	ldd	r25, Y+4	; 0x04
    16c8:	01 97       	sbiw	r24, 0x01	; 1
    16ca:	9c 83       	std	Y+4, r25	; 0x04
    16cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    16ce:	eb 81       	ldd	r30, Y+3	; 0x03
    16d0:	fc 81       	ldd	r31, Y+4	; 0x04
    16d2:	80 e8       	ldi	r24, 0x80	; 128
    16d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    16d6:	8b 81       	ldd	r24, Y+3	; 0x03
    16d8:	9c 81       	ldd	r25, Y+4	; 0x04
    16da:	01 97       	sbiw	r24, 0x01	; 1
    16dc:	9c 83       	std	Y+4, r25	; 0x04
    16de:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    16e0:	eb 81       	ldd	r30, Y+3	; 0x03
    16e2:	fc 81       	ldd	r31, Y+4	; 0x04
    16e4:	10 82       	st	Z, r1
	pxTopOfStack--;
    16e6:	8b 81       	ldd	r24, Y+3	; 0x03
    16e8:	9c 81       	ldd	r25, Y+4	; 0x04
    16ea:	01 97       	sbiw	r24, 0x01	; 1
    16ec:	9c 83       	std	Y+4, r25	; 0x04
    16ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    16f0:	eb 81       	ldd	r30, Y+3	; 0x03
    16f2:	fc 81       	ldd	r31, Y+4	; 0x04
    16f4:	82 e0       	ldi	r24, 0x02	; 2
    16f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    16f8:	8b 81       	ldd	r24, Y+3	; 0x03
    16fa:	9c 81       	ldd	r25, Y+4	; 0x04
    16fc:	01 97       	sbiw	r24, 0x01	; 1
    16fe:	9c 83       	std	Y+4, r25	; 0x04
    1700:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1702:	eb 81       	ldd	r30, Y+3	; 0x03
    1704:	fc 81       	ldd	r31, Y+4	; 0x04
    1706:	83 e0       	ldi	r24, 0x03	; 3
    1708:	80 83       	st	Z, r24
	pxTopOfStack--;
    170a:	8b 81       	ldd	r24, Y+3	; 0x03
    170c:	9c 81       	ldd	r25, Y+4	; 0x04
    170e:	01 97       	sbiw	r24, 0x01	; 1
    1710:	9c 83       	std	Y+4, r25	; 0x04
    1712:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1714:	eb 81       	ldd	r30, Y+3	; 0x03
    1716:	fc 81       	ldd	r31, Y+4	; 0x04
    1718:	84 e0       	ldi	r24, 0x04	; 4
    171a:	80 83       	st	Z, r24
	pxTopOfStack--;
    171c:	8b 81       	ldd	r24, Y+3	; 0x03
    171e:	9c 81       	ldd	r25, Y+4	; 0x04
    1720:	01 97       	sbiw	r24, 0x01	; 1
    1722:	9c 83       	std	Y+4, r25	; 0x04
    1724:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1726:	eb 81       	ldd	r30, Y+3	; 0x03
    1728:	fc 81       	ldd	r31, Y+4	; 0x04
    172a:	85 e0       	ldi	r24, 0x05	; 5
    172c:	80 83       	st	Z, r24
	pxTopOfStack--;
    172e:	8b 81       	ldd	r24, Y+3	; 0x03
    1730:	9c 81       	ldd	r25, Y+4	; 0x04
    1732:	01 97       	sbiw	r24, 0x01	; 1
    1734:	9c 83       	std	Y+4, r25	; 0x04
    1736:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1738:	eb 81       	ldd	r30, Y+3	; 0x03
    173a:	fc 81       	ldd	r31, Y+4	; 0x04
    173c:	86 e0       	ldi	r24, 0x06	; 6
    173e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1740:	8b 81       	ldd	r24, Y+3	; 0x03
    1742:	9c 81       	ldd	r25, Y+4	; 0x04
    1744:	01 97       	sbiw	r24, 0x01	; 1
    1746:	9c 83       	std	Y+4, r25	; 0x04
    1748:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    174a:	eb 81       	ldd	r30, Y+3	; 0x03
    174c:	fc 81       	ldd	r31, Y+4	; 0x04
    174e:	87 e0       	ldi	r24, 0x07	; 7
    1750:	80 83       	st	Z, r24
	pxTopOfStack--;
    1752:	8b 81       	ldd	r24, Y+3	; 0x03
    1754:	9c 81       	ldd	r25, Y+4	; 0x04
    1756:	01 97       	sbiw	r24, 0x01	; 1
    1758:	9c 83       	std	Y+4, r25	; 0x04
    175a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    175c:	eb 81       	ldd	r30, Y+3	; 0x03
    175e:	fc 81       	ldd	r31, Y+4	; 0x04
    1760:	88 e0       	ldi	r24, 0x08	; 8
    1762:	80 83       	st	Z, r24
	pxTopOfStack--;
    1764:	8b 81       	ldd	r24, Y+3	; 0x03
    1766:	9c 81       	ldd	r25, Y+4	; 0x04
    1768:	01 97       	sbiw	r24, 0x01	; 1
    176a:	9c 83       	std	Y+4, r25	; 0x04
    176c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    176e:	eb 81       	ldd	r30, Y+3	; 0x03
    1770:	fc 81       	ldd	r31, Y+4	; 0x04
    1772:	89 e0       	ldi	r24, 0x09	; 9
    1774:	80 83       	st	Z, r24
	pxTopOfStack--;
    1776:	8b 81       	ldd	r24, Y+3	; 0x03
    1778:	9c 81       	ldd	r25, Y+4	; 0x04
    177a:	01 97       	sbiw	r24, 0x01	; 1
    177c:	9c 83       	std	Y+4, r25	; 0x04
    177e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1780:	eb 81       	ldd	r30, Y+3	; 0x03
    1782:	fc 81       	ldd	r31, Y+4	; 0x04
    1784:	80 e1       	ldi	r24, 0x10	; 16
    1786:	80 83       	st	Z, r24
	pxTopOfStack--;
    1788:	8b 81       	ldd	r24, Y+3	; 0x03
    178a:	9c 81       	ldd	r25, Y+4	; 0x04
    178c:	01 97       	sbiw	r24, 0x01	; 1
    178e:	9c 83       	std	Y+4, r25	; 0x04
    1790:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1792:	eb 81       	ldd	r30, Y+3	; 0x03
    1794:	fc 81       	ldd	r31, Y+4	; 0x04
    1796:	81 e1       	ldi	r24, 0x11	; 17
    1798:	80 83       	st	Z, r24
	pxTopOfStack--;
    179a:	8b 81       	ldd	r24, Y+3	; 0x03
    179c:	9c 81       	ldd	r25, Y+4	; 0x04
    179e:	01 97       	sbiw	r24, 0x01	; 1
    17a0:	9c 83       	std	Y+4, r25	; 0x04
    17a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    17a4:	eb 81       	ldd	r30, Y+3	; 0x03
    17a6:	fc 81       	ldd	r31, Y+4	; 0x04
    17a8:	82 e1       	ldi	r24, 0x12	; 18
    17aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    17ac:	8b 81       	ldd	r24, Y+3	; 0x03
    17ae:	9c 81       	ldd	r25, Y+4	; 0x04
    17b0:	01 97       	sbiw	r24, 0x01	; 1
    17b2:	9c 83       	std	Y+4, r25	; 0x04
    17b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    17b6:	eb 81       	ldd	r30, Y+3	; 0x03
    17b8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ba:	83 e1       	ldi	r24, 0x13	; 19
    17bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    17be:	8b 81       	ldd	r24, Y+3	; 0x03
    17c0:	9c 81       	ldd	r25, Y+4	; 0x04
    17c2:	01 97       	sbiw	r24, 0x01	; 1
    17c4:	9c 83       	std	Y+4, r25	; 0x04
    17c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    17c8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ca:	fc 81       	ldd	r31, Y+4	; 0x04
    17cc:	84 e1       	ldi	r24, 0x14	; 20
    17ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    17d0:	8b 81       	ldd	r24, Y+3	; 0x03
    17d2:	9c 81       	ldd	r25, Y+4	; 0x04
    17d4:	01 97       	sbiw	r24, 0x01	; 1
    17d6:	9c 83       	std	Y+4, r25	; 0x04
    17d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    17da:	eb 81       	ldd	r30, Y+3	; 0x03
    17dc:	fc 81       	ldd	r31, Y+4	; 0x04
    17de:	85 e1       	ldi	r24, 0x15	; 21
    17e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17e2:	8b 81       	ldd	r24, Y+3	; 0x03
    17e4:	9c 81       	ldd	r25, Y+4	; 0x04
    17e6:	01 97       	sbiw	r24, 0x01	; 1
    17e8:	9c 83       	std	Y+4, r25	; 0x04
    17ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    17ec:	eb 81       	ldd	r30, Y+3	; 0x03
    17ee:	fc 81       	ldd	r31, Y+4	; 0x04
    17f0:	86 e1       	ldi	r24, 0x16	; 22
    17f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f4:	8b 81       	ldd	r24, Y+3	; 0x03
    17f6:	9c 81       	ldd	r25, Y+4	; 0x04
    17f8:	01 97       	sbiw	r24, 0x01	; 1
    17fa:	9c 83       	std	Y+4, r25	; 0x04
    17fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    17fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1800:	fc 81       	ldd	r31, Y+4	; 0x04
    1802:	87 e1       	ldi	r24, 0x17	; 23
    1804:	80 83       	st	Z, r24
	pxTopOfStack--;
    1806:	8b 81       	ldd	r24, Y+3	; 0x03
    1808:	9c 81       	ldd	r25, Y+4	; 0x04
    180a:	01 97       	sbiw	r24, 0x01	; 1
    180c:	9c 83       	std	Y+4, r25	; 0x04
    180e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1810:	eb 81       	ldd	r30, Y+3	; 0x03
    1812:	fc 81       	ldd	r31, Y+4	; 0x04
    1814:	88 e1       	ldi	r24, 0x18	; 24
    1816:	80 83       	st	Z, r24
	pxTopOfStack--;
    1818:	8b 81       	ldd	r24, Y+3	; 0x03
    181a:	9c 81       	ldd	r25, Y+4	; 0x04
    181c:	01 97       	sbiw	r24, 0x01	; 1
    181e:	9c 83       	std	Y+4, r25	; 0x04
    1820:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1822:	eb 81       	ldd	r30, Y+3	; 0x03
    1824:	fc 81       	ldd	r31, Y+4	; 0x04
    1826:	89 e1       	ldi	r24, 0x19	; 25
    1828:	80 83       	st	Z, r24
	pxTopOfStack--;
    182a:	8b 81       	ldd	r24, Y+3	; 0x03
    182c:	9c 81       	ldd	r25, Y+4	; 0x04
    182e:	01 97       	sbiw	r24, 0x01	; 1
    1830:	9c 83       	std	Y+4, r25	; 0x04
    1832:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1834:	eb 81       	ldd	r30, Y+3	; 0x03
    1836:	fc 81       	ldd	r31, Y+4	; 0x04
    1838:	80 e2       	ldi	r24, 0x20	; 32
    183a:	80 83       	st	Z, r24
	pxTopOfStack--;
    183c:	8b 81       	ldd	r24, Y+3	; 0x03
    183e:	9c 81       	ldd	r25, Y+4	; 0x04
    1840:	01 97       	sbiw	r24, 0x01	; 1
    1842:	9c 83       	std	Y+4, r25	; 0x04
    1844:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1846:	eb 81       	ldd	r30, Y+3	; 0x03
    1848:	fc 81       	ldd	r31, Y+4	; 0x04
    184a:	81 e2       	ldi	r24, 0x21	; 33
    184c:	80 83       	st	Z, r24
	pxTopOfStack--;
    184e:	8b 81       	ldd	r24, Y+3	; 0x03
    1850:	9c 81       	ldd	r25, Y+4	; 0x04
    1852:	01 97       	sbiw	r24, 0x01	; 1
    1854:	9c 83       	std	Y+4, r25	; 0x04
    1856:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1858:	eb 81       	ldd	r30, Y+3	; 0x03
    185a:	fc 81       	ldd	r31, Y+4	; 0x04
    185c:	82 e2       	ldi	r24, 0x22	; 34
    185e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1860:	8b 81       	ldd	r24, Y+3	; 0x03
    1862:	9c 81       	ldd	r25, Y+4	; 0x04
    1864:	01 97       	sbiw	r24, 0x01	; 1
    1866:	9c 83       	std	Y+4, r25	; 0x04
    1868:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    186a:	eb 81       	ldd	r30, Y+3	; 0x03
    186c:	fc 81       	ldd	r31, Y+4	; 0x04
    186e:	83 e2       	ldi	r24, 0x23	; 35
    1870:	80 83       	st	Z, r24
	pxTopOfStack--;
    1872:	8b 81       	ldd	r24, Y+3	; 0x03
    1874:	9c 81       	ldd	r25, Y+4	; 0x04
    1876:	01 97       	sbiw	r24, 0x01	; 1
    1878:	9c 83       	std	Y+4, r25	; 0x04
    187a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    187c:	8f 81       	ldd	r24, Y+7	; 0x07
    187e:	98 85       	ldd	r25, Y+8	; 0x08
    1880:	9a 83       	std	Y+2, r25	; 0x02
    1882:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1884:	89 81       	ldd	r24, Y+1	; 0x01
    1886:	eb 81       	ldd	r30, Y+3	; 0x03
    1888:	fc 81       	ldd	r31, Y+4	; 0x04
    188a:	80 83       	st	Z, r24
	pxTopOfStack--;
    188c:	8b 81       	ldd	r24, Y+3	; 0x03
    188e:	9c 81       	ldd	r25, Y+4	; 0x04
    1890:	01 97       	sbiw	r24, 0x01	; 1
    1892:	9c 83       	std	Y+4, r25	; 0x04
    1894:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1896:	89 81       	ldd	r24, Y+1	; 0x01
    1898:	9a 81       	ldd	r25, Y+2	; 0x02
    189a:	89 2f       	mov	r24, r25
    189c:	99 27       	eor	r25, r25
    189e:	9a 83       	std	Y+2, r25	; 0x02
    18a0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    18a2:	89 81       	ldd	r24, Y+1	; 0x01
    18a4:	eb 81       	ldd	r30, Y+3	; 0x03
    18a6:	fc 81       	ldd	r31, Y+4	; 0x04
    18a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18aa:	8b 81       	ldd	r24, Y+3	; 0x03
    18ac:	9c 81       	ldd	r25, Y+4	; 0x04
    18ae:	01 97       	sbiw	r24, 0x01	; 1
    18b0:	9c 83       	std	Y+4, r25	; 0x04
    18b2:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    18b4:	eb 81       	ldd	r30, Y+3	; 0x03
    18b6:	fc 81       	ldd	r31, Y+4	; 0x04
    18b8:	86 e2       	ldi	r24, 0x26	; 38
    18ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    18bc:	8b 81       	ldd	r24, Y+3	; 0x03
    18be:	9c 81       	ldd	r25, Y+4	; 0x04
    18c0:	01 97       	sbiw	r24, 0x01	; 1
    18c2:	9c 83       	std	Y+4, r25	; 0x04
    18c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    18c6:	eb 81       	ldd	r30, Y+3	; 0x03
    18c8:	fc 81       	ldd	r31, Y+4	; 0x04
    18ca:	87 e2       	ldi	r24, 0x27	; 39
    18cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ce:	8b 81       	ldd	r24, Y+3	; 0x03
    18d0:	9c 81       	ldd	r25, Y+4	; 0x04
    18d2:	01 97       	sbiw	r24, 0x01	; 1
    18d4:	9c 83       	std	Y+4, r25	; 0x04
    18d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    18d8:	eb 81       	ldd	r30, Y+3	; 0x03
    18da:	fc 81       	ldd	r31, Y+4	; 0x04
    18dc:	88 e2       	ldi	r24, 0x28	; 40
    18de:	80 83       	st	Z, r24
	pxTopOfStack--;
    18e0:	8b 81       	ldd	r24, Y+3	; 0x03
    18e2:	9c 81       	ldd	r25, Y+4	; 0x04
    18e4:	01 97       	sbiw	r24, 0x01	; 1
    18e6:	9c 83       	std	Y+4, r25	; 0x04
    18e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    18ea:	eb 81       	ldd	r30, Y+3	; 0x03
    18ec:	fc 81       	ldd	r31, Y+4	; 0x04
    18ee:	89 e2       	ldi	r24, 0x29	; 41
    18f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    18f2:	8b 81       	ldd	r24, Y+3	; 0x03
    18f4:	9c 81       	ldd	r25, Y+4	; 0x04
    18f6:	01 97       	sbiw	r24, 0x01	; 1
    18f8:	9c 83       	std	Y+4, r25	; 0x04
    18fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    18fc:	eb 81       	ldd	r30, Y+3	; 0x03
    18fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1900:	80 e3       	ldi	r24, 0x30	; 48
    1902:	80 83       	st	Z, r24
	pxTopOfStack--;
    1904:	8b 81       	ldd	r24, Y+3	; 0x03
    1906:	9c 81       	ldd	r25, Y+4	; 0x04
    1908:	01 97       	sbiw	r24, 0x01	; 1
    190a:	9c 83       	std	Y+4, r25	; 0x04
    190c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    190e:	eb 81       	ldd	r30, Y+3	; 0x03
    1910:	fc 81       	ldd	r31, Y+4	; 0x04
    1912:	81 e3       	ldi	r24, 0x31	; 49
    1914:	80 83       	st	Z, r24
	pxTopOfStack--;
    1916:	8b 81       	ldd	r24, Y+3	; 0x03
    1918:	9c 81       	ldd	r25, Y+4	; 0x04
    191a:	01 97       	sbiw	r24, 0x01	; 1
    191c:	9c 83       	std	Y+4, r25	; 0x04
    191e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1920:	8b 81       	ldd	r24, Y+3	; 0x03
    1922:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1924:	28 96       	adiw	r28, 0x08	; 8
    1926:	0f b6       	in	r0, 0x3f	; 63
    1928:	f8 94       	cli
    192a:	de bf       	out	0x3e, r29	; 62
    192c:	0f be       	out	0x3f, r0	; 63
    192e:	cd bf       	out	0x3d, r28	; 61
    1930:	cf 91       	pop	r28
    1932:	df 91       	pop	r29
    1934:	08 95       	ret

00001936 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1936:	df 93       	push	r29
    1938:	cf 93       	push	r28
    193a:	cd b7       	in	r28, 0x3d	; 61
    193c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    193e:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1942:	a0 91 a8 06 	lds	r26, 0x06A8
    1946:	b0 91 a9 06 	lds	r27, 0x06A9
    194a:	cd 91       	ld	r28, X+
    194c:	cd bf       	out	0x3d, r28	; 61
    194e:	dd 91       	ld	r29, X+
    1950:	de bf       	out	0x3e, r29	; 62
    1952:	ff 91       	pop	r31
    1954:	ef 91       	pop	r30
    1956:	df 91       	pop	r29
    1958:	cf 91       	pop	r28
    195a:	bf 91       	pop	r27
    195c:	af 91       	pop	r26
    195e:	9f 91       	pop	r25
    1960:	8f 91       	pop	r24
    1962:	7f 91       	pop	r23
    1964:	6f 91       	pop	r22
    1966:	5f 91       	pop	r21
    1968:	4f 91       	pop	r20
    196a:	3f 91       	pop	r19
    196c:	2f 91       	pop	r18
    196e:	1f 91       	pop	r17
    1970:	0f 91       	pop	r16
    1972:	ff 90       	pop	r15
    1974:	ef 90       	pop	r14
    1976:	df 90       	pop	r13
    1978:	cf 90       	pop	r12
    197a:	bf 90       	pop	r11
    197c:	af 90       	pop	r10
    197e:	9f 90       	pop	r9
    1980:	8f 90       	pop	r8
    1982:	7f 90       	pop	r7
    1984:	6f 90       	pop	r6
    1986:	5f 90       	pop	r5
    1988:	4f 90       	pop	r4
    198a:	3f 90       	pop	r3
    198c:	2f 90       	pop	r2
    198e:	1f 90       	pop	r1
    1990:	0f 90       	pop	r0
    1992:	0f be       	out	0x3f, r0	; 63
    1994:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1996:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1998:	81 e0       	ldi	r24, 0x01	; 1
}
    199a:	cf 91       	pop	r28
    199c:	df 91       	pop	r29
    199e:	08 95       	ret

000019a0 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    19a0:	df 93       	push	r29
    19a2:	cf 93       	push	r28
    19a4:	cd b7       	in	r28, 0x3d	; 61
    19a6:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    19a8:	cf 91       	pop	r28
    19aa:	df 91       	pop	r29
    19ac:	08 95       	ret

000019ae <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    19ae:	0f 92       	push	r0
    19b0:	0f b6       	in	r0, 0x3f	; 63
    19b2:	f8 94       	cli
    19b4:	0f 92       	push	r0
    19b6:	1f 92       	push	r1
    19b8:	11 24       	eor	r1, r1
    19ba:	2f 92       	push	r2
    19bc:	3f 92       	push	r3
    19be:	4f 92       	push	r4
    19c0:	5f 92       	push	r5
    19c2:	6f 92       	push	r6
    19c4:	7f 92       	push	r7
    19c6:	8f 92       	push	r8
    19c8:	9f 92       	push	r9
    19ca:	af 92       	push	r10
    19cc:	bf 92       	push	r11
    19ce:	cf 92       	push	r12
    19d0:	df 92       	push	r13
    19d2:	ef 92       	push	r14
    19d4:	ff 92       	push	r15
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	2f 93       	push	r18
    19dc:	3f 93       	push	r19
    19de:	4f 93       	push	r20
    19e0:	5f 93       	push	r21
    19e2:	6f 93       	push	r22
    19e4:	7f 93       	push	r23
    19e6:	8f 93       	push	r24
    19e8:	9f 93       	push	r25
    19ea:	af 93       	push	r26
    19ec:	bf 93       	push	r27
    19ee:	cf 93       	push	r28
    19f0:	df 93       	push	r29
    19f2:	ef 93       	push	r30
    19f4:	ff 93       	push	r31
    19f6:	a0 91 a8 06 	lds	r26, 0x06A8
    19fa:	b0 91 a9 06 	lds	r27, 0x06A9
    19fe:	0d b6       	in	r0, 0x3d	; 61
    1a00:	0d 92       	st	X+, r0
    1a02:	0e b6       	in	r0, 0x3e	; 62
    1a04:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1a06:	0e 94 6e 22 	call	0x44dc	; 0x44dc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a0a:	a0 91 a8 06 	lds	r26, 0x06A8
    1a0e:	b0 91 a9 06 	lds	r27, 0x06A9
    1a12:	cd 91       	ld	r28, X+
    1a14:	cd bf       	out	0x3d, r28	; 61
    1a16:	dd 91       	ld	r29, X+
    1a18:	de bf       	out	0x3e, r29	; 62
    1a1a:	ff 91       	pop	r31
    1a1c:	ef 91       	pop	r30
    1a1e:	df 91       	pop	r29
    1a20:	cf 91       	pop	r28
    1a22:	bf 91       	pop	r27
    1a24:	af 91       	pop	r26
    1a26:	9f 91       	pop	r25
    1a28:	8f 91       	pop	r24
    1a2a:	7f 91       	pop	r23
    1a2c:	6f 91       	pop	r22
    1a2e:	5f 91       	pop	r21
    1a30:	4f 91       	pop	r20
    1a32:	3f 91       	pop	r19
    1a34:	2f 91       	pop	r18
    1a36:	1f 91       	pop	r17
    1a38:	0f 91       	pop	r16
    1a3a:	ff 90       	pop	r15
    1a3c:	ef 90       	pop	r14
    1a3e:	df 90       	pop	r13
    1a40:	cf 90       	pop	r12
    1a42:	bf 90       	pop	r11
    1a44:	af 90       	pop	r10
    1a46:	9f 90       	pop	r9
    1a48:	8f 90       	pop	r8
    1a4a:	7f 90       	pop	r7
    1a4c:	6f 90       	pop	r6
    1a4e:	5f 90       	pop	r5
    1a50:	4f 90       	pop	r4
    1a52:	3f 90       	pop	r3
    1a54:	2f 90       	pop	r2
    1a56:	1f 90       	pop	r1
    1a58:	0f 90       	pop	r0
    1a5a:	0f be       	out	0x3f, r0	; 63
    1a5c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a5e:	08 95       	ret

00001a60 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1a60:	0f 92       	push	r0
    1a62:	0f b6       	in	r0, 0x3f	; 63
    1a64:	f8 94       	cli
    1a66:	0f 92       	push	r0
    1a68:	1f 92       	push	r1
    1a6a:	11 24       	eor	r1, r1
    1a6c:	2f 92       	push	r2
    1a6e:	3f 92       	push	r3
    1a70:	4f 92       	push	r4
    1a72:	5f 92       	push	r5
    1a74:	6f 92       	push	r6
    1a76:	7f 92       	push	r7
    1a78:	8f 92       	push	r8
    1a7a:	9f 92       	push	r9
    1a7c:	af 92       	push	r10
    1a7e:	bf 92       	push	r11
    1a80:	cf 92       	push	r12
    1a82:	df 92       	push	r13
    1a84:	ef 92       	push	r14
    1a86:	ff 92       	push	r15
    1a88:	0f 93       	push	r16
    1a8a:	1f 93       	push	r17
    1a8c:	2f 93       	push	r18
    1a8e:	3f 93       	push	r19
    1a90:	4f 93       	push	r20
    1a92:	5f 93       	push	r21
    1a94:	6f 93       	push	r22
    1a96:	7f 93       	push	r23
    1a98:	8f 93       	push	r24
    1a9a:	9f 93       	push	r25
    1a9c:	af 93       	push	r26
    1a9e:	bf 93       	push	r27
    1aa0:	cf 93       	push	r28
    1aa2:	df 93       	push	r29
    1aa4:	ef 93       	push	r30
    1aa6:	ff 93       	push	r31
    1aa8:	a0 91 a8 06 	lds	r26, 0x06A8
    1aac:	b0 91 a9 06 	lds	r27, 0x06A9
    1ab0:	0d b6       	in	r0, 0x3d	; 61
    1ab2:	0d 92       	st	X+, r0
    1ab4:	0e b6       	in	r0, 0x3e	; 62
    1ab6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1ab8:	0e 94 89 21 	call	0x4312	; 0x4312 <xTaskIncrementTick>
    1abc:	88 23       	and	r24, r24
    1abe:	11 f0       	breq	.+4      	; 0x1ac4 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1ac0:	0e 94 6e 22 	call	0x44dc	; 0x44dc <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1ac4:	a0 91 a8 06 	lds	r26, 0x06A8
    1ac8:	b0 91 a9 06 	lds	r27, 0x06A9
    1acc:	cd 91       	ld	r28, X+
    1ace:	cd bf       	out	0x3d, r28	; 61
    1ad0:	dd 91       	ld	r29, X+
    1ad2:	de bf       	out	0x3e, r29	; 62
    1ad4:	ff 91       	pop	r31
    1ad6:	ef 91       	pop	r30
    1ad8:	df 91       	pop	r29
    1ada:	cf 91       	pop	r28
    1adc:	bf 91       	pop	r27
    1ade:	af 91       	pop	r26
    1ae0:	9f 91       	pop	r25
    1ae2:	8f 91       	pop	r24
    1ae4:	7f 91       	pop	r23
    1ae6:	6f 91       	pop	r22
    1ae8:	5f 91       	pop	r21
    1aea:	4f 91       	pop	r20
    1aec:	3f 91       	pop	r19
    1aee:	2f 91       	pop	r18
    1af0:	1f 91       	pop	r17
    1af2:	0f 91       	pop	r16
    1af4:	ff 90       	pop	r15
    1af6:	ef 90       	pop	r14
    1af8:	df 90       	pop	r13
    1afa:	cf 90       	pop	r12
    1afc:	bf 90       	pop	r11
    1afe:	af 90       	pop	r10
    1b00:	9f 90       	pop	r9
    1b02:	8f 90       	pop	r8
    1b04:	7f 90       	pop	r7
    1b06:	6f 90       	pop	r6
    1b08:	5f 90       	pop	r5
    1b0a:	4f 90       	pop	r4
    1b0c:	3f 90       	pop	r3
    1b0e:	2f 90       	pop	r2
    1b10:	1f 90       	pop	r1
    1b12:	0f 90       	pop	r0
    1b14:	0f be       	out	0x3f, r0	; 63
    1b16:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b18:	08 95       	ret

00001b1a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1b1a:	df 93       	push	r29
    1b1c:	cf 93       	push	r28
    1b1e:	00 d0       	rcall	.+0      	; 0x1b20 <prvSetupTimerInterrupt+0x6>
    1b20:	00 d0       	rcall	.+0      	; 0x1b22 <prvSetupTimerInterrupt+0x8>
    1b22:	00 d0       	rcall	.+0      	; 0x1b24 <prvSetupTimerInterrupt+0xa>
    1b24:	cd b7       	in	r28, 0x3d	; 61
    1b26:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1b28:	80 e4       	ldi	r24, 0x40	; 64
    1b2a:	9f e1       	ldi	r25, 0x1F	; 31
    1b2c:	a0 e0       	ldi	r26, 0x00	; 0
    1b2e:	b0 e0       	ldi	r27, 0x00	; 0
    1b30:	8b 83       	std	Y+3, r24	; 0x03
    1b32:	9c 83       	std	Y+4, r25	; 0x04
    1b34:	ad 83       	std	Y+5, r26	; 0x05
    1b36:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1b38:	8b 81       	ldd	r24, Y+3	; 0x03
    1b3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b3c:	ad 81       	ldd	r26, Y+5	; 0x05
    1b3e:	be 81       	ldd	r27, Y+6	; 0x06
    1b40:	68 94       	set
    1b42:	15 f8       	bld	r1, 5
    1b44:	b6 95       	lsr	r27
    1b46:	a7 95       	ror	r26
    1b48:	97 95       	ror	r25
    1b4a:	87 95       	ror	r24
    1b4c:	16 94       	lsr	r1
    1b4e:	d1 f7       	brne	.-12     	; 0x1b44 <prvSetupTimerInterrupt+0x2a>
    1b50:	8b 83       	std	Y+3, r24	; 0x03
    1b52:	9c 83       	std	Y+4, r25	; 0x04
    1b54:	ad 83       	std	Y+5, r26	; 0x05
    1b56:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1b58:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5c:	ad 81       	ldd	r26, Y+5	; 0x05
    1b5e:	be 81       	ldd	r27, Y+6	; 0x06
    1b60:	01 97       	sbiw	r24, 0x01	; 1
    1b62:	a1 09       	sbc	r26, r1
    1b64:	b1 09       	sbc	r27, r1
    1b66:	8b 83       	std	Y+3, r24	; 0x03
    1b68:	9c 83       	std	Y+4, r25	; 0x04
    1b6a:	ad 83       	std	Y+5, r26	; 0x05
    1b6c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1b6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b70:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1b72:	8b 81       	ldd	r24, Y+3	; 0x03
    1b74:	9c 81       	ldd	r25, Y+4	; 0x04
    1b76:	ad 81       	ldd	r26, Y+5	; 0x05
    1b78:	be 81       	ldd	r27, Y+6	; 0x06
    1b7a:	89 2f       	mov	r24, r25
    1b7c:	9a 2f       	mov	r25, r26
    1b7e:	ab 2f       	mov	r26, r27
    1b80:	bb 27       	eor	r27, r27
    1b82:	8b 83       	std	Y+3, r24	; 0x03
    1b84:	9c 83       	std	Y+4, r25	; 0x04
    1b86:	ad 83       	std	Y+5, r26	; 0x05
    1b88:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b8c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1b8e:	eb e4       	ldi	r30, 0x4B	; 75
    1b90:	f0 e0       	ldi	r31, 0x00	; 0
    1b92:	8a 81       	ldd	r24, Y+2	; 0x02
    1b94:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1b96:	ea e4       	ldi	r30, 0x4A	; 74
    1b98:	f0 e0       	ldi	r31, 0x00	; 0
    1b9a:	89 81       	ldd	r24, Y+1	; 0x01
    1b9c:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1b9e:	8b e0       	ldi	r24, 0x0B	; 11
    1ba0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1ba2:	ee e4       	ldi	r30, 0x4E	; 78
    1ba4:	f0 e0       	ldi	r31, 0x00	; 0
    1ba6:	89 81       	ldd	r24, Y+1	; 0x01
    1ba8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1baa:	e9 e5       	ldi	r30, 0x59	; 89
    1bac:	f0 e0       	ldi	r31, 0x00	; 0
    1bae:	80 81       	ld	r24, Z
    1bb0:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1bb2:	89 81       	ldd	r24, Y+1	; 0x01
    1bb4:	80 61       	ori	r24, 0x10	; 16
    1bb6:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1bb8:	e9 e5       	ldi	r30, 0x59	; 89
    1bba:	f0 e0       	ldi	r31, 0x00	; 0
    1bbc:	89 81       	ldd	r24, Y+1	; 0x01
    1bbe:	80 83       	st	Z, r24
}
    1bc0:	26 96       	adiw	r28, 0x06	; 6
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	f8 94       	cli
    1bc6:	de bf       	out	0x3e, r29	; 62
    1bc8:	0f be       	out	0x3f, r0	; 63
    1bca:	cd bf       	out	0x3d, r28	; 61
    1bcc:	cf 91       	pop	r28
    1bce:	df 91       	pop	r29
    1bd0:	08 95       	ret

00001bd2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1bd2:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1bd6:	18 95       	reti

00001bd8 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1bd8:	df 93       	push	r29
    1bda:	cf 93       	push	r28
    1bdc:	00 d0       	rcall	.+0      	; 0x1bde <xQueueGenericReset+0x6>
    1bde:	00 d0       	rcall	.+0      	; 0x1be0 <xQueueGenericReset+0x8>
    1be0:	0f 92       	push	r0
    1be2:	cd b7       	in	r28, 0x3d	; 61
    1be4:	de b7       	in	r29, 0x3e	; 62
    1be6:	9c 83       	std	Y+4, r25	; 0x04
    1be8:	8b 83       	std	Y+3, r24	; 0x03
    1bea:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1bec:	8b 81       	ldd	r24, Y+3	; 0x03
    1bee:	9c 81       	ldd	r25, Y+4	; 0x04
    1bf0:	9a 83       	std	Y+2, r25	; 0x02
    1bf2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1bf4:	0f b6       	in	r0, 0x3f	; 63
    1bf6:	f8 94       	cli
    1bf8:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1bfe:	40 81       	ld	r20, Z
    1c00:	51 81       	ldd	r21, Z+1	; 0x01
    1c02:	e9 81       	ldd	r30, Y+1	; 0x01
    1c04:	fa 81       	ldd	r31, Y+2	; 0x02
    1c06:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c08:	28 2f       	mov	r18, r24
    1c0a:	30 e0       	ldi	r19, 0x00	; 0
    1c0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c10:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c12:	88 2f       	mov	r24, r24
    1c14:	90 e0       	ldi	r25, 0x00	; 0
    1c16:	bc 01       	movw	r22, r24
    1c18:	26 9f       	mul	r18, r22
    1c1a:	c0 01       	movw	r24, r0
    1c1c:	27 9f       	mul	r18, r23
    1c1e:	90 0d       	add	r25, r0
    1c20:	36 9f       	mul	r19, r22
    1c22:	90 0d       	add	r25, r0
    1c24:	11 24       	eor	r1, r1
    1c26:	84 0f       	add	r24, r20
    1c28:	95 1f       	adc	r25, r21
    1c2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c2e:	95 83       	std	Z+5, r25	; 0x05
    1c30:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1c32:	e9 81       	ldd	r30, Y+1	; 0x01
    1c34:	fa 81       	ldd	r31, Y+2	; 0x02
    1c36:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1c38:	e9 81       	ldd	r30, Y+1	; 0x01
    1c3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c3c:	80 81       	ld	r24, Z
    1c3e:	91 81       	ldd	r25, Z+1	; 0x01
    1c40:	e9 81       	ldd	r30, Y+1	; 0x01
    1c42:	fa 81       	ldd	r31, Y+2	; 0x02
    1c44:	93 83       	std	Z+3, r25	; 0x03
    1c46:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1c48:	e9 81       	ldd	r30, Y+1	; 0x01
    1c4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c4c:	40 81       	ld	r20, Z
    1c4e:	51 81       	ldd	r21, Z+1	; 0x01
    1c50:	e9 81       	ldd	r30, Y+1	; 0x01
    1c52:	fa 81       	ldd	r31, Y+2	; 0x02
    1c54:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c56:	88 2f       	mov	r24, r24
    1c58:	90 e0       	ldi	r25, 0x00	; 0
    1c5a:	9c 01       	movw	r18, r24
    1c5c:	21 50       	subi	r18, 0x01	; 1
    1c5e:	30 40       	sbci	r19, 0x00	; 0
    1c60:	e9 81       	ldd	r30, Y+1	; 0x01
    1c62:	fa 81       	ldd	r31, Y+2	; 0x02
    1c64:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c66:	88 2f       	mov	r24, r24
    1c68:	90 e0       	ldi	r25, 0x00	; 0
    1c6a:	bc 01       	movw	r22, r24
    1c6c:	26 9f       	mul	r18, r22
    1c6e:	c0 01       	movw	r24, r0
    1c70:	27 9f       	mul	r18, r23
    1c72:	90 0d       	add	r25, r0
    1c74:	36 9f       	mul	r19, r22
    1c76:	90 0d       	add	r25, r0
    1c78:	11 24       	eor	r1, r1
    1c7a:	84 0f       	add	r24, r20
    1c7c:	95 1f       	adc	r25, r21
    1c7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c80:	fa 81       	ldd	r31, Y+2	; 0x02
    1c82:	97 83       	std	Z+7, r25	; 0x07
    1c84:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1c86:	e9 81       	ldd	r30, Y+1	; 0x01
    1c88:	fa 81       	ldd	r31, Y+2	; 0x02
    1c8a:	8f ef       	ldi	r24, 0xFF	; 255
    1c8c:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1c8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c90:	fa 81       	ldd	r31, Y+2	; 0x02
    1c92:	8f ef       	ldi	r24, 0xFF	; 255
    1c94:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1c96:	8d 81       	ldd	r24, Y+5	; 0x05
    1c98:	88 23       	and	r24, r24
    1c9a:	79 f4       	brne	.+30     	; 0x1cba <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca0:	80 85       	ldd	r24, Z+8	; 0x08
    1ca2:	88 23       	and	r24, r24
    1ca4:	a1 f0       	breq	.+40     	; 0x1cce <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ca6:	89 81       	ldd	r24, Y+1	; 0x01
    1ca8:	9a 81       	ldd	r25, Y+2	; 0x02
    1caa:	08 96       	adiw	r24, 0x08	; 8
    1cac:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    1cb0:	88 23       	and	r24, r24
    1cb2:	69 f0       	breq	.+26     	; 0x1cce <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1cb4:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
    1cb8:	0a c0       	rjmp	.+20     	; 0x1cce <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1cba:	89 81       	ldd	r24, Y+1	; 0x01
    1cbc:	9a 81       	ldd	r25, Y+2	; 0x02
    1cbe:	08 96       	adiw	r24, 0x08	; 8
    1cc0:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1cc4:	89 81       	ldd	r24, Y+1	; 0x01
    1cc6:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc8:	41 96       	adiw	r24, 0x11	; 17
    1cca:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1cce:	0f 90       	pop	r0
    1cd0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1cd2:	81 e0       	ldi	r24, 0x01	; 1
}
    1cd4:	0f 90       	pop	r0
    1cd6:	0f 90       	pop	r0
    1cd8:	0f 90       	pop	r0
    1cda:	0f 90       	pop	r0
    1cdc:	0f 90       	pop	r0
    1cde:	cf 91       	pop	r28
    1ce0:	df 91       	pop	r29
    1ce2:	08 95       	ret

00001ce4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1ce4:	0f 93       	push	r16
    1ce6:	1f 93       	push	r17
    1ce8:	df 93       	push	r29
    1cea:	cf 93       	push	r28
    1cec:	cd b7       	in	r28, 0x3d	; 61
    1cee:	de b7       	in	r29, 0x3e	; 62
    1cf0:	29 97       	sbiw	r28, 0x09	; 9
    1cf2:	0f b6       	in	r0, 0x3f	; 63
    1cf4:	f8 94       	cli
    1cf6:	de bf       	out	0x3e, r29	; 62
    1cf8:	0f be       	out	0x3f, r0	; 63
    1cfa:	cd bf       	out	0x3d, r28	; 61
    1cfc:	8f 83       	std	Y+7, r24	; 0x07
    1cfe:	68 87       	std	Y+8, r22	; 0x08
    1d00:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1d02:	88 85       	ldd	r24, Y+8	; 0x08
    1d04:	88 23       	and	r24, r24
    1d06:	19 f4       	brne	.+6      	; 0x1d0e <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1d08:	1c 82       	std	Y+4, r1	; 0x04
    1d0a:	1b 82       	std	Y+3, r1	; 0x03
    1d0c:	10 c0       	rjmp	.+32     	; 0x1d2e <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1d0e:	8f 81       	ldd	r24, Y+7	; 0x07
    1d10:	28 2f       	mov	r18, r24
    1d12:	30 e0       	ldi	r19, 0x00	; 0
    1d14:	88 85       	ldd	r24, Y+8	; 0x08
    1d16:	88 2f       	mov	r24, r24
    1d18:	90 e0       	ldi	r25, 0x00	; 0
    1d1a:	ac 01       	movw	r20, r24
    1d1c:	24 9f       	mul	r18, r20
    1d1e:	c0 01       	movw	r24, r0
    1d20:	25 9f       	mul	r18, r21
    1d22:	90 0d       	add	r25, r0
    1d24:	34 9f       	mul	r19, r20
    1d26:	90 0d       	add	r25, r0
    1d28:	11 24       	eor	r1, r1
    1d2a:	9c 83       	std	Y+4, r25	; 0x04
    1d2c:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d30:	9c 81       	ldd	r25, Y+4	; 0x04
    1d32:	4f 96       	adiw	r24, 0x1f	; 31
    1d34:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
    1d38:	9e 83       	std	Y+6, r25	; 0x06
    1d3a:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1d3c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d3e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d40:	00 97       	sbiw	r24, 0x00	; 0
    1d42:	a1 f0       	breq	.+40     	; 0x1d6c <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1d44:	8d 81       	ldd	r24, Y+5	; 0x05
    1d46:	9e 81       	ldd	r25, Y+6	; 0x06
    1d48:	9a 83       	std	Y+2, r25	; 0x02
    1d4a:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1d4c:	89 81       	ldd	r24, Y+1	; 0x01
    1d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d50:	4f 96       	adiw	r24, 0x1f	; 31
    1d52:	9a 83       	std	Y+2, r25	; 0x02
    1d54:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1d56:	29 81       	ldd	r18, Y+1	; 0x01
    1d58:	3a 81       	ldd	r19, Y+2	; 0x02
    1d5a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d5c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d5e:	8f 81       	ldd	r24, Y+7	; 0x07
    1d60:	68 85       	ldd	r22, Y+8	; 0x08
    1d62:	a9 01       	movw	r20, r18
    1d64:	29 85       	ldd	r18, Y+9	; 0x09
    1d66:	8f 01       	movw	r16, r30
    1d68:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1d6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d6e:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1d70:	29 96       	adiw	r28, 0x09	; 9
    1d72:	0f b6       	in	r0, 0x3f	; 63
    1d74:	f8 94       	cli
    1d76:	de bf       	out	0x3e, r29	; 62
    1d78:	0f be       	out	0x3f, r0	; 63
    1d7a:	cd bf       	out	0x3d, r28	; 61
    1d7c:	cf 91       	pop	r28
    1d7e:	df 91       	pop	r29
    1d80:	1f 91       	pop	r17
    1d82:	0f 91       	pop	r16
    1d84:	08 95       	ret

00001d86 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1d86:	0f 93       	push	r16
    1d88:	1f 93       	push	r17
    1d8a:	df 93       	push	r29
    1d8c:	cf 93       	push	r28
    1d8e:	cd b7       	in	r28, 0x3d	; 61
    1d90:	de b7       	in	r29, 0x3e	; 62
    1d92:	27 97       	sbiw	r28, 0x07	; 7
    1d94:	0f b6       	in	r0, 0x3f	; 63
    1d96:	f8 94       	cli
    1d98:	de bf       	out	0x3e, r29	; 62
    1d9a:	0f be       	out	0x3f, r0	; 63
    1d9c:	cd bf       	out	0x3d, r28	; 61
    1d9e:	89 83       	std	Y+1, r24	; 0x01
    1da0:	6a 83       	std	Y+2, r22	; 0x02
    1da2:	5c 83       	std	Y+4, r21	; 0x04
    1da4:	4b 83       	std	Y+3, r20	; 0x03
    1da6:	2d 83       	std	Y+5, r18	; 0x05
    1da8:	1f 83       	std	Y+7, r17	; 0x07
    1daa:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1dac:	8a 81       	ldd	r24, Y+2	; 0x02
    1dae:	88 23       	and	r24, r24
    1db0:	39 f4       	brne	.+14     	; 0x1dc0 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1db2:	8e 81       	ldd	r24, Y+6	; 0x06
    1db4:	9f 81       	ldd	r25, Y+7	; 0x07
    1db6:	ee 81       	ldd	r30, Y+6	; 0x06
    1db8:	ff 81       	ldd	r31, Y+7	; 0x07
    1dba:	91 83       	std	Z+1, r25	; 0x01
    1dbc:	80 83       	st	Z, r24
    1dbe:	06 c0       	rjmp	.+12     	; 0x1dcc <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1dc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc2:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc4:	ee 81       	ldd	r30, Y+6	; 0x06
    1dc6:	ff 81       	ldd	r31, Y+7	; 0x07
    1dc8:	91 83       	std	Z+1, r25	; 0x01
    1dca:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1dcc:	ee 81       	ldd	r30, Y+6	; 0x06
    1dce:	ff 81       	ldd	r31, Y+7	; 0x07
    1dd0:	89 81       	ldd	r24, Y+1	; 0x01
    1dd2:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1dd4:	ee 81       	ldd	r30, Y+6	; 0x06
    1dd6:	ff 81       	ldd	r31, Y+7	; 0x07
    1dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    1dda:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1ddc:	8e 81       	ldd	r24, Y+6	; 0x06
    1dde:	9f 81       	ldd	r25, Y+7	; 0x07
    1de0:	61 e0       	ldi	r22, 0x01	; 1
    1de2:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1de6:	27 96       	adiw	r28, 0x07	; 7
    1de8:	0f b6       	in	r0, 0x3f	; 63
    1dea:	f8 94       	cli
    1dec:	de bf       	out	0x3e, r29	; 62
    1dee:	0f be       	out	0x3f, r0	; 63
    1df0:	cd bf       	out	0x3d, r28	; 61
    1df2:	cf 91       	pop	r28
    1df4:	df 91       	pop	r29
    1df6:	1f 91       	pop	r17
    1df8:	0f 91       	pop	r16
    1dfa:	08 95       	ret

00001dfc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1dfc:	df 93       	push	r29
    1dfe:	cf 93       	push	r28
    1e00:	cd b7       	in	r28, 0x3d	; 61
    1e02:	de b7       	in	r29, 0x3e	; 62
    1e04:	2f 97       	sbiw	r28, 0x0f	; 15
    1e06:	0f b6       	in	r0, 0x3f	; 63
    1e08:	f8 94       	cli
    1e0a:	de bf       	out	0x3e, r29	; 62
    1e0c:	0f be       	out	0x3f, r0	; 63
    1e0e:	cd bf       	out	0x3d, r28	; 61
    1e10:	99 87       	std	Y+9, r25	; 0x09
    1e12:	88 87       	std	Y+8, r24	; 0x08
    1e14:	7b 87       	std	Y+11, r23	; 0x0b
    1e16:	6a 87       	std	Y+10, r22	; 0x0a
    1e18:	5d 87       	std	Y+13, r21	; 0x0d
    1e1a:	4c 87       	std	Y+12, r20	; 0x0c
    1e1c:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1e1e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1e20:	88 85       	ldd	r24, Y+8	; 0x08
    1e22:	99 85       	ldd	r25, Y+9	; 0x09
    1e24:	9a 83       	std	Y+2, r25	; 0x02
    1e26:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1e28:	0f b6       	in	r0, 0x3f	; 63
    1e2a:	f8 94       	cli
    1e2c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e30:	fa 81       	ldd	r31, Y+2	; 0x02
    1e32:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e34:	e9 81       	ldd	r30, Y+1	; 0x01
    1e36:	fa 81       	ldd	r31, Y+2	; 0x02
    1e38:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e3a:	98 17       	cp	r25, r24
    1e3c:	18 f0       	brcs	.+6      	; 0x1e44 <xQueueGenericSend+0x48>
    1e3e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e40:	82 30       	cpi	r24, 0x02	; 2
    1e42:	11 f5       	brne	.+68     	; 0x1e88 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e44:	89 81       	ldd	r24, Y+1	; 0x01
    1e46:	9a 81       	ldd	r25, Y+2	; 0x02
    1e48:	2a 85       	ldd	r18, Y+10	; 0x0a
    1e4a:	3b 85       	ldd	r19, Y+11	; 0x0b
    1e4c:	b9 01       	movw	r22, r18
    1e4e:	4e 85       	ldd	r20, Y+14	; 0x0e
    1e50:	0e 94 50 13 	call	0x26a0	; 0x26a0 <prvCopyDataToQueue>
    1e54:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e56:	e9 81       	ldd	r30, Y+1	; 0x01
    1e58:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5a:	81 89       	ldd	r24, Z+17	; 0x11
    1e5c:	88 23       	and	r24, r24
    1e5e:	51 f0       	breq	.+20     	; 0x1e74 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e60:	89 81       	ldd	r24, Y+1	; 0x01
    1e62:	9a 81       	ldd	r25, Y+2	; 0x02
    1e64:	41 96       	adiw	r24, 0x11	; 17
    1e66:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    1e6a:	88 23       	and	r24, r24
    1e6c:	41 f0       	breq	.+16     	; 0x1e7e <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1e6e:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
    1e72:	05 c0       	rjmp	.+10     	; 0x1e7e <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1e74:	8b 81       	ldd	r24, Y+3	; 0x03
    1e76:	88 23       	and	r24, r24
    1e78:	11 f0       	breq	.+4      	; 0x1e7e <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1e7a:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1e7e:	0f 90       	pop	r0
    1e80:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1e82:	81 e0       	ldi	r24, 0x01	; 1
    1e84:	8f 87       	std	Y+15, r24	; 0x0f
    1e86:	5c c0       	rjmp	.+184    	; 0x1f40 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e88:	8c 85       	ldd	r24, Y+12	; 0x0c
    1e8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    1e8c:	00 97       	sbiw	r24, 0x00	; 0
    1e8e:	21 f4       	brne	.+8      	; 0x1e98 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e90:	0f 90       	pop	r0
    1e92:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1e94:	1f 86       	std	Y+15, r1	; 0x0f
    1e96:	54 c0       	rjmp	.+168    	; 0x1f40 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e98:	8c 81       	ldd	r24, Y+4	; 0x04
    1e9a:	88 23       	and	r24, r24
    1e9c:	31 f4       	brne	.+12     	; 0x1eaa <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1e9e:	ce 01       	movw	r24, r28
    1ea0:	05 96       	adiw	r24, 0x05	; 5
    1ea2:	0e 94 13 24 	call	0x4826	; 0x4826 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1ea6:	81 e0       	ldi	r24, 0x01	; 1
    1ea8:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1eaa:	0f 90       	pop	r0
    1eac:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1eae:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1eb2:	0f b6       	in	r0, 0x3f	; 63
    1eb4:	f8 94       	cli
    1eb6:	0f 92       	push	r0
    1eb8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eba:	fa 81       	ldd	r31, Y+2	; 0x02
    1ebc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ebe:	8f 3f       	cpi	r24, 0xFF	; 255
    1ec0:	19 f4       	brne	.+6      	; 0x1ec8 <xQueueGenericSend+0xcc>
    1ec2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec6:	15 8e       	std	Z+29, r1	; 0x1d
    1ec8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eca:	fa 81       	ldd	r31, Y+2	; 0x02
    1ecc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ece:	8f 3f       	cpi	r24, 0xFF	; 255
    1ed0:	19 f4       	brne	.+6      	; 0x1ed8 <xQueueGenericSend+0xdc>
    1ed2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed6:	16 8e       	std	Z+30, r1	; 0x1e
    1ed8:	0f 90       	pop	r0
    1eda:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1edc:	ce 01       	movw	r24, r28
    1ede:	05 96       	adiw	r24, 0x05	; 5
    1ee0:	9e 01       	movw	r18, r28
    1ee2:	24 5f       	subi	r18, 0xF4	; 244
    1ee4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ee6:	b9 01       	movw	r22, r18
    1ee8:	0e 94 2c 24 	call	0x4858	; 0x4858 <xTaskCheckForTimeOut>
    1eec:	88 23       	and	r24, r24
    1eee:	09 f5       	brne	.+66     	; 0x1f32 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ef0:	89 81       	ldd	r24, Y+1	; 0x01
    1ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef4:	0e 94 cc 14 	call	0x2998	; 0x2998 <prvIsQueueFull>
    1ef8:	88 23       	and	r24, r24
    1efa:	a1 f0       	breq	.+40     	; 0x1f24 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1efc:	89 81       	ldd	r24, Y+1	; 0x01
    1efe:	9a 81       	ldd	r25, Y+2	; 0x02
    1f00:	08 96       	adiw	r24, 0x08	; 8
    1f02:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f04:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f06:	b9 01       	movw	r22, r18
    1f08:	0e 94 db 22 	call	0x45b6	; 0x45b6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1f0c:	89 81       	ldd	r24, Y+1	; 0x01
    1f0e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f10:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1f14:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    1f18:	88 23       	and	r24, r24
    1f1a:	09 f0       	breq	.+2      	; 0x1f1e <xQueueGenericSend+0x122>
    1f1c:	85 cf       	rjmp	.-246    	; 0x1e28 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1f1e:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
    1f22:	82 cf       	rjmp	.-252    	; 0x1e28 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f24:	89 81       	ldd	r24, Y+1	; 0x01
    1f26:	9a 81       	ldd	r25, Y+2	; 0x02
    1f28:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f2c:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    1f30:	7b cf       	rjmp	.-266    	; 0x1e28 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1f32:	89 81       	ldd	r24, Y+1	; 0x01
    1f34:	9a 81       	ldd	r25, Y+2	; 0x02
    1f36:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f3a:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1f3e:	1f 86       	std	Y+15, r1	; 0x0f
    1f40:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1f42:	2f 96       	adiw	r28, 0x0f	; 15
    1f44:	0f b6       	in	r0, 0x3f	; 63
    1f46:	f8 94       	cli
    1f48:	de bf       	out	0x3e, r29	; 62
    1f4a:	0f be       	out	0x3f, r0	; 63
    1f4c:	cd bf       	out	0x3d, r28	; 61
    1f4e:	cf 91       	pop	r28
    1f50:	df 91       	pop	r29
    1f52:	08 95       	ret

00001f54 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1f54:	df 93       	push	r29
    1f56:	cf 93       	push	r28
    1f58:	cd b7       	in	r28, 0x3d	; 61
    1f5a:	de b7       	in	r29, 0x3e	; 62
    1f5c:	2c 97       	sbiw	r28, 0x0c	; 12
    1f5e:	0f b6       	in	r0, 0x3f	; 63
    1f60:	f8 94       	cli
    1f62:	de bf       	out	0x3e, r29	; 62
    1f64:	0f be       	out	0x3f, r0	; 63
    1f66:	cd bf       	out	0x3d, r28	; 61
    1f68:	9f 83       	std	Y+7, r25	; 0x07
    1f6a:	8e 83       	std	Y+6, r24	; 0x06
    1f6c:	79 87       	std	Y+9, r23	; 0x09
    1f6e:	68 87       	std	Y+8, r22	; 0x08
    1f70:	5b 87       	std	Y+11, r21	; 0x0b
    1f72:	4a 87       	std	Y+10, r20	; 0x0a
    1f74:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1f76:	8e 81       	ldd	r24, Y+6	; 0x06
    1f78:	9f 81       	ldd	r25, Y+7	; 0x07
    1f7a:	9b 83       	std	Y+3, r25	; 0x03
    1f7c:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f7e:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1f80:	ea 81       	ldd	r30, Y+2	; 0x02
    1f82:	fb 81       	ldd	r31, Y+3	; 0x03
    1f84:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f86:	ea 81       	ldd	r30, Y+2	; 0x02
    1f88:	fb 81       	ldd	r31, Y+3	; 0x03
    1f8a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f8c:	98 17       	cp	r25, r24
    1f8e:	18 f0       	brcs	.+6      	; 0x1f96 <xQueueGenericSendFromISR+0x42>
    1f90:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f92:	82 30       	cpi	r24, 0x02	; 2
    1f94:	61 f5       	brne	.+88     	; 0x1fee <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1f96:	ea 81       	ldd	r30, Y+2	; 0x02
    1f98:	fb 81       	ldd	r31, Y+3	; 0x03
    1f9a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f9c:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1f9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa0:	9b 81       	ldd	r25, Y+3	; 0x03
    1fa2:	28 85       	ldd	r18, Y+8	; 0x08
    1fa4:	39 85       	ldd	r19, Y+9	; 0x09
    1fa6:	b9 01       	movw	r22, r18
    1fa8:	4c 85       	ldd	r20, Y+12	; 0x0c
    1faa:	0e 94 50 13 	call	0x26a0	; 0x26a0 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1fae:	89 81       	ldd	r24, Y+1	; 0x01
    1fb0:	8f 3f       	cpi	r24, 0xFF	; 255
    1fb2:	a9 f4       	brne	.+42     	; 0x1fde <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1fb4:	ea 81       	ldd	r30, Y+2	; 0x02
    1fb6:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb8:	81 89       	ldd	r24, Z+17	; 0x11
    1fba:	88 23       	and	r24, r24
    1fbc:	a9 f0       	breq	.+42     	; 0x1fe8 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc0:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc2:	41 96       	adiw	r24, 0x11	; 17
    1fc4:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    1fc8:	88 23       	and	r24, r24
    1fca:	71 f0       	breq	.+28     	; 0x1fe8 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1fcc:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fce:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fd0:	00 97       	sbiw	r24, 0x00	; 0
    1fd2:	51 f0       	breq	.+20     	; 0x1fe8 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1fd4:	ea 85       	ldd	r30, Y+10	; 0x0a
    1fd6:	fb 85       	ldd	r31, Y+11	; 0x0b
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	80 83       	st	Z, r24
    1fdc:	05 c0       	rjmp	.+10     	; 0x1fe8 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1fde:	89 81       	ldd	r24, Y+1	; 0x01
    1fe0:	8f 5f       	subi	r24, 0xFF	; 255
    1fe2:	ea 81       	ldd	r30, Y+2	; 0x02
    1fe4:	fb 81       	ldd	r31, Y+3	; 0x03
    1fe6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	8d 83       	std	Y+5, r24	; 0x05
    1fec:	01 c0       	rjmp	.+2      	; 0x1ff0 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1fee:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1ff0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1ff2:	2c 96       	adiw	r28, 0x0c	; 12
    1ff4:	0f b6       	in	r0, 0x3f	; 63
    1ff6:	f8 94       	cli
    1ff8:	de bf       	out	0x3e, r29	; 62
    1ffa:	0f be       	out	0x3f, r0	; 63
    1ffc:	cd bf       	out	0x3d, r28	; 61
    1ffe:	cf 91       	pop	r28
    2000:	df 91       	pop	r29
    2002:	08 95       	ret

00002004 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2004:	df 93       	push	r29
    2006:	cf 93       	push	r28
    2008:	cd b7       	in	r28, 0x3d	; 61
    200a:	de b7       	in	r29, 0x3e	; 62
    200c:	2a 97       	sbiw	r28, 0x0a	; 10
    200e:	0f b6       	in	r0, 0x3f	; 63
    2010:	f8 94       	cli
    2012:	de bf       	out	0x3e, r29	; 62
    2014:	0f be       	out	0x3f, r0	; 63
    2016:	cd bf       	out	0x3d, r28	; 61
    2018:	98 87       	std	Y+8, r25	; 0x08
    201a:	8f 83       	std	Y+7, r24	; 0x07
    201c:	7a 87       	std	Y+10, r23	; 0x0a
    201e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2020:	8f 81       	ldd	r24, Y+7	; 0x07
    2022:	98 85       	ldd	r25, Y+8	; 0x08
    2024:	9c 83       	std	Y+4, r25	; 0x04
    2026:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2028:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    202a:	eb 81       	ldd	r30, Y+3	; 0x03
    202c:	fc 81       	ldd	r31, Y+4	; 0x04
    202e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2030:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    2032:	eb 81       	ldd	r30, Y+3	; 0x03
    2034:	fc 81       	ldd	r31, Y+4	; 0x04
    2036:	93 8d       	ldd	r25, Z+27	; 0x1b
    2038:	8a 81       	ldd	r24, Y+2	; 0x02
    203a:	89 17       	cp	r24, r25
    203c:	48 f5       	brcc	.+82     	; 0x2090 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    203e:	eb 81       	ldd	r30, Y+3	; 0x03
    2040:	fc 81       	ldd	r31, Y+4	; 0x04
    2042:	86 8d       	ldd	r24, Z+30	; 0x1e
    2044:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2046:	8a 81       	ldd	r24, Y+2	; 0x02
    2048:	8f 5f       	subi	r24, 0xFF	; 255
    204a:	eb 81       	ldd	r30, Y+3	; 0x03
    204c:	fc 81       	ldd	r31, Y+4	; 0x04
    204e:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2050:	89 81       	ldd	r24, Y+1	; 0x01
    2052:	8f 3f       	cpi	r24, 0xFF	; 255
    2054:	a9 f4       	brne	.+42     	; 0x2080 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2056:	eb 81       	ldd	r30, Y+3	; 0x03
    2058:	fc 81       	ldd	r31, Y+4	; 0x04
    205a:	81 89       	ldd	r24, Z+17	; 0x11
    205c:	88 23       	and	r24, r24
    205e:	a9 f0       	breq	.+42     	; 0x208a <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2060:	8b 81       	ldd	r24, Y+3	; 0x03
    2062:	9c 81       	ldd	r25, Y+4	; 0x04
    2064:	41 96       	adiw	r24, 0x11	; 17
    2066:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    206a:	88 23       	and	r24, r24
    206c:	71 f0       	breq	.+28     	; 0x208a <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    206e:	89 85       	ldd	r24, Y+9	; 0x09
    2070:	9a 85       	ldd	r25, Y+10	; 0x0a
    2072:	00 97       	sbiw	r24, 0x00	; 0
    2074:	51 f0       	breq	.+20     	; 0x208a <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2076:	e9 85       	ldd	r30, Y+9	; 0x09
    2078:	fa 85       	ldd	r31, Y+10	; 0x0a
    207a:	81 e0       	ldi	r24, 0x01	; 1
    207c:	80 83       	st	Z, r24
    207e:	05 c0       	rjmp	.+10     	; 0x208a <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2080:	89 81       	ldd	r24, Y+1	; 0x01
    2082:	8f 5f       	subi	r24, 0xFF	; 255
    2084:	eb 81       	ldd	r30, Y+3	; 0x03
    2086:	fc 81       	ldd	r31, Y+4	; 0x04
    2088:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    208a:	81 e0       	ldi	r24, 0x01	; 1
    208c:	8e 83       	std	Y+6, r24	; 0x06
    208e:	01 c0       	rjmp	.+2      	; 0x2092 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2090:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2092:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2094:	2a 96       	adiw	r28, 0x0a	; 10
    2096:	0f b6       	in	r0, 0x3f	; 63
    2098:	f8 94       	cli
    209a:	de bf       	out	0x3e, r29	; 62
    209c:	0f be       	out	0x3f, r0	; 63
    209e:	cd bf       	out	0x3d, r28	; 61
    20a0:	cf 91       	pop	r28
    20a2:	df 91       	pop	r29
    20a4:	08 95       	ret

000020a6 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    20a6:	df 93       	push	r29
    20a8:	cf 93       	push	r28
    20aa:	cd b7       	in	r28, 0x3d	; 61
    20ac:	de b7       	in	r29, 0x3e	; 62
    20ae:	2e 97       	sbiw	r28, 0x0e	; 14
    20b0:	0f b6       	in	r0, 0x3f	; 63
    20b2:	f8 94       	cli
    20b4:	de bf       	out	0x3e, r29	; 62
    20b6:	0f be       	out	0x3f, r0	; 63
    20b8:	cd bf       	out	0x3d, r28	; 61
    20ba:	99 87       	std	Y+9, r25	; 0x09
    20bc:	88 87       	std	Y+8, r24	; 0x08
    20be:	7b 87       	std	Y+11, r23	; 0x0b
    20c0:	6a 87       	std	Y+10, r22	; 0x0a
    20c2:	5d 87       	std	Y+13, r21	; 0x0d
    20c4:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    20c6:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    20c8:	88 85       	ldd	r24, Y+8	; 0x08
    20ca:	99 85       	ldd	r25, Y+9	; 0x09
    20cc:	9b 83       	std	Y+3, r25	; 0x03
    20ce:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    20d0:	0f b6       	in	r0, 0x3f	; 63
    20d2:	f8 94       	cli
    20d4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    20d6:	ea 81       	ldd	r30, Y+2	; 0x02
    20d8:	fb 81       	ldd	r31, Y+3	; 0x03
    20da:	82 8d       	ldd	r24, Z+26	; 0x1a
    20dc:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    20de:	89 81       	ldd	r24, Y+1	; 0x01
    20e0:	88 23       	and	r24, r24
    20e2:	f9 f0       	breq	.+62     	; 0x2122 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    20e4:	8a 81       	ldd	r24, Y+2	; 0x02
    20e6:	9b 81       	ldd	r25, Y+3	; 0x03
    20e8:	2a 85       	ldd	r18, Y+10	; 0x0a
    20ea:	3b 85       	ldd	r19, Y+11	; 0x0b
    20ec:	b9 01       	movw	r22, r18
    20ee:	0e 94 f6 13 	call	0x27ec	; 0x27ec <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    20f2:	89 81       	ldd	r24, Y+1	; 0x01
    20f4:	81 50       	subi	r24, 0x01	; 1
    20f6:	ea 81       	ldd	r30, Y+2	; 0x02
    20f8:	fb 81       	ldd	r31, Y+3	; 0x03
    20fa:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20fc:	ea 81       	ldd	r30, Y+2	; 0x02
    20fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2100:	80 85       	ldd	r24, Z+8	; 0x08
    2102:	88 23       	and	r24, r24
    2104:	49 f0       	breq	.+18     	; 0x2118 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2106:	8a 81       	ldd	r24, Y+2	; 0x02
    2108:	9b 81       	ldd	r25, Y+3	; 0x03
    210a:	08 96       	adiw	r24, 0x08	; 8
    210c:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    2110:	88 23       	and	r24, r24
    2112:	11 f0       	breq	.+4      	; 0x2118 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2114:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2118:	0f 90       	pop	r0
    211a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    211c:	81 e0       	ldi	r24, 0x01	; 1
    211e:	8e 87       	std	Y+14, r24	; 0x0e
    2120:	63 c0       	rjmp	.+198    	; 0x21e8 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2122:	8c 85       	ldd	r24, Y+12	; 0x0c
    2124:	9d 85       	ldd	r25, Y+13	; 0x0d
    2126:	00 97       	sbiw	r24, 0x00	; 0
    2128:	21 f4       	brne	.+8      	; 0x2132 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    212a:	0f 90       	pop	r0
    212c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    212e:	1e 86       	std	Y+14, r1	; 0x0e
    2130:	5b c0       	rjmp	.+182    	; 0x21e8 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    2132:	8c 81       	ldd	r24, Y+4	; 0x04
    2134:	88 23       	and	r24, r24
    2136:	31 f4       	brne	.+12     	; 0x2144 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2138:	ce 01       	movw	r24, r28
    213a:	05 96       	adiw	r24, 0x05	; 5
    213c:	0e 94 13 24 	call	0x4826	; 0x4826 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2144:	0f 90       	pop	r0
    2146:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2148:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    214c:	0f b6       	in	r0, 0x3f	; 63
    214e:	f8 94       	cli
    2150:	0f 92       	push	r0
    2152:	ea 81       	ldd	r30, Y+2	; 0x02
    2154:	fb 81       	ldd	r31, Y+3	; 0x03
    2156:	85 8d       	ldd	r24, Z+29	; 0x1d
    2158:	8f 3f       	cpi	r24, 0xFF	; 255
    215a:	19 f4       	brne	.+6      	; 0x2162 <xQueueReceive+0xbc>
    215c:	ea 81       	ldd	r30, Y+2	; 0x02
    215e:	fb 81       	ldd	r31, Y+3	; 0x03
    2160:	15 8e       	std	Z+29, r1	; 0x1d
    2162:	ea 81       	ldd	r30, Y+2	; 0x02
    2164:	fb 81       	ldd	r31, Y+3	; 0x03
    2166:	86 8d       	ldd	r24, Z+30	; 0x1e
    2168:	8f 3f       	cpi	r24, 0xFF	; 255
    216a:	19 f4       	brne	.+6      	; 0x2172 <xQueueReceive+0xcc>
    216c:	ea 81       	ldd	r30, Y+2	; 0x02
    216e:	fb 81       	ldd	r31, Y+3	; 0x03
    2170:	16 8e       	std	Z+30, r1	; 0x1e
    2172:	0f 90       	pop	r0
    2174:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2176:	ce 01       	movw	r24, r28
    2178:	05 96       	adiw	r24, 0x05	; 5
    217a:	9e 01       	movw	r18, r28
    217c:	24 5f       	subi	r18, 0xF4	; 244
    217e:	3f 4f       	sbci	r19, 0xFF	; 255
    2180:	b9 01       	movw	r22, r18
    2182:	0e 94 2c 24 	call	0x4858	; 0x4858 <xTaskCheckForTimeOut>
    2186:	88 23       	and	r24, r24
    2188:	09 f5       	brne	.+66     	; 0x21cc <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    218a:	8a 81       	ldd	r24, Y+2	; 0x02
    218c:	9b 81       	ldd	r25, Y+3	; 0x03
    218e:	0e 94 90 14 	call	0x2920	; 0x2920 <prvIsQueueEmpty>
    2192:	88 23       	and	r24, r24
    2194:	a1 f0       	breq	.+40     	; 0x21be <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2196:	8a 81       	ldd	r24, Y+2	; 0x02
    2198:	9b 81       	ldd	r25, Y+3	; 0x03
    219a:	41 96       	adiw	r24, 0x11	; 17
    219c:	2c 85       	ldd	r18, Y+12	; 0x0c
    219e:	3d 85       	ldd	r19, Y+13	; 0x0d
    21a0:	b9 01       	movw	r22, r18
    21a2:	0e 94 db 22 	call	0x45b6	; 0x45b6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    21a6:	8a 81       	ldd	r24, Y+2	; 0x02
    21a8:	9b 81       	ldd	r25, Y+3	; 0x03
    21aa:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    21ae:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    21b2:	88 23       	and	r24, r24
    21b4:	09 f0       	breq	.+2      	; 0x21b8 <xQueueReceive+0x112>
    21b6:	8c cf       	rjmp	.-232    	; 0x20d0 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    21b8:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
    21bc:	89 cf       	rjmp	.-238    	; 0x20d0 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    21be:	8a 81       	ldd	r24, Y+2	; 0x02
    21c0:	9b 81       	ldd	r25, Y+3	; 0x03
    21c2:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    21c6:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    21ca:	82 cf       	rjmp	.-252    	; 0x20d0 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    21cc:	8a 81       	ldd	r24, Y+2	; 0x02
    21ce:	9b 81       	ldd	r25, Y+3	; 0x03
    21d0:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    21d4:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    21d8:	8a 81       	ldd	r24, Y+2	; 0x02
    21da:	9b 81       	ldd	r25, Y+3	; 0x03
    21dc:	0e 94 90 14 	call	0x2920	; 0x2920 <prvIsQueueEmpty>
    21e0:	88 23       	and	r24, r24
    21e2:	09 f4       	brne	.+2      	; 0x21e6 <xQueueReceive+0x140>
    21e4:	75 cf       	rjmp	.-278    	; 0x20d0 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    21e6:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    21e8:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    21ea:	2e 96       	adiw	r28, 0x0e	; 14
    21ec:	0f b6       	in	r0, 0x3f	; 63
    21ee:	f8 94       	cli
    21f0:	de bf       	out	0x3e, r29	; 62
    21f2:	0f be       	out	0x3f, r0	; 63
    21f4:	cd bf       	out	0x3d, r28	; 61
    21f6:	cf 91       	pop	r28
    21f8:	df 91       	pop	r29
    21fa:	08 95       	ret

000021fc <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    21fc:	df 93       	push	r29
    21fe:	cf 93       	push	r28
    2200:	cd b7       	in	r28, 0x3d	; 61
    2202:	de b7       	in	r29, 0x3e	; 62
    2204:	2c 97       	sbiw	r28, 0x0c	; 12
    2206:	0f b6       	in	r0, 0x3f	; 63
    2208:	f8 94       	cli
    220a:	de bf       	out	0x3e, r29	; 62
    220c:	0f be       	out	0x3f, r0	; 63
    220e:	cd bf       	out	0x3d, r28	; 61
    2210:	99 87       	std	Y+9, r25	; 0x09
    2212:	88 87       	std	Y+8, r24	; 0x08
    2214:	7b 87       	std	Y+11, r23	; 0x0b
    2216:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    2218:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    221a:	88 85       	ldd	r24, Y+8	; 0x08
    221c:	99 85       	ldd	r25, Y+9	; 0x09
    221e:	9b 83       	std	Y+3, r25	; 0x03
    2220:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2222:	0f b6       	in	r0, 0x3f	; 63
    2224:	f8 94       	cli
    2226:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2228:	ea 81       	ldd	r30, Y+2	; 0x02
    222a:	fb 81       	ldd	r31, Y+3	; 0x03
    222c:	82 8d       	ldd	r24, Z+26	; 0x1a
    222e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2230:	89 81       	ldd	r24, Y+1	; 0x01
    2232:	88 23       	and	r24, r24
    2234:	c1 f0       	breq	.+48     	; 0x2266 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2236:	89 81       	ldd	r24, Y+1	; 0x01
    2238:	81 50       	subi	r24, 0x01	; 1
    223a:	ea 81       	ldd	r30, Y+2	; 0x02
    223c:	fb 81       	ldd	r31, Y+3	; 0x03
    223e:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2240:	ea 81       	ldd	r30, Y+2	; 0x02
    2242:	fb 81       	ldd	r31, Y+3	; 0x03
    2244:	80 85       	ldd	r24, Z+8	; 0x08
    2246:	88 23       	and	r24, r24
    2248:	49 f0       	breq	.+18     	; 0x225c <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    224a:	8a 81       	ldd	r24, Y+2	; 0x02
    224c:	9b 81       	ldd	r25, Y+3	; 0x03
    224e:	08 96       	adiw	r24, 0x08	; 8
    2250:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    2254:	88 23       	and	r24, r24
    2256:	11 f0       	breq	.+4      	; 0x225c <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2258:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    225c:	0f 90       	pop	r0
    225e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2260:	81 e0       	ldi	r24, 0x01	; 1
    2262:	8c 87       	std	Y+12, r24	; 0x0c
    2264:	63 c0       	rjmp	.+198    	; 0x232c <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2266:	8a 85       	ldd	r24, Y+10	; 0x0a
    2268:	9b 85       	ldd	r25, Y+11	; 0x0b
    226a:	00 97       	sbiw	r24, 0x00	; 0
    226c:	21 f4       	brne	.+8      	; 0x2276 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    226e:	0f 90       	pop	r0
    2270:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2272:	1c 86       	std	Y+12, r1	; 0x0c
    2274:	5b c0       	rjmp	.+182    	; 0x232c <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    2276:	8c 81       	ldd	r24, Y+4	; 0x04
    2278:	88 23       	and	r24, r24
    227a:	31 f4       	brne	.+12     	; 0x2288 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    227c:	ce 01       	movw	r24, r28
    227e:	05 96       	adiw	r24, 0x05	; 5
    2280:	0e 94 13 24 	call	0x4826	; 0x4826 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2284:	81 e0       	ldi	r24, 0x01	; 1
    2286:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2288:	0f 90       	pop	r0
    228a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    228c:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2290:	0f b6       	in	r0, 0x3f	; 63
    2292:	f8 94       	cli
    2294:	0f 92       	push	r0
    2296:	ea 81       	ldd	r30, Y+2	; 0x02
    2298:	fb 81       	ldd	r31, Y+3	; 0x03
    229a:	85 8d       	ldd	r24, Z+29	; 0x1d
    229c:	8f 3f       	cpi	r24, 0xFF	; 255
    229e:	19 f4       	brne	.+6      	; 0x22a6 <xQueueSemaphoreTake+0xaa>
    22a0:	ea 81       	ldd	r30, Y+2	; 0x02
    22a2:	fb 81       	ldd	r31, Y+3	; 0x03
    22a4:	15 8e       	std	Z+29, r1	; 0x1d
    22a6:	ea 81       	ldd	r30, Y+2	; 0x02
    22a8:	fb 81       	ldd	r31, Y+3	; 0x03
    22aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    22ac:	8f 3f       	cpi	r24, 0xFF	; 255
    22ae:	19 f4       	brne	.+6      	; 0x22b6 <xQueueSemaphoreTake+0xba>
    22b0:	ea 81       	ldd	r30, Y+2	; 0x02
    22b2:	fb 81       	ldd	r31, Y+3	; 0x03
    22b4:	16 8e       	std	Z+30, r1	; 0x1e
    22b6:	0f 90       	pop	r0
    22b8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    22ba:	ce 01       	movw	r24, r28
    22bc:	05 96       	adiw	r24, 0x05	; 5
    22be:	9e 01       	movw	r18, r28
    22c0:	26 5f       	subi	r18, 0xF6	; 246
    22c2:	3f 4f       	sbci	r19, 0xFF	; 255
    22c4:	b9 01       	movw	r22, r18
    22c6:	0e 94 2c 24 	call	0x4858	; 0x4858 <xTaskCheckForTimeOut>
    22ca:	88 23       	and	r24, r24
    22cc:	09 f5       	brne	.+66     	; 0x2310 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22ce:	8a 81       	ldd	r24, Y+2	; 0x02
    22d0:	9b 81       	ldd	r25, Y+3	; 0x03
    22d2:	0e 94 90 14 	call	0x2920	; 0x2920 <prvIsQueueEmpty>
    22d6:	88 23       	and	r24, r24
    22d8:	a1 f0       	breq	.+40     	; 0x2302 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    22da:	8a 81       	ldd	r24, Y+2	; 0x02
    22dc:	9b 81       	ldd	r25, Y+3	; 0x03
    22de:	41 96       	adiw	r24, 0x11	; 17
    22e0:	2a 85       	ldd	r18, Y+10	; 0x0a
    22e2:	3b 85       	ldd	r19, Y+11	; 0x0b
    22e4:	b9 01       	movw	r22, r18
    22e6:	0e 94 db 22 	call	0x45b6	; 0x45b6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    22ea:	8a 81       	ldd	r24, Y+2	; 0x02
    22ec:	9b 81       	ldd	r25, Y+3	; 0x03
    22ee:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    22f2:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    22f6:	88 23       	and	r24, r24
    22f8:	09 f0       	breq	.+2      	; 0x22fc <xQueueSemaphoreTake+0x100>
    22fa:	93 cf       	rjmp	.-218    	; 0x2222 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    22fc:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
    2300:	90 cf       	rjmp	.-224    	; 0x2222 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2302:	8a 81       	ldd	r24, Y+2	; 0x02
    2304:	9b 81       	ldd	r25, Y+3	; 0x03
    2306:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    230a:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    230e:	89 cf       	rjmp	.-238    	; 0x2222 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2310:	8a 81       	ldd	r24, Y+2	; 0x02
    2312:	9b 81       	ldd	r25, Y+3	; 0x03
    2314:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2318:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    231c:	8a 81       	ldd	r24, Y+2	; 0x02
    231e:	9b 81       	ldd	r25, Y+3	; 0x03
    2320:	0e 94 90 14 	call	0x2920	; 0x2920 <prvIsQueueEmpty>
    2324:	88 23       	and	r24, r24
    2326:	09 f4       	brne	.+2      	; 0x232a <xQueueSemaphoreTake+0x12e>
    2328:	7c cf       	rjmp	.-264    	; 0x2222 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    232a:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    232c:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    232e:	2c 96       	adiw	r28, 0x0c	; 12
    2330:	0f b6       	in	r0, 0x3f	; 63
    2332:	f8 94       	cli
    2334:	de bf       	out	0x3e, r29	; 62
    2336:	0f be       	out	0x3f, r0	; 63
    2338:	cd bf       	out	0x3d, r28	; 61
    233a:	cf 91       	pop	r28
    233c:	df 91       	pop	r29
    233e:	08 95       	ret

00002340 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2340:	df 93       	push	r29
    2342:	cf 93       	push	r28
    2344:	cd b7       	in	r28, 0x3d	; 61
    2346:	de b7       	in	r29, 0x3e	; 62
    2348:	60 97       	sbiw	r28, 0x10	; 16
    234a:	0f b6       	in	r0, 0x3f	; 63
    234c:	f8 94       	cli
    234e:	de bf       	out	0x3e, r29	; 62
    2350:	0f be       	out	0x3f, r0	; 63
    2352:	cd bf       	out	0x3d, r28	; 61
    2354:	9b 87       	std	Y+11, r25	; 0x0b
    2356:	8a 87       	std	Y+10, r24	; 0x0a
    2358:	7d 87       	std	Y+13, r23	; 0x0d
    235a:	6c 87       	std	Y+12, r22	; 0x0c
    235c:	5f 87       	std	Y+15, r21	; 0x0f
    235e:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    2360:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2362:	8a 85       	ldd	r24, Y+10	; 0x0a
    2364:	9b 85       	ldd	r25, Y+11	; 0x0b
    2366:	9b 83       	std	Y+3, r25	; 0x03
    2368:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    236a:	0f b6       	in	r0, 0x3f	; 63
    236c:	f8 94       	cli
    236e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2370:	ea 81       	ldd	r30, Y+2	; 0x02
    2372:	fb 81       	ldd	r31, Y+3	; 0x03
    2374:	82 8d       	ldd	r24, Z+26	; 0x1a
    2376:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2378:	89 81       	ldd	r24, Y+1	; 0x01
    237a:	88 23       	and	r24, r24
    237c:	31 f1       	breq	.+76     	; 0x23ca <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    237e:	ea 81       	ldd	r30, Y+2	; 0x02
    2380:	fb 81       	ldd	r31, Y+3	; 0x03
    2382:	86 81       	ldd	r24, Z+6	; 0x06
    2384:	97 81       	ldd	r25, Z+7	; 0x07
    2386:	9d 83       	std	Y+5, r25	; 0x05
    2388:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    238a:	8a 81       	ldd	r24, Y+2	; 0x02
    238c:	9b 81       	ldd	r25, Y+3	; 0x03
    238e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2390:	3d 85       	ldd	r19, Y+13	; 0x0d
    2392:	b9 01       	movw	r22, r18
    2394:	0e 94 f6 13 	call	0x27ec	; 0x27ec <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2398:	ea 81       	ldd	r30, Y+2	; 0x02
    239a:	fb 81       	ldd	r31, Y+3	; 0x03
    239c:	8c 81       	ldd	r24, Y+4	; 0x04
    239e:	9d 81       	ldd	r25, Y+5	; 0x05
    23a0:	97 83       	std	Z+7, r25	; 0x07
    23a2:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23a4:	ea 81       	ldd	r30, Y+2	; 0x02
    23a6:	fb 81       	ldd	r31, Y+3	; 0x03
    23a8:	81 89       	ldd	r24, Z+17	; 0x11
    23aa:	88 23       	and	r24, r24
    23ac:	49 f0       	breq	.+18     	; 0x23c0 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23ae:	8a 81       	ldd	r24, Y+2	; 0x02
    23b0:	9b 81       	ldd	r25, Y+3	; 0x03
    23b2:	41 96       	adiw	r24, 0x11	; 17
    23b4:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    23b8:	88 23       	and	r24, r24
    23ba:	11 f0       	breq	.+4      	; 0x23c0 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    23bc:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    23c0:	0f 90       	pop	r0
    23c2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    23c4:	81 e0       	ldi	r24, 0x01	; 1
    23c6:	88 8b       	std	Y+16, r24	; 0x10
    23c8:	63 c0       	rjmp	.+198    	; 0x2490 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    23ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    23cc:	9f 85       	ldd	r25, Y+15	; 0x0f
    23ce:	00 97       	sbiw	r24, 0x00	; 0
    23d0:	21 f4       	brne	.+8      	; 0x23da <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23d2:	0f 90       	pop	r0
    23d4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    23d6:	18 8a       	std	Y+16, r1	; 0x10
    23d8:	5b c0       	rjmp	.+182    	; 0x2490 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    23da:	8e 81       	ldd	r24, Y+6	; 0x06
    23dc:	88 23       	and	r24, r24
    23de:	31 f4       	brne	.+12     	; 0x23ec <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    23e0:	ce 01       	movw	r24, r28
    23e2:	07 96       	adiw	r24, 0x07	; 7
    23e4:	0e 94 13 24 	call	0x4826	; 0x4826 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    23e8:	81 e0       	ldi	r24, 0x01	; 1
    23ea:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    23ec:	0f 90       	pop	r0
    23ee:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23f0:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    23f4:	0f b6       	in	r0, 0x3f	; 63
    23f6:	f8 94       	cli
    23f8:	0f 92       	push	r0
    23fa:	ea 81       	ldd	r30, Y+2	; 0x02
    23fc:	fb 81       	ldd	r31, Y+3	; 0x03
    23fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2400:	8f 3f       	cpi	r24, 0xFF	; 255
    2402:	19 f4       	brne	.+6      	; 0x240a <xQueuePeek+0xca>
    2404:	ea 81       	ldd	r30, Y+2	; 0x02
    2406:	fb 81       	ldd	r31, Y+3	; 0x03
    2408:	15 8e       	std	Z+29, r1	; 0x1d
    240a:	ea 81       	ldd	r30, Y+2	; 0x02
    240c:	fb 81       	ldd	r31, Y+3	; 0x03
    240e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2410:	8f 3f       	cpi	r24, 0xFF	; 255
    2412:	19 f4       	brne	.+6      	; 0x241a <xQueuePeek+0xda>
    2414:	ea 81       	ldd	r30, Y+2	; 0x02
    2416:	fb 81       	ldd	r31, Y+3	; 0x03
    2418:	16 8e       	std	Z+30, r1	; 0x1e
    241a:	0f 90       	pop	r0
    241c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    241e:	ce 01       	movw	r24, r28
    2420:	07 96       	adiw	r24, 0x07	; 7
    2422:	9e 01       	movw	r18, r28
    2424:	22 5f       	subi	r18, 0xF2	; 242
    2426:	3f 4f       	sbci	r19, 0xFF	; 255
    2428:	b9 01       	movw	r22, r18
    242a:	0e 94 2c 24 	call	0x4858	; 0x4858 <xTaskCheckForTimeOut>
    242e:	88 23       	and	r24, r24
    2430:	09 f5       	brne	.+66     	; 0x2474 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2432:	8a 81       	ldd	r24, Y+2	; 0x02
    2434:	9b 81       	ldd	r25, Y+3	; 0x03
    2436:	0e 94 90 14 	call	0x2920	; 0x2920 <prvIsQueueEmpty>
    243a:	88 23       	and	r24, r24
    243c:	a1 f0       	breq	.+40     	; 0x2466 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    243e:	8a 81       	ldd	r24, Y+2	; 0x02
    2440:	9b 81       	ldd	r25, Y+3	; 0x03
    2442:	41 96       	adiw	r24, 0x11	; 17
    2444:	2e 85       	ldd	r18, Y+14	; 0x0e
    2446:	3f 85       	ldd	r19, Y+15	; 0x0f
    2448:	b9 01       	movw	r22, r18
    244a:	0e 94 db 22 	call	0x45b6	; 0x45b6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    244e:	8a 81       	ldd	r24, Y+2	; 0x02
    2450:	9b 81       	ldd	r25, Y+3	; 0x03
    2452:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2456:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    245a:	88 23       	and	r24, r24
    245c:	09 f0       	breq	.+2      	; 0x2460 <xQueuePeek+0x120>
    245e:	85 cf       	rjmp	.-246    	; 0x236a <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2460:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
    2464:	82 cf       	rjmp	.-252    	; 0x236a <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2466:	8a 81       	ldd	r24, Y+2	; 0x02
    2468:	9b 81       	ldd	r25, Y+3	; 0x03
    246a:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    246e:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    2472:	7b cf       	rjmp	.-266    	; 0x236a <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2474:	8a 81       	ldd	r24, Y+2	; 0x02
    2476:	9b 81       	ldd	r25, Y+3	; 0x03
    2478:	0e 94 3d 14 	call	0x287a	; 0x287a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    247c:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2480:	8a 81       	ldd	r24, Y+2	; 0x02
    2482:	9b 81       	ldd	r25, Y+3	; 0x03
    2484:	0e 94 90 14 	call	0x2920	; 0x2920 <prvIsQueueEmpty>
    2488:	88 23       	and	r24, r24
    248a:	09 f4       	brne	.+2      	; 0x248e <xQueuePeek+0x14e>
    248c:	6e cf       	rjmp	.-292    	; 0x236a <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    248e:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2490:	88 89       	ldd	r24, Y+16	; 0x10
}
    2492:	60 96       	adiw	r28, 0x10	; 16
    2494:	0f b6       	in	r0, 0x3f	; 63
    2496:	f8 94       	cli
    2498:	de bf       	out	0x3e, r29	; 62
    249a:	0f be       	out	0x3f, r0	; 63
    249c:	cd bf       	out	0x3d, r28	; 61
    249e:	cf 91       	pop	r28
    24a0:	df 91       	pop	r29
    24a2:	08 95       	ret

000024a4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    24a4:	df 93       	push	r29
    24a6:	cf 93       	push	r28
    24a8:	cd b7       	in	r28, 0x3d	; 61
    24aa:	de b7       	in	r29, 0x3e	; 62
    24ac:	2c 97       	sbiw	r28, 0x0c	; 12
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	de bf       	out	0x3e, r29	; 62
    24b4:	0f be       	out	0x3f, r0	; 63
    24b6:	cd bf       	out	0x3d, r28	; 61
    24b8:	98 87       	std	Y+8, r25	; 0x08
    24ba:	8f 83       	std	Y+7, r24	; 0x07
    24bc:	7a 87       	std	Y+10, r23	; 0x0a
    24be:	69 87       	std	Y+9, r22	; 0x09
    24c0:	5c 87       	std	Y+12, r21	; 0x0c
    24c2:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    24c4:	8f 81       	ldd	r24, Y+7	; 0x07
    24c6:	98 85       	ldd	r25, Y+8	; 0x08
    24c8:	9c 83       	std	Y+4, r25	; 0x04
    24ca:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    24cc:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    24ce:	eb 81       	ldd	r30, Y+3	; 0x03
    24d0:	fc 81       	ldd	r31, Y+4	; 0x04
    24d2:	82 8d       	ldd	r24, Z+26	; 0x1a
    24d4:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    24d6:	8a 81       	ldd	r24, Y+2	; 0x02
    24d8:	88 23       	and	r24, r24
    24da:	81 f1       	breq	.+96     	; 0x253c <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    24dc:	eb 81       	ldd	r30, Y+3	; 0x03
    24de:	fc 81       	ldd	r31, Y+4	; 0x04
    24e0:	85 8d       	ldd	r24, Z+29	; 0x1d
    24e2:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    24e4:	8b 81       	ldd	r24, Y+3	; 0x03
    24e6:	9c 81       	ldd	r25, Y+4	; 0x04
    24e8:	29 85       	ldd	r18, Y+9	; 0x09
    24ea:	3a 85       	ldd	r19, Y+10	; 0x0a
    24ec:	b9 01       	movw	r22, r18
    24ee:	0e 94 f6 13 	call	0x27ec	; 0x27ec <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    24f2:	8a 81       	ldd	r24, Y+2	; 0x02
    24f4:	81 50       	subi	r24, 0x01	; 1
    24f6:	eb 81       	ldd	r30, Y+3	; 0x03
    24f8:	fc 81       	ldd	r31, Y+4	; 0x04
    24fa:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    24fc:	89 81       	ldd	r24, Y+1	; 0x01
    24fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2500:	a9 f4       	brne	.+42     	; 0x252c <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2502:	eb 81       	ldd	r30, Y+3	; 0x03
    2504:	fc 81       	ldd	r31, Y+4	; 0x04
    2506:	80 85       	ldd	r24, Z+8	; 0x08
    2508:	88 23       	and	r24, r24
    250a:	a9 f0       	breq	.+42     	; 0x2536 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    250c:	8b 81       	ldd	r24, Y+3	; 0x03
    250e:	9c 81       	ldd	r25, Y+4	; 0x04
    2510:	08 96       	adiw	r24, 0x08	; 8
    2512:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    2516:	88 23       	and	r24, r24
    2518:	71 f0       	breq	.+28     	; 0x2536 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    251a:	8b 85       	ldd	r24, Y+11	; 0x0b
    251c:	9c 85       	ldd	r25, Y+12	; 0x0c
    251e:	00 97       	sbiw	r24, 0x00	; 0
    2520:	51 f0       	breq	.+20     	; 0x2536 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2522:	eb 85       	ldd	r30, Y+11	; 0x0b
    2524:	fc 85       	ldd	r31, Y+12	; 0x0c
    2526:	81 e0       	ldi	r24, 0x01	; 1
    2528:	80 83       	st	Z, r24
    252a:	05 c0       	rjmp	.+10     	; 0x2536 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    252c:	89 81       	ldd	r24, Y+1	; 0x01
    252e:	8f 5f       	subi	r24, 0xFF	; 255
    2530:	eb 81       	ldd	r30, Y+3	; 0x03
    2532:	fc 81       	ldd	r31, Y+4	; 0x04
    2534:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2536:	81 e0       	ldi	r24, 0x01	; 1
    2538:	8e 83       	std	Y+6, r24	; 0x06
    253a:	01 c0       	rjmp	.+2      	; 0x253e <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    253c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    253e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2540:	2c 96       	adiw	r28, 0x0c	; 12
    2542:	0f b6       	in	r0, 0x3f	; 63
    2544:	f8 94       	cli
    2546:	de bf       	out	0x3e, r29	; 62
    2548:	0f be       	out	0x3f, r0	; 63
    254a:	cd bf       	out	0x3d, r28	; 61
    254c:	cf 91       	pop	r28
    254e:	df 91       	pop	r29
    2550:	08 95       	ret

00002552 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2552:	df 93       	push	r29
    2554:	cf 93       	push	r28
    2556:	cd b7       	in	r28, 0x3d	; 61
    2558:	de b7       	in	r29, 0x3e	; 62
    255a:	2a 97       	sbiw	r28, 0x0a	; 10
    255c:	0f b6       	in	r0, 0x3f	; 63
    255e:	f8 94       	cli
    2560:	de bf       	out	0x3e, r29	; 62
    2562:	0f be       	out	0x3f, r0	; 63
    2564:	cd bf       	out	0x3d, r28	; 61
    2566:	98 87       	std	Y+8, r25	; 0x08
    2568:	8f 83       	std	Y+7, r24	; 0x07
    256a:	7a 87       	std	Y+10, r23	; 0x0a
    256c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    256e:	8f 81       	ldd	r24, Y+7	; 0x07
    2570:	98 85       	ldd	r25, Y+8	; 0x08
    2572:	9a 83       	std	Y+2, r25	; 0x02
    2574:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2576:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2578:	e9 81       	ldd	r30, Y+1	; 0x01
    257a:	fa 81       	ldd	r31, Y+2	; 0x02
    257c:	82 8d       	ldd	r24, Z+26	; 0x1a
    257e:	88 23       	and	r24, r24
    2580:	b1 f0       	breq	.+44     	; 0x25ae <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2582:	e9 81       	ldd	r30, Y+1	; 0x01
    2584:	fa 81       	ldd	r31, Y+2	; 0x02
    2586:	86 81       	ldd	r24, Z+6	; 0x06
    2588:	97 81       	ldd	r25, Z+7	; 0x07
    258a:	9c 83       	std	Y+4, r25	; 0x04
    258c:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    258e:	89 81       	ldd	r24, Y+1	; 0x01
    2590:	9a 81       	ldd	r25, Y+2	; 0x02
    2592:	29 85       	ldd	r18, Y+9	; 0x09
    2594:	3a 85       	ldd	r19, Y+10	; 0x0a
    2596:	b9 01       	movw	r22, r18
    2598:	0e 94 f6 13 	call	0x27ec	; 0x27ec <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    259c:	e9 81       	ldd	r30, Y+1	; 0x01
    259e:	fa 81       	ldd	r31, Y+2	; 0x02
    25a0:	8b 81       	ldd	r24, Y+3	; 0x03
    25a2:	9c 81       	ldd	r25, Y+4	; 0x04
    25a4:	97 83       	std	Z+7, r25	; 0x07
    25a6:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    25a8:	81 e0       	ldi	r24, 0x01	; 1
    25aa:	8e 83       	std	Y+6, r24	; 0x06
    25ac:	01 c0       	rjmp	.+2      	; 0x25b0 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    25ae:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    25b0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    25b2:	2a 96       	adiw	r28, 0x0a	; 10
    25b4:	0f b6       	in	r0, 0x3f	; 63
    25b6:	f8 94       	cli
    25b8:	de bf       	out	0x3e, r29	; 62
    25ba:	0f be       	out	0x3f, r0	; 63
    25bc:	cd bf       	out	0x3d, r28	; 61
    25be:	cf 91       	pop	r28
    25c0:	df 91       	pop	r29
    25c2:	08 95       	ret

000025c4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    25c4:	df 93       	push	r29
    25c6:	cf 93       	push	r28
    25c8:	00 d0       	rcall	.+0      	; 0x25ca <uxQueueMessagesWaiting+0x6>
    25ca:	0f 92       	push	r0
    25cc:	cd b7       	in	r28, 0x3d	; 61
    25ce:	de b7       	in	r29, 0x3e	; 62
    25d0:	9b 83       	std	Y+3, r25	; 0x03
    25d2:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    25d4:	0f b6       	in	r0, 0x3f	; 63
    25d6:	f8 94       	cli
    25d8:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    25da:	ea 81       	ldd	r30, Y+2	; 0x02
    25dc:	fb 81       	ldd	r31, Y+3	; 0x03
    25de:	82 8d       	ldd	r24, Z+26	; 0x1a
    25e0:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    25e2:	0f 90       	pop	r0
    25e4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    25e6:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    25e8:	0f 90       	pop	r0
    25ea:	0f 90       	pop	r0
    25ec:	0f 90       	pop	r0
    25ee:	cf 91       	pop	r28
    25f0:	df 91       	pop	r29
    25f2:	08 95       	ret

000025f4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    25f4:	df 93       	push	r29
    25f6:	cf 93       	push	r28
    25f8:	00 d0       	rcall	.+0      	; 0x25fa <uxQueueSpacesAvailable+0x6>
    25fa:	00 d0       	rcall	.+0      	; 0x25fc <uxQueueSpacesAvailable+0x8>
    25fc:	0f 92       	push	r0
    25fe:	cd b7       	in	r28, 0x3d	; 61
    2600:	de b7       	in	r29, 0x3e	; 62
    2602:	9d 83       	std	Y+5, r25	; 0x05
    2604:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2606:	8c 81       	ldd	r24, Y+4	; 0x04
    2608:	9d 81       	ldd	r25, Y+5	; 0x05
    260a:	9a 83       	std	Y+2, r25	; 0x02
    260c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    260e:	0f b6       	in	r0, 0x3f	; 63
    2610:	f8 94       	cli
    2612:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2614:	e9 81       	ldd	r30, Y+1	; 0x01
    2616:	fa 81       	ldd	r31, Y+2	; 0x02
    2618:	93 8d       	ldd	r25, Z+27	; 0x1b
    261a:	e9 81       	ldd	r30, Y+1	; 0x01
    261c:	fa 81       	ldd	r31, Y+2	; 0x02
    261e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2620:	29 2f       	mov	r18, r25
    2622:	28 1b       	sub	r18, r24
    2624:	82 2f       	mov	r24, r18
    2626:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2628:	0f 90       	pop	r0
    262a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    262c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    262e:	0f 90       	pop	r0
    2630:	0f 90       	pop	r0
    2632:	0f 90       	pop	r0
    2634:	0f 90       	pop	r0
    2636:	0f 90       	pop	r0
    2638:	cf 91       	pop	r28
    263a:	df 91       	pop	r29
    263c:	08 95       	ret

0000263e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    263e:	df 93       	push	r29
    2640:	cf 93       	push	r28
    2642:	00 d0       	rcall	.+0      	; 0x2644 <uxQueueMessagesWaitingFromISR+0x6>
    2644:	00 d0       	rcall	.+0      	; 0x2646 <uxQueueMessagesWaitingFromISR+0x8>
    2646:	0f 92       	push	r0
    2648:	cd b7       	in	r28, 0x3d	; 61
    264a:	de b7       	in	r29, 0x3e	; 62
    264c:	9d 83       	std	Y+5, r25	; 0x05
    264e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2650:	8c 81       	ldd	r24, Y+4	; 0x04
    2652:	9d 81       	ldd	r25, Y+5	; 0x05
    2654:	9a 83       	std	Y+2, r25	; 0x02
    2656:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2658:	e9 81       	ldd	r30, Y+1	; 0x01
    265a:	fa 81       	ldd	r31, Y+2	; 0x02
    265c:	82 8d       	ldd	r24, Z+26	; 0x1a
    265e:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2660:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2662:	0f 90       	pop	r0
    2664:	0f 90       	pop	r0
    2666:	0f 90       	pop	r0
    2668:	0f 90       	pop	r0
    266a:	0f 90       	pop	r0
    266c:	cf 91       	pop	r28
    266e:	df 91       	pop	r29
    2670:	08 95       	ret

00002672 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2672:	df 93       	push	r29
    2674:	cf 93       	push	r28
    2676:	00 d0       	rcall	.+0      	; 0x2678 <vQueueDelete+0x6>
    2678:	00 d0       	rcall	.+0      	; 0x267a <vQueueDelete+0x8>
    267a:	cd b7       	in	r28, 0x3d	; 61
    267c:	de b7       	in	r29, 0x3e	; 62
    267e:	9c 83       	std	Y+4, r25	; 0x04
    2680:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2682:	8b 81       	ldd	r24, Y+3	; 0x03
    2684:	9c 81       	ldd	r25, Y+4	; 0x04
    2686:	9a 83       	std	Y+2, r25	; 0x02
    2688:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    268a:	89 81       	ldd	r24, Y+1	; 0x01
    268c:	9a 81       	ldd	r25, Y+2	; 0x02
    268e:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2692:	0f 90       	pop	r0
    2694:	0f 90       	pop	r0
    2696:	0f 90       	pop	r0
    2698:	0f 90       	pop	r0
    269a:	cf 91       	pop	r28
    269c:	df 91       	pop	r29
    269e:	08 95       	ret

000026a0 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    26a0:	df 93       	push	r29
    26a2:	cf 93       	push	r28
    26a4:	cd b7       	in	r28, 0x3d	; 61
    26a6:	de b7       	in	r29, 0x3e	; 62
    26a8:	27 97       	sbiw	r28, 0x07	; 7
    26aa:	0f b6       	in	r0, 0x3f	; 63
    26ac:	f8 94       	cli
    26ae:	de bf       	out	0x3e, r29	; 62
    26b0:	0f be       	out	0x3f, r0	; 63
    26b2:	cd bf       	out	0x3d, r28	; 61
    26b4:	9c 83       	std	Y+4, r25	; 0x04
    26b6:	8b 83       	std	Y+3, r24	; 0x03
    26b8:	7e 83       	std	Y+6, r23	; 0x06
    26ba:	6d 83       	std	Y+5, r22	; 0x05
    26bc:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    26be:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    26c0:	eb 81       	ldd	r30, Y+3	; 0x03
    26c2:	fc 81       	ldd	r31, Y+4	; 0x04
    26c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    26c6:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    26c8:	eb 81       	ldd	r30, Y+3	; 0x03
    26ca:	fc 81       	ldd	r31, Y+4	; 0x04
    26cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    26ce:	88 23       	and	r24, r24
    26d0:	09 f4       	brne	.+2      	; 0x26d4 <prvCopyDataToQueue+0x34>
    26d2:	7d c0       	rjmp	.+250    	; 0x27ce <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    26d4:	8f 81       	ldd	r24, Y+7	; 0x07
    26d6:	88 23       	and	r24, r24
    26d8:	99 f5       	brne	.+102    	; 0x2740 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    26da:	eb 81       	ldd	r30, Y+3	; 0x03
    26dc:	fc 81       	ldd	r31, Y+4	; 0x04
    26de:	62 81       	ldd	r22, Z+2	; 0x02
    26e0:	73 81       	ldd	r23, Z+3	; 0x03
    26e2:	eb 81       	ldd	r30, Y+3	; 0x03
    26e4:	fc 81       	ldd	r31, Y+4	; 0x04
    26e6:	84 8d       	ldd	r24, Z+28	; 0x1c
    26e8:	48 2f       	mov	r20, r24
    26ea:	50 e0       	ldi	r21, 0x00	; 0
    26ec:	2d 81       	ldd	r18, Y+5	; 0x05
    26ee:	3e 81       	ldd	r19, Y+6	; 0x06
    26f0:	cb 01       	movw	r24, r22
    26f2:	b9 01       	movw	r22, r18
    26f4:	0e 94 bb 29 	call	0x5376	; 0x5376 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    26f8:	eb 81       	ldd	r30, Y+3	; 0x03
    26fa:	fc 81       	ldd	r31, Y+4	; 0x04
    26fc:	22 81       	ldd	r18, Z+2	; 0x02
    26fe:	33 81       	ldd	r19, Z+3	; 0x03
    2700:	eb 81       	ldd	r30, Y+3	; 0x03
    2702:	fc 81       	ldd	r31, Y+4	; 0x04
    2704:	84 8d       	ldd	r24, Z+28	; 0x1c
    2706:	88 2f       	mov	r24, r24
    2708:	90 e0       	ldi	r25, 0x00	; 0
    270a:	82 0f       	add	r24, r18
    270c:	93 1f       	adc	r25, r19
    270e:	eb 81       	ldd	r30, Y+3	; 0x03
    2710:	fc 81       	ldd	r31, Y+4	; 0x04
    2712:	93 83       	std	Z+3, r25	; 0x03
    2714:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2716:	eb 81       	ldd	r30, Y+3	; 0x03
    2718:	fc 81       	ldd	r31, Y+4	; 0x04
    271a:	22 81       	ldd	r18, Z+2	; 0x02
    271c:	33 81       	ldd	r19, Z+3	; 0x03
    271e:	eb 81       	ldd	r30, Y+3	; 0x03
    2720:	fc 81       	ldd	r31, Y+4	; 0x04
    2722:	84 81       	ldd	r24, Z+4	; 0x04
    2724:	95 81       	ldd	r25, Z+5	; 0x05
    2726:	28 17       	cp	r18, r24
    2728:	39 07       	cpc	r19, r25
    272a:	08 f4       	brcc	.+2      	; 0x272e <prvCopyDataToQueue+0x8e>
    272c:	50 c0       	rjmp	.+160    	; 0x27ce <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    272e:	eb 81       	ldd	r30, Y+3	; 0x03
    2730:	fc 81       	ldd	r31, Y+4	; 0x04
    2732:	80 81       	ld	r24, Z
    2734:	91 81       	ldd	r25, Z+1	; 0x01
    2736:	eb 81       	ldd	r30, Y+3	; 0x03
    2738:	fc 81       	ldd	r31, Y+4	; 0x04
    273a:	93 83       	std	Z+3, r25	; 0x03
    273c:	82 83       	std	Z+2, r24	; 0x02
    273e:	47 c0       	rjmp	.+142    	; 0x27ce <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2740:	eb 81       	ldd	r30, Y+3	; 0x03
    2742:	fc 81       	ldd	r31, Y+4	; 0x04
    2744:	66 81       	ldd	r22, Z+6	; 0x06
    2746:	77 81       	ldd	r23, Z+7	; 0x07
    2748:	eb 81       	ldd	r30, Y+3	; 0x03
    274a:	fc 81       	ldd	r31, Y+4	; 0x04
    274c:	84 8d       	ldd	r24, Z+28	; 0x1c
    274e:	48 2f       	mov	r20, r24
    2750:	50 e0       	ldi	r21, 0x00	; 0
    2752:	2d 81       	ldd	r18, Y+5	; 0x05
    2754:	3e 81       	ldd	r19, Y+6	; 0x06
    2756:	cb 01       	movw	r24, r22
    2758:	b9 01       	movw	r22, r18
    275a:	0e 94 bb 29 	call	0x5376	; 0x5376 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    275e:	eb 81       	ldd	r30, Y+3	; 0x03
    2760:	fc 81       	ldd	r31, Y+4	; 0x04
    2762:	26 81       	ldd	r18, Z+6	; 0x06
    2764:	37 81       	ldd	r19, Z+7	; 0x07
    2766:	eb 81       	ldd	r30, Y+3	; 0x03
    2768:	fc 81       	ldd	r31, Y+4	; 0x04
    276a:	84 8d       	ldd	r24, Z+28	; 0x1c
    276c:	88 2f       	mov	r24, r24
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	90 95       	com	r25
    2772:	81 95       	neg	r24
    2774:	9f 4f       	sbci	r25, 0xFF	; 255
    2776:	82 0f       	add	r24, r18
    2778:	93 1f       	adc	r25, r19
    277a:	eb 81       	ldd	r30, Y+3	; 0x03
    277c:	fc 81       	ldd	r31, Y+4	; 0x04
    277e:	97 83       	std	Z+7, r25	; 0x07
    2780:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2782:	eb 81       	ldd	r30, Y+3	; 0x03
    2784:	fc 81       	ldd	r31, Y+4	; 0x04
    2786:	26 81       	ldd	r18, Z+6	; 0x06
    2788:	37 81       	ldd	r19, Z+7	; 0x07
    278a:	eb 81       	ldd	r30, Y+3	; 0x03
    278c:	fc 81       	ldd	r31, Y+4	; 0x04
    278e:	80 81       	ld	r24, Z
    2790:	91 81       	ldd	r25, Z+1	; 0x01
    2792:	28 17       	cp	r18, r24
    2794:	39 07       	cpc	r19, r25
    2796:	90 f4       	brcc	.+36     	; 0x27bc <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2798:	eb 81       	ldd	r30, Y+3	; 0x03
    279a:	fc 81       	ldd	r31, Y+4	; 0x04
    279c:	24 81       	ldd	r18, Z+4	; 0x04
    279e:	35 81       	ldd	r19, Z+5	; 0x05
    27a0:	eb 81       	ldd	r30, Y+3	; 0x03
    27a2:	fc 81       	ldd	r31, Y+4	; 0x04
    27a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    27a6:	88 2f       	mov	r24, r24
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	90 95       	com	r25
    27ac:	81 95       	neg	r24
    27ae:	9f 4f       	sbci	r25, 0xFF	; 255
    27b0:	82 0f       	add	r24, r18
    27b2:	93 1f       	adc	r25, r19
    27b4:	eb 81       	ldd	r30, Y+3	; 0x03
    27b6:	fc 81       	ldd	r31, Y+4	; 0x04
    27b8:	97 83       	std	Z+7, r25	; 0x07
    27ba:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    27bc:	8f 81       	ldd	r24, Y+7	; 0x07
    27be:	82 30       	cpi	r24, 0x02	; 2
    27c0:	31 f4       	brne	.+12     	; 0x27ce <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    27c2:	89 81       	ldd	r24, Y+1	; 0x01
    27c4:	88 23       	and	r24, r24
    27c6:	19 f0       	breq	.+6      	; 0x27ce <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    27c8:	89 81       	ldd	r24, Y+1	; 0x01
    27ca:	81 50       	subi	r24, 0x01	; 1
    27cc:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    27ce:	89 81       	ldd	r24, Y+1	; 0x01
    27d0:	8f 5f       	subi	r24, 0xFF	; 255
    27d2:	eb 81       	ldd	r30, Y+3	; 0x03
    27d4:	fc 81       	ldd	r31, Y+4	; 0x04
    27d6:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    27d8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    27da:	27 96       	adiw	r28, 0x07	; 7
    27dc:	0f b6       	in	r0, 0x3f	; 63
    27de:	f8 94       	cli
    27e0:	de bf       	out	0x3e, r29	; 62
    27e2:	0f be       	out	0x3f, r0	; 63
    27e4:	cd bf       	out	0x3d, r28	; 61
    27e6:	cf 91       	pop	r28
    27e8:	df 91       	pop	r29
    27ea:	08 95       	ret

000027ec <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    27ec:	df 93       	push	r29
    27ee:	cf 93       	push	r28
    27f0:	00 d0       	rcall	.+0      	; 0x27f2 <prvCopyDataFromQueue+0x6>
    27f2:	00 d0       	rcall	.+0      	; 0x27f4 <prvCopyDataFromQueue+0x8>
    27f4:	cd b7       	in	r28, 0x3d	; 61
    27f6:	de b7       	in	r29, 0x3e	; 62
    27f8:	9a 83       	std	Y+2, r25	; 0x02
    27fa:	89 83       	std	Y+1, r24	; 0x01
    27fc:	7c 83       	std	Y+4, r23	; 0x04
    27fe:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2800:	e9 81       	ldd	r30, Y+1	; 0x01
    2802:	fa 81       	ldd	r31, Y+2	; 0x02
    2804:	84 8d       	ldd	r24, Z+28	; 0x1c
    2806:	88 23       	and	r24, r24
    2808:	89 f1       	breq	.+98     	; 0x286c <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    280a:	e9 81       	ldd	r30, Y+1	; 0x01
    280c:	fa 81       	ldd	r31, Y+2	; 0x02
    280e:	26 81       	ldd	r18, Z+6	; 0x06
    2810:	37 81       	ldd	r19, Z+7	; 0x07
    2812:	e9 81       	ldd	r30, Y+1	; 0x01
    2814:	fa 81       	ldd	r31, Y+2	; 0x02
    2816:	84 8d       	ldd	r24, Z+28	; 0x1c
    2818:	88 2f       	mov	r24, r24
    281a:	90 e0       	ldi	r25, 0x00	; 0
    281c:	82 0f       	add	r24, r18
    281e:	93 1f       	adc	r25, r19
    2820:	e9 81       	ldd	r30, Y+1	; 0x01
    2822:	fa 81       	ldd	r31, Y+2	; 0x02
    2824:	97 83       	std	Z+7, r25	; 0x07
    2826:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2828:	e9 81       	ldd	r30, Y+1	; 0x01
    282a:	fa 81       	ldd	r31, Y+2	; 0x02
    282c:	26 81       	ldd	r18, Z+6	; 0x06
    282e:	37 81       	ldd	r19, Z+7	; 0x07
    2830:	e9 81       	ldd	r30, Y+1	; 0x01
    2832:	fa 81       	ldd	r31, Y+2	; 0x02
    2834:	84 81       	ldd	r24, Z+4	; 0x04
    2836:	95 81       	ldd	r25, Z+5	; 0x05
    2838:	28 17       	cp	r18, r24
    283a:	39 07       	cpc	r19, r25
    283c:	40 f0       	brcs	.+16     	; 0x284e <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    283e:	e9 81       	ldd	r30, Y+1	; 0x01
    2840:	fa 81       	ldd	r31, Y+2	; 0x02
    2842:	80 81       	ld	r24, Z
    2844:	91 81       	ldd	r25, Z+1	; 0x01
    2846:	e9 81       	ldd	r30, Y+1	; 0x01
    2848:	fa 81       	ldd	r31, Y+2	; 0x02
    284a:	97 83       	std	Z+7, r25	; 0x07
    284c:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    284e:	e9 81       	ldd	r30, Y+1	; 0x01
    2850:	fa 81       	ldd	r31, Y+2	; 0x02
    2852:	46 81       	ldd	r20, Z+6	; 0x06
    2854:	57 81       	ldd	r21, Z+7	; 0x07
    2856:	e9 81       	ldd	r30, Y+1	; 0x01
    2858:	fa 81       	ldd	r31, Y+2	; 0x02
    285a:	84 8d       	ldd	r24, Z+28	; 0x1c
    285c:	28 2f       	mov	r18, r24
    285e:	30 e0       	ldi	r19, 0x00	; 0
    2860:	8b 81       	ldd	r24, Y+3	; 0x03
    2862:	9c 81       	ldd	r25, Y+4	; 0x04
    2864:	ba 01       	movw	r22, r20
    2866:	a9 01       	movw	r20, r18
    2868:	0e 94 bb 29 	call	0x5376	; 0x5376 <memcpy>
	}
}
    286c:	0f 90       	pop	r0
    286e:	0f 90       	pop	r0
    2870:	0f 90       	pop	r0
    2872:	0f 90       	pop	r0
    2874:	cf 91       	pop	r28
    2876:	df 91       	pop	r29
    2878:	08 95       	ret

0000287a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    287a:	df 93       	push	r29
    287c:	cf 93       	push	r28
    287e:	00 d0       	rcall	.+0      	; 0x2880 <prvUnlockQueue+0x6>
    2880:	00 d0       	rcall	.+0      	; 0x2882 <prvUnlockQueue+0x8>
    2882:	cd b7       	in	r28, 0x3d	; 61
    2884:	de b7       	in	r29, 0x3e	; 62
    2886:	9c 83       	std	Y+4, r25	; 0x04
    2888:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    288a:	0f b6       	in	r0, 0x3f	; 63
    288c:	f8 94       	cli
    288e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2890:	eb 81       	ldd	r30, Y+3	; 0x03
    2892:	fc 81       	ldd	r31, Y+4	; 0x04
    2894:	86 8d       	ldd	r24, Z+30	; 0x1e
    2896:	8a 83       	std	Y+2, r24	; 0x02
    2898:	11 c0       	rjmp	.+34     	; 0x28bc <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    289a:	eb 81       	ldd	r30, Y+3	; 0x03
    289c:	fc 81       	ldd	r31, Y+4	; 0x04
    289e:	81 89       	ldd	r24, Z+17	; 0x11
    28a0:	88 23       	and	r24, r24
    28a2:	79 f0       	breq	.+30     	; 0x28c2 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28a4:	8b 81       	ldd	r24, Y+3	; 0x03
    28a6:	9c 81       	ldd	r25, Y+4	; 0x04
    28a8:	41 96       	adiw	r24, 0x11	; 17
    28aa:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    28ae:	88 23       	and	r24, r24
    28b0:	11 f0       	breq	.+4      	; 0x28b6 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    28b2:	0e 94 99 24 	call	0x4932	; 0x4932 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    28b6:	8a 81       	ldd	r24, Y+2	; 0x02
    28b8:	81 50       	subi	r24, 0x01	; 1
    28ba:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    28bc:	8a 81       	ldd	r24, Y+2	; 0x02
    28be:	18 16       	cp	r1, r24
    28c0:	64 f3       	brlt	.-40     	; 0x289a <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    28c2:	eb 81       	ldd	r30, Y+3	; 0x03
    28c4:	fc 81       	ldd	r31, Y+4	; 0x04
    28c6:	8f ef       	ldi	r24, 0xFF	; 255
    28c8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    28ca:	0f 90       	pop	r0
    28cc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    28ce:	0f b6       	in	r0, 0x3f	; 63
    28d0:	f8 94       	cli
    28d2:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    28d4:	eb 81       	ldd	r30, Y+3	; 0x03
    28d6:	fc 81       	ldd	r31, Y+4	; 0x04
    28d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    28da:	89 83       	std	Y+1, r24	; 0x01
    28dc:	11 c0       	rjmp	.+34     	; 0x2900 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28de:	eb 81       	ldd	r30, Y+3	; 0x03
    28e0:	fc 81       	ldd	r31, Y+4	; 0x04
    28e2:	80 85       	ldd	r24, Z+8	; 0x08
    28e4:	88 23       	and	r24, r24
    28e6:	79 f0       	breq	.+30     	; 0x2906 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    28e8:	8b 81       	ldd	r24, Y+3	; 0x03
    28ea:	9c 81       	ldd	r25, Y+4	; 0x04
    28ec:	08 96       	adiw	r24, 0x08	; 8
    28ee:	0e 94 2d 23 	call	0x465a	; 0x465a <xTaskRemoveFromEventList>
    28f2:	88 23       	and	r24, r24
    28f4:	11 f0       	breq	.+4      	; 0x28fa <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    28f6:	0e 94 99 24 	call	0x4932	; 0x4932 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    28fa:	89 81       	ldd	r24, Y+1	; 0x01
    28fc:	81 50       	subi	r24, 0x01	; 1
    28fe:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2900:	89 81       	ldd	r24, Y+1	; 0x01
    2902:	18 16       	cp	r1, r24
    2904:	64 f3       	brlt	.-40     	; 0x28de <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2906:	eb 81       	ldd	r30, Y+3	; 0x03
    2908:	fc 81       	ldd	r31, Y+4	; 0x04
    290a:	8f ef       	ldi	r24, 0xFF	; 255
    290c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    290e:	0f 90       	pop	r0
    2910:	0f be       	out	0x3f, r0	; 63
}
    2912:	0f 90       	pop	r0
    2914:	0f 90       	pop	r0
    2916:	0f 90       	pop	r0
    2918:	0f 90       	pop	r0
    291a:	cf 91       	pop	r28
    291c:	df 91       	pop	r29
    291e:	08 95       	ret

00002920 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2920:	df 93       	push	r29
    2922:	cf 93       	push	r28
    2924:	00 d0       	rcall	.+0      	; 0x2926 <prvIsQueueEmpty+0x6>
    2926:	0f 92       	push	r0
    2928:	cd b7       	in	r28, 0x3d	; 61
    292a:	de b7       	in	r29, 0x3e	; 62
    292c:	9b 83       	std	Y+3, r25	; 0x03
    292e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2930:	0f b6       	in	r0, 0x3f	; 63
    2932:	f8 94       	cli
    2934:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2936:	ea 81       	ldd	r30, Y+2	; 0x02
    2938:	fb 81       	ldd	r31, Y+3	; 0x03
    293a:	82 8d       	ldd	r24, Z+26	; 0x1a
    293c:	88 23       	and	r24, r24
    293e:	19 f4       	brne	.+6      	; 0x2946 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2940:	81 e0       	ldi	r24, 0x01	; 1
    2942:	89 83       	std	Y+1, r24	; 0x01
    2944:	01 c0       	rjmp	.+2      	; 0x2948 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2946:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2948:	0f 90       	pop	r0
    294a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    294c:	89 81       	ldd	r24, Y+1	; 0x01
}
    294e:	0f 90       	pop	r0
    2950:	0f 90       	pop	r0
    2952:	0f 90       	pop	r0
    2954:	cf 91       	pop	r28
    2956:	df 91       	pop	r29
    2958:	08 95       	ret

0000295a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    295a:	df 93       	push	r29
    295c:	cf 93       	push	r28
    295e:	00 d0       	rcall	.+0      	; 0x2960 <xQueueIsQueueEmptyFromISR+0x6>
    2960:	00 d0       	rcall	.+0      	; 0x2962 <xQueueIsQueueEmptyFromISR+0x8>
    2962:	0f 92       	push	r0
    2964:	cd b7       	in	r28, 0x3d	; 61
    2966:	de b7       	in	r29, 0x3e	; 62
    2968:	9d 83       	std	Y+5, r25	; 0x05
    296a:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    296c:	8c 81       	ldd	r24, Y+4	; 0x04
    296e:	9d 81       	ldd	r25, Y+5	; 0x05
    2970:	9a 83       	std	Y+2, r25	; 0x02
    2972:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2974:	e9 81       	ldd	r30, Y+1	; 0x01
    2976:	fa 81       	ldd	r31, Y+2	; 0x02
    2978:	82 8d       	ldd	r24, Z+26	; 0x1a
    297a:	88 23       	and	r24, r24
    297c:	19 f4       	brne	.+6      	; 0x2984 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    297e:	81 e0       	ldi	r24, 0x01	; 1
    2980:	8b 83       	std	Y+3, r24	; 0x03
    2982:	01 c0       	rjmp	.+2      	; 0x2986 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2984:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2986:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2988:	0f 90       	pop	r0
    298a:	0f 90       	pop	r0
    298c:	0f 90       	pop	r0
    298e:	0f 90       	pop	r0
    2990:	0f 90       	pop	r0
    2992:	cf 91       	pop	r28
    2994:	df 91       	pop	r29
    2996:	08 95       	ret

00002998 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2998:	df 93       	push	r29
    299a:	cf 93       	push	r28
    299c:	00 d0       	rcall	.+0      	; 0x299e <prvIsQueueFull+0x6>
    299e:	0f 92       	push	r0
    29a0:	cd b7       	in	r28, 0x3d	; 61
    29a2:	de b7       	in	r29, 0x3e	; 62
    29a4:	9b 83       	std	Y+3, r25	; 0x03
    29a6:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    29a8:	0f b6       	in	r0, 0x3f	; 63
    29aa:	f8 94       	cli
    29ac:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    29ae:	ea 81       	ldd	r30, Y+2	; 0x02
    29b0:	fb 81       	ldd	r31, Y+3	; 0x03
    29b2:	92 8d       	ldd	r25, Z+26	; 0x1a
    29b4:	ea 81       	ldd	r30, Y+2	; 0x02
    29b6:	fb 81       	ldd	r31, Y+3	; 0x03
    29b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    29ba:	98 17       	cp	r25, r24
    29bc:	19 f4       	brne	.+6      	; 0x29c4 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    29be:	81 e0       	ldi	r24, 0x01	; 1
    29c0:	89 83       	std	Y+1, r24	; 0x01
    29c2:	01 c0       	rjmp	.+2      	; 0x29c6 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    29c4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    29c6:	0f 90       	pop	r0
    29c8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    29ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    29cc:	0f 90       	pop	r0
    29ce:	0f 90       	pop	r0
    29d0:	0f 90       	pop	r0
    29d2:	cf 91       	pop	r28
    29d4:	df 91       	pop	r29
    29d6:	08 95       	ret

000029d8 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    29d8:	df 93       	push	r29
    29da:	cf 93       	push	r28
    29dc:	00 d0       	rcall	.+0      	; 0x29de <xQueueIsQueueFullFromISR+0x6>
    29de:	00 d0       	rcall	.+0      	; 0x29e0 <xQueueIsQueueFullFromISR+0x8>
    29e0:	0f 92       	push	r0
    29e2:	cd b7       	in	r28, 0x3d	; 61
    29e4:	de b7       	in	r29, 0x3e	; 62
    29e6:	9d 83       	std	Y+5, r25	; 0x05
    29e8:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    29ea:	8c 81       	ldd	r24, Y+4	; 0x04
    29ec:	9d 81       	ldd	r25, Y+5	; 0x05
    29ee:	9a 83       	std	Y+2, r25	; 0x02
    29f0:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    29f2:	e9 81       	ldd	r30, Y+1	; 0x01
    29f4:	fa 81       	ldd	r31, Y+2	; 0x02
    29f6:	92 8d       	ldd	r25, Z+26	; 0x1a
    29f8:	e9 81       	ldd	r30, Y+1	; 0x01
    29fa:	fa 81       	ldd	r31, Y+2	; 0x02
    29fc:	83 8d       	ldd	r24, Z+27	; 0x1b
    29fe:	98 17       	cp	r25, r24
    2a00:	19 f4       	brne	.+6      	; 0x2a08 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2a02:	81 e0       	ldi	r24, 0x01	; 1
    2a04:	8b 83       	std	Y+3, r24	; 0x03
    2a06:	01 c0       	rjmp	.+2      	; 0x2a0a <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2a08:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2a0a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2a0c:	0f 90       	pop	r0
    2a0e:	0f 90       	pop	r0
    2a10:	0f 90       	pop	r0
    2a12:	0f 90       	pop	r0
    2a14:	0f 90       	pop	r0
    2a16:	cf 91       	pop	r28
    2a18:	df 91       	pop	r29
    2a1a:	08 95       	ret

00002a1c <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2a1c:	0f 93       	push	r16
    2a1e:	df 93       	push	r29
    2a20:	cf 93       	push	r28
    2a22:	cd b7       	in	r28, 0x3d	; 61
    2a24:	de b7       	in	r29, 0x3e	; 62
    2a26:	28 97       	sbiw	r28, 0x08	; 8
    2a28:	0f b6       	in	r0, 0x3f	; 63
    2a2a:	f8 94       	cli
    2a2c:	de bf       	out	0x3e, r29	; 62
    2a2e:	0f be       	out	0x3f, r0	; 63
    2a30:	cd bf       	out	0x3d, r28	; 61
    2a32:	9d 83       	std	Y+5, r25	; 0x05
    2a34:	8c 83       	std	Y+4, r24	; 0x04
    2a36:	7f 83       	std	Y+7, r23	; 0x07
    2a38:	6e 83       	std	Y+6, r22	; 0x06
    2a3a:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2a3c:	88 85       	ldd	r24, Y+8	; 0x08
    2a3e:	81 30       	cpi	r24, 0x01	; 1
    2a40:	19 f4       	brne	.+6      	; 0x2a48 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2a42:	81 e0       	ldi	r24, 0x01	; 1
    2a44:	89 83       	std	Y+1, r24	; 0x01
    2a46:	01 c0       	rjmp	.+2      	; 0x2a4a <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2a48:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2a4a:	8e 81       	ldd	r24, Y+6	; 0x06
    2a4c:	9f 81       	ldd	r25, Y+7	; 0x07
    2a4e:	00 97       	sbiw	r24, 0x00	; 0
    2a50:	21 f4       	brne	.+8      	; 0x2a5a <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2a52:	81 e0       	ldi	r24, 0x01	; 1
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	9f 83       	std	Y+7, r25	; 0x07
    2a58:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2a5a:	8c 81       	ldd	r24, Y+4	; 0x04
    2a5c:	9d 81       	ldd	r25, Y+5	; 0x05
    2a5e:	01 96       	adiw	r24, 0x01	; 1
    2a60:	9d 83       	std	Y+5, r25	; 0x05
    2a62:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2a64:	8c 81       	ldd	r24, Y+4	; 0x04
    2a66:	9d 81       	ldd	r25, Y+5	; 0x05
    2a68:	0f 96       	adiw	r24, 0x0f	; 15
    2a6a:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
    2a6e:	9b 83       	std	Y+3, r25	; 0x03
    2a70:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2a72:	8a 81       	ldd	r24, Y+2	; 0x02
    2a74:	9b 81       	ldd	r25, Y+3	; 0x03
    2a76:	00 97       	sbiw	r24, 0x00	; 0
    2a78:	89 f0       	breq	.+34     	; 0x2a9c <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2a7a:	6a 81       	ldd	r22, Y+2	; 0x02
    2a7c:	7b 81       	ldd	r23, Y+3	; 0x03
    2a7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a80:	9b 81       	ldd	r25, Y+3	; 0x03
    2a82:	9c 01       	movw	r18, r24
    2a84:	21 5f       	subi	r18, 0xF1	; 241
    2a86:	3f 4f       	sbci	r19, 0xFF	; 255
    2a88:	4c 81       	ldd	r20, Y+4	; 0x04
    2a8a:	5d 81       	ldd	r21, Y+5	; 0x05
    2a8c:	ee 81       	ldd	r30, Y+6	; 0x06
    2a8e:	ff 81       	ldd	r31, Y+7	; 0x07
    2a90:	cb 01       	movw	r24, r22
    2a92:	b9 01       	movw	r22, r18
    2a94:	9f 01       	movw	r18, r30
    2a96:	09 81       	ldd	r16, Y+1	; 0x01
    2a98:	0e 94 66 1c 	call	0x38cc	; 0x38cc <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a9e:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2aa0:	28 96       	adiw	r28, 0x08	; 8
    2aa2:	0f b6       	in	r0, 0x3f	; 63
    2aa4:	f8 94       	cli
    2aa6:	de bf       	out	0x3e, r29	; 62
    2aa8:	0f be       	out	0x3f, r0	; 63
    2aaa:	cd bf       	out	0x3d, r28	; 61
    2aac:	cf 91       	pop	r28
    2aae:	df 91       	pop	r29
    2ab0:	0f 91       	pop	r16
    2ab2:	08 95       	ret

00002ab4 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2ab4:	df 93       	push	r29
    2ab6:	cf 93       	push	r28
    2ab8:	00 d0       	rcall	.+0      	; 0x2aba <vStreamBufferDelete+0x6>
    2aba:	00 d0       	rcall	.+0      	; 0x2abc <vStreamBufferDelete+0x8>
    2abc:	cd b7       	in	r28, 0x3d	; 61
    2abe:	de b7       	in	r29, 0x3e	; 62
    2ac0:	9c 83       	std	Y+4, r25	; 0x04
    2ac2:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac8:	9a 83       	std	Y+2, r25	; 0x02
    2aca:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2acc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ace:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad0:	86 85       	ldd	r24, Z+14	; 0x0e
    2ad2:	88 2f       	mov	r24, r24
    2ad4:	90 e0       	ldi	r25, 0x00	; 0
    2ad6:	82 70       	andi	r24, 0x02	; 2
    2ad8:	90 70       	andi	r25, 0x00	; 0
    2ada:	00 97       	sbiw	r24, 0x00	; 0
    2adc:	29 f4       	brne	.+10     	; 0x2ae8 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2ade:	89 81       	ldd	r24, Y+1	; 0x01
    2ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ae2:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
    2ae6:	08 c0       	rjmp	.+16     	; 0x2af8 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2ae8:	89 81       	ldd	r24, Y+1	; 0x01
    2aea:	9a 81       	ldd	r25, Y+2	; 0x02
    2aec:	60 e0       	ldi	r22, 0x00	; 0
    2aee:	70 e0       	ldi	r23, 0x00	; 0
    2af0:	4f e0       	ldi	r20, 0x0F	; 15
    2af2:	50 e0       	ldi	r21, 0x00	; 0
    2af4:	0e 94 c4 29 	call	0x5388	; 0x5388 <memset>
	}
}
    2af8:	0f 90       	pop	r0
    2afa:	0f 90       	pop	r0
    2afc:	0f 90       	pop	r0
    2afe:	0f 90       	pop	r0
    2b00:	cf 91       	pop	r28
    2b02:	df 91       	pop	r29
    2b04:	08 95       	ret

00002b06 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2b06:	0f 93       	push	r16
    2b08:	df 93       	push	r29
    2b0a:	cf 93       	push	r28
    2b0c:	00 d0       	rcall	.+0      	; 0x2b0e <xStreamBufferReset+0x8>
    2b0e:	00 d0       	rcall	.+0      	; 0x2b10 <xStreamBufferReset+0xa>
    2b10:	0f 92       	push	r0
    2b12:	cd b7       	in	r28, 0x3d	; 61
    2b14:	de b7       	in	r29, 0x3e	; 62
    2b16:	9d 83       	std	Y+5, r25	; 0x05
    2b18:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2b1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2b1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2b1e:	9b 83       	std	Y+3, r25	; 0x03
    2b20:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2b22:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    2b24:	0f b6       	in	r0, 0x3f	; 63
    2b26:	f8 94       	cli
    2b28:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2b2a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b2c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b2e:	80 85       	ldd	r24, Z+8	; 0x08
    2b30:	91 85       	ldd	r25, Z+9	; 0x09
    2b32:	00 97       	sbiw	r24, 0x00	; 0
    2b34:	f1 f4       	brne	.+60     	; 0x2b72 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2b36:	ea 81       	ldd	r30, Y+2	; 0x02
    2b38:	fb 81       	ldd	r31, Y+3	; 0x03
    2b3a:	82 85       	ldd	r24, Z+10	; 0x0a
    2b3c:	93 85       	ldd	r25, Z+11	; 0x0b
    2b3e:	00 97       	sbiw	r24, 0x00	; 0
    2b40:	c1 f4       	brne	.+48     	; 0x2b72 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2b42:	ea 81       	ldd	r30, Y+2	; 0x02
    2b44:	fb 81       	ldd	r31, Y+3	; 0x03
    2b46:	24 85       	ldd	r18, Z+12	; 0x0c
    2b48:	35 85       	ldd	r19, Z+13	; 0x0d
    2b4a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b4c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b4e:	44 81       	ldd	r20, Z+4	; 0x04
    2b50:	55 81       	ldd	r21, Z+5	; 0x05
    2b52:	ea 81       	ldd	r30, Y+2	; 0x02
    2b54:	fb 81       	ldd	r31, Y+3	; 0x03
    2b56:	a6 81       	ldd	r26, Z+6	; 0x06
    2b58:	b7 81       	ldd	r27, Z+7	; 0x07
    2b5a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b5c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b5e:	e6 85       	ldd	r30, Z+14	; 0x0e
    2b60:	8a 81       	ldd	r24, Y+2	; 0x02
    2b62:	9b 81       	ldd	r25, Y+3	; 0x03
    2b64:	b9 01       	movw	r22, r18
    2b66:	9d 01       	movw	r18, r26
    2b68:	0e 2f       	mov	r16, r30
    2b6a:	0e 94 66 1c 	call	0x38cc	; 0x38cc <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2b6e:	81 e0       	ldi	r24, 0x01	; 1
    2b70:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2b72:	0f 90       	pop	r0
    2b74:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2b76:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b78:	0f 90       	pop	r0
    2b7a:	0f 90       	pop	r0
    2b7c:	0f 90       	pop	r0
    2b7e:	0f 90       	pop	r0
    2b80:	0f 90       	pop	r0
    2b82:	cf 91       	pop	r28
    2b84:	df 91       	pop	r29
    2b86:	0f 91       	pop	r16
    2b88:	08 95       	ret

00002b8a <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    2b8a:	df 93       	push	r29
    2b8c:	cf 93       	push	r28
    2b8e:	cd b7       	in	r28, 0x3d	; 61
    2b90:	de b7       	in	r29, 0x3e	; 62
    2b92:	27 97       	sbiw	r28, 0x07	; 7
    2b94:	0f b6       	in	r0, 0x3f	; 63
    2b96:	f8 94       	cli
    2b98:	de bf       	out	0x3e, r29	; 62
    2b9a:	0f be       	out	0x3f, r0	; 63
    2b9c:	cd bf       	out	0x3d, r28	; 61
    2b9e:	9d 83       	std	Y+5, r25	; 0x05
    2ba0:	8c 83       	std	Y+4, r24	; 0x04
    2ba2:	7f 83       	std	Y+7, r23	; 0x07
    2ba4:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2ba6:	8c 81       	ldd	r24, Y+4	; 0x04
    2ba8:	9d 81       	ldd	r25, Y+5	; 0x05
    2baa:	9b 83       	std	Y+3, r25	; 0x03
    2bac:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2bae:	8e 81       	ldd	r24, Y+6	; 0x06
    2bb0:	9f 81       	ldd	r25, Y+7	; 0x07
    2bb2:	00 97       	sbiw	r24, 0x00	; 0
    2bb4:	21 f4       	brne	.+8      	; 0x2bbe <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2bb6:	81 e0       	ldi	r24, 0x01	; 1
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	9f 83       	std	Y+7, r25	; 0x07
    2bbc:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2bbe:	ea 81       	ldd	r30, Y+2	; 0x02
    2bc0:	fb 81       	ldd	r31, Y+3	; 0x03
    2bc2:	24 81       	ldd	r18, Z+4	; 0x04
    2bc4:	35 81       	ldd	r19, Z+5	; 0x05
    2bc6:	8e 81       	ldd	r24, Y+6	; 0x06
    2bc8:	9f 81       	ldd	r25, Y+7	; 0x07
    2bca:	28 17       	cp	r18, r24
    2bcc:	39 07       	cpc	r19, r25
    2bce:	48 f0       	brcs	.+18     	; 0x2be2 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2bd0:	ea 81       	ldd	r30, Y+2	; 0x02
    2bd2:	fb 81       	ldd	r31, Y+3	; 0x03
    2bd4:	8e 81       	ldd	r24, Y+6	; 0x06
    2bd6:	9f 81       	ldd	r25, Y+7	; 0x07
    2bd8:	97 83       	std	Z+7, r25	; 0x07
    2bda:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2bdc:	81 e0       	ldi	r24, 0x01	; 1
    2bde:	89 83       	std	Y+1, r24	; 0x01
    2be0:	01 c0       	rjmp	.+2      	; 0x2be4 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2be2:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2be4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2be6:	27 96       	adiw	r28, 0x07	; 7
    2be8:	0f b6       	in	r0, 0x3f	; 63
    2bea:	f8 94       	cli
    2bec:	de bf       	out	0x3e, r29	; 62
    2bee:	0f be       	out	0x3f, r0	; 63
    2bf0:	cd bf       	out	0x3d, r28	; 61
    2bf2:	cf 91       	pop	r28
    2bf4:	df 91       	pop	r29
    2bf6:	08 95       	ret

00002bf8 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2bf8:	df 93       	push	r29
    2bfa:	cf 93       	push	r28
    2bfc:	00 d0       	rcall	.+0      	; 0x2bfe <xStreamBufferSpacesAvailable+0x6>
    2bfe:	00 d0       	rcall	.+0      	; 0x2c00 <xStreamBufferSpacesAvailable+0x8>
    2c00:	00 d0       	rcall	.+0      	; 0x2c02 <xStreamBufferSpacesAvailable+0xa>
    2c02:	cd b7       	in	r28, 0x3d	; 61
    2c04:	de b7       	in	r29, 0x3e	; 62
    2c06:	9e 83       	std	Y+6, r25	; 0x06
    2c08:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c0a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c0c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c0e:	9c 83       	std	Y+4, r25	; 0x04
    2c10:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2c12:	eb 81       	ldd	r30, Y+3	; 0x03
    2c14:	fc 81       	ldd	r31, Y+4	; 0x04
    2c16:	24 81       	ldd	r18, Z+4	; 0x04
    2c18:	35 81       	ldd	r19, Z+5	; 0x05
    2c1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c1e:	80 81       	ld	r24, Z
    2c20:	91 81       	ldd	r25, Z+1	; 0x01
    2c22:	82 0f       	add	r24, r18
    2c24:	93 1f       	adc	r25, r19
    2c26:	9a 83       	std	Y+2, r25	; 0x02
    2c28:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2e:	22 81       	ldd	r18, Z+2	; 0x02
    2c30:	33 81       	ldd	r19, Z+3	; 0x03
    2c32:	89 81       	ldd	r24, Y+1	; 0x01
    2c34:	9a 81       	ldd	r25, Y+2	; 0x02
    2c36:	82 1b       	sub	r24, r18
    2c38:	93 0b       	sbc	r25, r19
    2c3a:	9a 83       	std	Y+2, r25	; 0x02
    2c3c:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2c3e:	89 81       	ldd	r24, Y+1	; 0x01
    2c40:	9a 81       	ldd	r25, Y+2	; 0x02
    2c42:	01 97       	sbiw	r24, 0x01	; 1
    2c44:	9a 83       	std	Y+2, r25	; 0x02
    2c46:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    2c48:	eb 81       	ldd	r30, Y+3	; 0x03
    2c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c4c:	24 81       	ldd	r18, Z+4	; 0x04
    2c4e:	35 81       	ldd	r19, Z+5	; 0x05
    2c50:	89 81       	ldd	r24, Y+1	; 0x01
    2c52:	9a 81       	ldd	r25, Y+2	; 0x02
    2c54:	82 17       	cp	r24, r18
    2c56:	93 07       	cpc	r25, r19
    2c58:	50 f0       	brcs	.+20     	; 0x2c6e <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c5e:	24 81       	ldd	r18, Z+4	; 0x04
    2c60:	35 81       	ldd	r19, Z+5	; 0x05
    2c62:	89 81       	ldd	r24, Y+1	; 0x01
    2c64:	9a 81       	ldd	r25, Y+2	; 0x02
    2c66:	82 1b       	sub	r24, r18
    2c68:	93 0b       	sbc	r25, r19
    2c6a:	9a 83       	std	Y+2, r25	; 0x02
    2c6c:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2c6e:	89 81       	ldd	r24, Y+1	; 0x01
    2c70:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2c72:	26 96       	adiw	r28, 0x06	; 6
    2c74:	0f b6       	in	r0, 0x3f	; 63
    2c76:	f8 94       	cli
    2c78:	de bf       	out	0x3e, r29	; 62
    2c7a:	0f be       	out	0x3f, r0	; 63
    2c7c:	cd bf       	out	0x3d, r28	; 61
    2c7e:	cf 91       	pop	r28
    2c80:	df 91       	pop	r29
    2c82:	08 95       	ret

00002c84 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2c84:	df 93       	push	r29
    2c86:	cf 93       	push	r28
    2c88:	00 d0       	rcall	.+0      	; 0x2c8a <xStreamBufferBytesAvailable+0x6>
    2c8a:	00 d0       	rcall	.+0      	; 0x2c8c <xStreamBufferBytesAvailable+0x8>
    2c8c:	00 d0       	rcall	.+0      	; 0x2c8e <xStreamBufferBytesAvailable+0xa>
    2c8e:	cd b7       	in	r28, 0x3d	; 61
    2c90:	de b7       	in	r29, 0x3e	; 62
    2c92:	9e 83       	std	Y+6, r25	; 0x06
    2c94:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c96:	8d 81       	ldd	r24, Y+5	; 0x05
    2c98:	9e 81       	ldd	r25, Y+6	; 0x06
    2c9a:	9c 83       	std	Y+4, r25	; 0x04
    2c9c:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2c9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ca2:	0e 94 2c 1c 	call	0x3858	; 0x3858 <prvBytesInBuffer>
    2ca6:	9a 83       	std	Y+2, r25	; 0x02
    2ca8:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2caa:	89 81       	ldd	r24, Y+1	; 0x01
    2cac:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2cae:	26 96       	adiw	r28, 0x06	; 6
    2cb0:	0f b6       	in	r0, 0x3f	; 63
    2cb2:	f8 94       	cli
    2cb4:	de bf       	out	0x3e, r29	; 62
    2cb6:	0f be       	out	0x3f, r0	; 63
    2cb8:	cd bf       	out	0x3d, r28	; 61
    2cba:	cf 91       	pop	r28
    2cbc:	df 91       	pop	r29
    2cbe:	08 95       	ret

00002cc0 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2cc0:	ef 92       	push	r14
    2cc2:	ff 92       	push	r15
    2cc4:	0f 93       	push	r16
    2cc6:	1f 93       	push	r17
    2cc8:	df 93       	push	r29
    2cca:	cf 93       	push	r28
    2ccc:	cd b7       	in	r28, 0x3d	; 61
    2cce:	de b7       	in	r29, 0x3e	; 62
    2cd0:	63 97       	sbiw	r28, 0x13	; 19
    2cd2:	0f b6       	in	r0, 0x3f	; 63
    2cd4:	f8 94       	cli
    2cd6:	de bf       	out	0x3e, r29	; 62
    2cd8:	0f be       	out	0x3f, r0	; 63
    2cda:	cd bf       	out	0x3d, r28	; 61
    2cdc:	9d 87       	std	Y+13, r25	; 0x0d
    2cde:	8c 87       	std	Y+12, r24	; 0x0c
    2ce0:	7f 87       	std	Y+15, r23	; 0x0f
    2ce2:	6e 87       	std	Y+14, r22	; 0x0e
    2ce4:	59 8b       	std	Y+17, r21	; 0x11
    2ce6:	48 8b       	std	Y+16, r20	; 0x10
    2ce8:	3b 8b       	std	Y+19, r19	; 0x13
    2cea:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2cec:	8c 85       	ldd	r24, Y+12	; 0x0c
    2cee:	9d 85       	ldd	r25, Y+13	; 0x0d
    2cf0:	98 87       	std	Y+8, r25	; 0x08
    2cf2:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    2cf4:	1c 82       	std	Y+4, r1	; 0x04
    2cf6:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    2cf8:	88 89       	ldd	r24, Y+16	; 0x10
    2cfa:	99 89       	ldd	r25, Y+17	; 0x11
    2cfc:	9a 83       	std	Y+2, r25	; 0x02
    2cfe:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2d00:	ef 81       	ldd	r30, Y+7	; 0x07
    2d02:	f8 85       	ldd	r31, Y+8	; 0x08
    2d04:	86 85       	ldd	r24, Z+14	; 0x0e
    2d06:	88 2f       	mov	r24, r24
    2d08:	90 e0       	ldi	r25, 0x00	; 0
    2d0a:	81 70       	andi	r24, 0x01	; 1
    2d0c:	90 70       	andi	r25, 0x00	; 0
    2d0e:	88 23       	and	r24, r24
    2d10:	29 f0       	breq	.+10     	; 0x2d1c <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2d12:	89 81       	ldd	r24, Y+1	; 0x01
    2d14:	9a 81       	ldd	r25, Y+2	; 0x02
    2d16:	02 96       	adiw	r24, 0x02	; 2
    2d18:	9a 83       	std	Y+2, r25	; 0x02
    2d1a:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2d1c:	8a 89       	ldd	r24, Y+18	; 0x12
    2d1e:	9b 89       	ldd	r25, Y+19	; 0x13
    2d20:	00 97       	sbiw	r24, 0x00	; 0
    2d22:	09 f4       	brne	.+2      	; 0x2d26 <xStreamBufferSend+0x66>
    2d24:	40 c0       	rjmp	.+128    	; 0x2da6 <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    2d26:	ce 01       	movw	r24, r28
    2d28:	09 96       	adiw	r24, 0x09	; 9
    2d2a:	0e 94 f5 23 	call	0x47ea	; 0x47ea <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2d2e:	0f b6       	in	r0, 0x3f	; 63
    2d30:	f8 94       	cli
    2d32:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2d34:	8f 81       	ldd	r24, Y+7	; 0x07
    2d36:	98 85       	ldd	r25, Y+8	; 0x08
    2d38:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <xStreamBufferSpacesAvailable>
    2d3c:	9c 83       	std	Y+4, r25	; 0x04
    2d3e:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2d40:	2b 81       	ldd	r18, Y+3	; 0x03
    2d42:	3c 81       	ldd	r19, Y+4	; 0x04
    2d44:	89 81       	ldd	r24, Y+1	; 0x01
    2d46:	9a 81       	ldd	r25, Y+2	; 0x02
    2d48:	28 17       	cp	r18, r24
    2d4a:	39 07       	cpc	r19, r25
    2d4c:	50 f5       	brcc	.+84     	; 0x2da2 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    2d4e:	80 e0       	ldi	r24, 0x00	; 0
    2d50:	90 e0       	ldi	r25, 0x00	; 0
    2d52:	0e 94 05 29 	call	0x520a	; 0x520a <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2d56:	0e 94 5e 25 	call	0x4abc	; 0x4abc <xTaskGetCurrentTaskHandle>
    2d5a:	ef 81       	ldd	r30, Y+7	; 0x07
    2d5c:	f8 85       	ldd	r31, Y+8	; 0x08
    2d5e:	93 87       	std	Z+11, r25	; 0x0b
    2d60:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2d62:	0f 90       	pop	r0
    2d64:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2d66:	ea 89       	ldd	r30, Y+18	; 0x12
    2d68:	fb 89       	ldd	r31, Y+19	; 0x13
    2d6a:	60 e0       	ldi	r22, 0x00	; 0
    2d6c:	70 e0       	ldi	r23, 0x00	; 0
    2d6e:	80 e0       	ldi	r24, 0x00	; 0
    2d70:	90 e0       	ldi	r25, 0x00	; 0
    2d72:	20 e0       	ldi	r18, 0x00	; 0
    2d74:	30 e0       	ldi	r19, 0x00	; 0
    2d76:	40 e0       	ldi	r20, 0x00	; 0
    2d78:	50 e0       	ldi	r21, 0x00	; 0
    2d7a:	00 e0       	ldi	r16, 0x00	; 0
    2d7c:	10 e0       	ldi	r17, 0x00	; 0
    2d7e:	7f 01       	movw	r14, r30
    2d80:	0e 94 0e 26 	call	0x4c1c	; 0x4c1c <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    2d84:	ef 81       	ldd	r30, Y+7	; 0x07
    2d86:	f8 85       	ldd	r31, Y+8	; 0x08
    2d88:	13 86       	std	Z+11, r1	; 0x0b
    2d8a:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2d8c:	ce 01       	movw	r24, r28
    2d8e:	09 96       	adiw	r24, 0x09	; 9
    2d90:	9e 01       	movw	r18, r28
    2d92:	2e 5e       	subi	r18, 0xEE	; 238
    2d94:	3f 4f       	sbci	r19, 0xFF	; 255
    2d96:	b9 01       	movw	r22, r18
    2d98:	0e 94 2c 24 	call	0x4858	; 0x4858 <xTaskCheckForTimeOut>
    2d9c:	88 23       	and	r24, r24
    2d9e:	39 f2       	breq	.-114    	; 0x2d2e <xStreamBufferSend+0x6e>
    2da0:	02 c0       	rjmp	.+4      	; 0x2da6 <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    2da2:	0f 90       	pop	r0
    2da4:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    2da6:	8b 81       	ldd	r24, Y+3	; 0x03
    2da8:	9c 81       	ldd	r25, Y+4	; 0x04
    2daa:	00 97       	sbiw	r24, 0x00	; 0
    2dac:	31 f4       	brne	.+12     	; 0x2dba <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2dae:	8f 81       	ldd	r24, Y+7	; 0x07
    2db0:	98 85       	ldd	r25, Y+8	; 0x08
    2db2:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <xStreamBufferSpacesAvailable>
    2db6:	9c 83       	std	Y+4, r25	; 0x04
    2db8:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2dba:	8f 81       	ldd	r24, Y+7	; 0x07
    2dbc:	98 85       	ldd	r25, Y+8	; 0x08
    2dbe:	2e 85       	ldd	r18, Y+14	; 0x0e
    2dc0:	3f 85       	ldd	r19, Y+15	; 0x0f
    2dc2:	48 89       	ldd	r20, Y+16	; 0x10
    2dc4:	59 89       	ldd	r21, Y+17	; 0x11
    2dc6:	eb 81       	ldd	r30, Y+3	; 0x03
    2dc8:	fc 81       	ldd	r31, Y+4	; 0x04
    2dca:	a9 81       	ldd	r26, Y+1	; 0x01
    2dcc:	ba 81       	ldd	r27, Y+2	; 0x02
    2dce:	b9 01       	movw	r22, r18
    2dd0:	9f 01       	movw	r18, r30
    2dd2:	8d 01       	movw	r16, r26
    2dd4:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <prvWriteMessageToBuffer>
    2dd8:	9e 83       	std	Y+6, r25	; 0x06
    2dda:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    2ddc:	8d 81       	ldd	r24, Y+5	; 0x05
    2dde:	9e 81       	ldd	r25, Y+6	; 0x06
    2de0:	00 97       	sbiw	r24, 0x00	; 0
    2de2:	39 f1       	breq	.+78     	; 0x2e32 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2de4:	8f 81       	ldd	r24, Y+7	; 0x07
    2de6:	98 85       	ldd	r25, Y+8	; 0x08
    2de8:	0e 94 2c 1c 	call	0x3858	; 0x3858 <prvBytesInBuffer>
    2dec:	9c 01       	movw	r18, r24
    2dee:	ef 81       	ldd	r30, Y+7	; 0x07
    2df0:	f8 85       	ldd	r31, Y+8	; 0x08
    2df2:	86 81       	ldd	r24, Z+6	; 0x06
    2df4:	97 81       	ldd	r25, Z+7	; 0x07
    2df6:	28 17       	cp	r18, r24
    2df8:	39 07       	cpc	r19, r25
    2dfa:	d8 f0       	brcs	.+54     	; 0x2e32 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    2dfc:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
    2e00:	ef 81       	ldd	r30, Y+7	; 0x07
    2e02:	f8 85       	ldd	r31, Y+8	; 0x08
    2e04:	80 85       	ldd	r24, Z+8	; 0x08
    2e06:	91 85       	ldd	r25, Z+9	; 0x09
    2e08:	00 97       	sbiw	r24, 0x00	; 0
    2e0a:	89 f0       	breq	.+34     	; 0x2e2e <xStreamBufferSend+0x16e>
    2e0c:	ef 81       	ldd	r30, Y+7	; 0x07
    2e0e:	f8 85       	ldd	r31, Y+8	; 0x08
    2e10:	80 85       	ldd	r24, Z+8	; 0x08
    2e12:	91 85       	ldd	r25, Z+9	; 0x09
    2e14:	40 e0       	ldi	r20, 0x00	; 0
    2e16:	50 e0       	ldi	r21, 0x00	; 0
    2e18:	60 e0       	ldi	r22, 0x00	; 0
    2e1a:	70 e0       	ldi	r23, 0x00	; 0
    2e1c:	20 e0       	ldi	r18, 0x00	; 0
    2e1e:	00 e0       	ldi	r16, 0x00	; 0
    2e20:	10 e0       	ldi	r17, 0x00	; 0
    2e22:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <xTaskGenericNotify>
    2e26:	ef 81       	ldd	r30, Y+7	; 0x07
    2e28:	f8 85       	ldd	r31, Y+8	; 0x08
    2e2a:	11 86       	std	Z+9, r1	; 0x09
    2e2c:	10 86       	std	Z+8, r1	; 0x08
    2e2e:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2e32:	8d 81       	ldd	r24, Y+5	; 0x05
    2e34:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2e36:	63 96       	adiw	r28, 0x13	; 19
    2e38:	0f b6       	in	r0, 0x3f	; 63
    2e3a:	f8 94       	cli
    2e3c:	de bf       	out	0x3e, r29	; 62
    2e3e:	0f be       	out	0x3f, r0	; 63
    2e40:	cd bf       	out	0x3d, r28	; 61
    2e42:	cf 91       	pop	r28
    2e44:	df 91       	pop	r29
    2e46:	1f 91       	pop	r17
    2e48:	0f 91       	pop	r16
    2e4a:	ff 90       	pop	r15
    2e4c:	ef 90       	pop	r14
    2e4e:	08 95       	ret

00002e50 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2e50:	ef 92       	push	r14
    2e52:	ff 92       	push	r15
    2e54:	0f 93       	push	r16
    2e56:	1f 93       	push	r17
    2e58:	df 93       	push	r29
    2e5a:	cf 93       	push	r28
    2e5c:	cd b7       	in	r28, 0x3d	; 61
    2e5e:	de b7       	in	r29, 0x3e	; 62
    2e60:	61 97       	sbiw	r28, 0x11	; 17
    2e62:	0f b6       	in	r0, 0x3f	; 63
    2e64:	f8 94       	cli
    2e66:	de bf       	out	0x3e, r29	; 62
    2e68:	0f be       	out	0x3f, r0	; 63
    2e6a:	cd bf       	out	0x3d, r28	; 61
    2e6c:	9b 87       	std	Y+11, r25	; 0x0b
    2e6e:	8a 87       	std	Y+10, r24	; 0x0a
    2e70:	7d 87       	std	Y+13, r23	; 0x0d
    2e72:	6c 87       	std	Y+12, r22	; 0x0c
    2e74:	5f 87       	std	Y+15, r21	; 0x0f
    2e76:	4e 87       	std	Y+14, r20	; 0x0e
    2e78:	39 8b       	std	Y+17, r19	; 0x11
    2e7a:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2e7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e7e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e80:	99 87       	std	Y+9, r25	; 0x09
    2e82:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    2e84:	8e 85       	ldd	r24, Y+14	; 0x0e
    2e86:	9f 85       	ldd	r25, Y+15	; 0x0f
    2e88:	9b 83       	std	Y+3, r25	; 0x03
    2e8a:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2e8c:	e8 85       	ldd	r30, Y+8	; 0x08
    2e8e:	f9 85       	ldd	r31, Y+9	; 0x09
    2e90:	86 85       	ldd	r24, Z+14	; 0x0e
    2e92:	88 2f       	mov	r24, r24
    2e94:	90 e0       	ldi	r25, 0x00	; 0
    2e96:	81 70       	andi	r24, 0x01	; 1
    2e98:	90 70       	andi	r25, 0x00	; 0
    2e9a:	88 23       	and	r24, r24
    2e9c:	29 f0       	breq	.+10     	; 0x2ea8 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea2:	02 96       	adiw	r24, 0x02	; 2
    2ea4:	9b 83       	std	Y+3, r25	; 0x03
    2ea6:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2ea8:	88 85       	ldd	r24, Y+8	; 0x08
    2eaa:	99 85       	ldd	r25, Y+9	; 0x09
    2eac:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <xStreamBufferSpacesAvailable>
    2eb0:	9d 83       	std	Y+5, r25	; 0x05
    2eb2:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2eb4:	88 85       	ldd	r24, Y+8	; 0x08
    2eb6:	99 85       	ldd	r25, Y+9	; 0x09
    2eb8:	2c 85       	ldd	r18, Y+12	; 0x0c
    2eba:	3d 85       	ldd	r19, Y+13	; 0x0d
    2ebc:	4e 85       	ldd	r20, Y+14	; 0x0e
    2ebe:	5f 85       	ldd	r21, Y+15	; 0x0f
    2ec0:	ec 81       	ldd	r30, Y+4	; 0x04
    2ec2:	fd 81       	ldd	r31, Y+5	; 0x05
    2ec4:	aa 81       	ldd	r26, Y+2	; 0x02
    2ec6:	bb 81       	ldd	r27, Y+3	; 0x03
    2ec8:	b9 01       	movw	r22, r18
    2eca:	9f 01       	movw	r18, r30
    2ecc:	8d 01       	movw	r16, r26
    2ece:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <prvWriteMessageToBuffer>
    2ed2:	9f 83       	std	Y+7, r25	; 0x07
    2ed4:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    2ed6:	8e 81       	ldd	r24, Y+6	; 0x06
    2ed8:	9f 81       	ldd	r25, Y+7	; 0x07
    2eda:	00 97       	sbiw	r24, 0x00	; 0
    2edc:	39 f1       	breq	.+78     	; 0x2f2c <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2ede:	88 85       	ldd	r24, Y+8	; 0x08
    2ee0:	99 85       	ldd	r25, Y+9	; 0x09
    2ee2:	0e 94 2c 1c 	call	0x3858	; 0x3858 <prvBytesInBuffer>
    2ee6:	9c 01       	movw	r18, r24
    2ee8:	e8 85       	ldd	r30, Y+8	; 0x08
    2eea:	f9 85       	ldd	r31, Y+9	; 0x09
    2eec:	86 81       	ldd	r24, Z+6	; 0x06
    2eee:	97 81       	ldd	r25, Z+7	; 0x07
    2ef0:	28 17       	cp	r18, r24
    2ef2:	39 07       	cpc	r19, r25
    2ef4:	d8 f0       	brcs	.+54     	; 0x2f2c <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2ef6:	19 82       	std	Y+1, r1	; 0x01
    2ef8:	e8 85       	ldd	r30, Y+8	; 0x08
    2efa:	f9 85       	ldd	r31, Y+9	; 0x09
    2efc:	80 85       	ldd	r24, Z+8	; 0x08
    2efe:	91 85       	ldd	r25, Z+9	; 0x09
    2f00:	00 97       	sbiw	r24, 0x00	; 0
    2f02:	a1 f0       	breq	.+40     	; 0x2f2c <xStreamBufferSendFromISR+0xdc>
    2f04:	e8 85       	ldd	r30, Y+8	; 0x08
    2f06:	f9 85       	ldd	r31, Y+9	; 0x09
    2f08:	80 85       	ldd	r24, Z+8	; 0x08
    2f0a:	91 85       	ldd	r25, Z+9	; 0x09
    2f0c:	e8 89       	ldd	r30, Y+16	; 0x10
    2f0e:	f9 89       	ldd	r31, Y+17	; 0x11
    2f10:	40 e0       	ldi	r20, 0x00	; 0
    2f12:	50 e0       	ldi	r21, 0x00	; 0
    2f14:	60 e0       	ldi	r22, 0x00	; 0
    2f16:	70 e0       	ldi	r23, 0x00	; 0
    2f18:	20 e0       	ldi	r18, 0x00	; 0
    2f1a:	00 e0       	ldi	r16, 0x00	; 0
    2f1c:	10 e0       	ldi	r17, 0x00	; 0
    2f1e:	7f 01       	movw	r14, r30
    2f20:	0e 94 87 27 	call	0x4f0e	; 0x4f0e <xTaskGenericNotifyFromISR>
    2f24:	e8 85       	ldd	r30, Y+8	; 0x08
    2f26:	f9 85       	ldd	r31, Y+9	; 0x09
    2f28:	11 86       	std	Z+9, r1	; 0x09
    2f2a:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    2f2c:	8e 81       	ldd	r24, Y+6	; 0x06
    2f2e:	9f 81       	ldd	r25, Y+7	; 0x07
}
    2f30:	61 96       	adiw	r28, 0x11	; 17
    2f32:	0f b6       	in	r0, 0x3f	; 63
    2f34:	f8 94       	cli
    2f36:	de bf       	out	0x3e, r29	; 62
    2f38:	0f be       	out	0x3f, r0	; 63
    2f3a:	cd bf       	out	0x3d, r28	; 61
    2f3c:	cf 91       	pop	r28
    2f3e:	df 91       	pop	r29
    2f40:	1f 91       	pop	r17
    2f42:	0f 91       	pop	r16
    2f44:	ff 90       	pop	r15
    2f46:	ef 90       	pop	r14
    2f48:	08 95       	ret

00002f4a <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    2f4a:	0f 93       	push	r16
    2f4c:	1f 93       	push	r17
    2f4e:	df 93       	push	r29
    2f50:	cf 93       	push	r28
    2f52:	cd b7       	in	r28, 0x3d	; 61
    2f54:	de b7       	in	r29, 0x3e	; 62
    2f56:	61 97       	sbiw	r28, 0x11	; 17
    2f58:	0f b6       	in	r0, 0x3f	; 63
    2f5a:	f8 94       	cli
    2f5c:	de bf       	out	0x3e, r29	; 62
    2f5e:	0f be       	out	0x3f, r0	; 63
    2f60:	cd bf       	out	0x3d, r28	; 61
    2f62:	9d 83       	std	Y+5, r25	; 0x05
    2f64:	8c 83       	std	Y+4, r24	; 0x04
    2f66:	7f 83       	std	Y+7, r23	; 0x07
    2f68:	6e 83       	std	Y+6, r22	; 0x06
    2f6a:	59 87       	std	Y+9, r21	; 0x09
    2f6c:	48 87       	std	Y+8, r20	; 0x08
    2f6e:	3b 87       	std	Y+11, r19	; 0x0b
    2f70:	2a 87       	std	Y+10, r18	; 0x0a
    2f72:	1d 87       	std	Y+13, r17	; 0x0d
    2f74:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    2f76:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f78:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f7a:	00 97       	sbiw	r24, 0x00	; 0
    2f7c:	11 f4       	brne	.+4      	; 0x2f82 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    2f7e:	1b 82       	std	Y+3, r1	; 0x03
    2f80:	38 c0       	rjmp	.+112    	; 0x2ff2 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    2f82:	ec 81       	ldd	r30, Y+4	; 0x04
    2f84:	fd 81       	ldd	r31, Y+5	; 0x05
    2f86:	86 85       	ldd	r24, Z+14	; 0x0e
    2f88:	88 2f       	mov	r24, r24
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	81 70       	andi	r24, 0x01	; 1
    2f8e:	90 70       	andi	r25, 0x00	; 0
    2f90:	00 97       	sbiw	r24, 0x00	; 0
    2f92:	d1 f4       	brne	.+52     	; 0x2fc8 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    2f94:	81 e0       	ldi	r24, 0x01	; 1
    2f96:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    2f98:	28 85       	ldd	r18, Y+8	; 0x08
    2f9a:	39 85       	ldd	r19, Y+9	; 0x09
    2f9c:	39 8b       	std	Y+17, r19	; 0x11
    2f9e:	28 8b       	std	Y+16, r18	; 0x10
    2fa0:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fa2:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fa4:	9f 87       	std	Y+15, r25	; 0x0f
    2fa6:	8e 87       	std	Y+14, r24	; 0x0e
    2fa8:	2e 85       	ldd	r18, Y+14	; 0x0e
    2faa:	3f 85       	ldd	r19, Y+15	; 0x0f
    2fac:	88 89       	ldd	r24, Y+16	; 0x10
    2fae:	99 89       	ldd	r25, Y+17	; 0x11
    2fb0:	82 17       	cp	r24, r18
    2fb2:	93 07       	cpc	r25, r19
    2fb4:	20 f4       	brcc	.+8      	; 0x2fbe <prvWriteMessageToBuffer+0x74>
    2fb6:	28 89       	ldd	r18, Y+16	; 0x10
    2fb8:	39 89       	ldd	r19, Y+17	; 0x11
    2fba:	3f 87       	std	Y+15, r19	; 0x0f
    2fbc:	2e 87       	std	Y+14, r18	; 0x0e
    2fbe:	8e 85       	ldd	r24, Y+14	; 0x0e
    2fc0:	9f 85       	ldd	r25, Y+15	; 0x0f
    2fc2:	99 87       	std	Y+9, r25	; 0x09
    2fc4:	88 87       	std	Y+8, r24	; 0x08
    2fc6:	15 c0       	rjmp	.+42     	; 0x2ff2 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    2fc8:	2a 85       	ldd	r18, Y+10	; 0x0a
    2fca:	3b 85       	ldd	r19, Y+11	; 0x0b
    2fcc:	8c 85       	ldd	r24, Y+12	; 0x0c
    2fce:	9d 85       	ldd	r25, Y+13	; 0x0d
    2fd0:	28 17       	cp	r18, r24
    2fd2:	39 07       	cpc	r19, r25
    2fd4:	68 f0       	brcs	.+26     	; 0x2ff0 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    2fd6:	81 e0       	ldi	r24, 0x01	; 1
    2fd8:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    2fda:	9e 01       	movw	r18, r28
    2fdc:	28 5f       	subi	r18, 0xF8	; 248
    2fde:	3f 4f       	sbci	r19, 0xFF	; 255
    2fe0:	8c 81       	ldd	r24, Y+4	; 0x04
    2fe2:	9d 81       	ldd	r25, Y+5	; 0x05
    2fe4:	b9 01       	movw	r22, r18
    2fe6:	42 e0       	ldi	r20, 0x02	; 2
    2fe8:	50 e0       	ldi	r21, 0x00	; 0
    2fea:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <prvWriteBytesToBuffer>
    2fee:	01 c0       	rjmp	.+2      	; 0x2ff2 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    2ff0:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    2ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ff4:	88 23       	and	r24, r24
    2ff6:	61 f0       	breq	.+24     	; 0x3010 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    2ff8:	2e 81       	ldd	r18, Y+6	; 0x06
    2ffa:	3f 81       	ldd	r19, Y+7	; 0x07
    2ffc:	48 85       	ldd	r20, Y+8	; 0x08
    2ffe:	59 85       	ldd	r21, Y+9	; 0x09
    3000:	8c 81       	ldd	r24, Y+4	; 0x04
    3002:	9d 81       	ldd	r25, Y+5	; 0x05
    3004:	b9 01       	movw	r22, r18
    3006:	0e 94 f2 1a 	call	0x35e4	; 0x35e4 <prvWriteBytesToBuffer>
    300a:	9a 83       	std	Y+2, r25	; 0x02
    300c:	89 83       	std	Y+1, r24	; 0x01
    300e:	02 c0       	rjmp	.+4      	; 0x3014 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3010:	1a 82       	std	Y+2, r1	; 0x02
    3012:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3014:	89 81       	ldd	r24, Y+1	; 0x01
    3016:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3018:	61 96       	adiw	r28, 0x11	; 17
    301a:	0f b6       	in	r0, 0x3f	; 63
    301c:	f8 94       	cli
    301e:	de bf       	out	0x3e, r29	; 62
    3020:	0f be       	out	0x3f, r0	; 63
    3022:	cd bf       	out	0x3d, r28	; 61
    3024:	cf 91       	pop	r28
    3026:	df 91       	pop	r29
    3028:	1f 91       	pop	r17
    302a:	0f 91       	pop	r16
    302c:	08 95       	ret

0000302e <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    302e:	ef 92       	push	r14
    3030:	ff 92       	push	r15
    3032:	0f 93       	push	r16
    3034:	1f 93       	push	r17
    3036:	df 93       	push	r29
    3038:	cf 93       	push	r28
    303a:	cd b7       	in	r28, 0x3d	; 61
    303c:	de b7       	in	r29, 0x3e	; 62
    303e:	60 97       	sbiw	r28, 0x10	; 16
    3040:	0f b6       	in	r0, 0x3f	; 63
    3042:	f8 94       	cli
    3044:	de bf       	out	0x3e, r29	; 62
    3046:	0f be       	out	0x3f, r0	; 63
    3048:	cd bf       	out	0x3d, r28	; 61
    304a:	9a 87       	std	Y+10, r25	; 0x0a
    304c:	89 87       	std	Y+9, r24	; 0x09
    304e:	7c 87       	std	Y+12, r23	; 0x0c
    3050:	6b 87       	std	Y+11, r22	; 0x0b
    3052:	5e 87       	std	Y+14, r21	; 0x0e
    3054:	4d 87       	std	Y+13, r20	; 0x0d
    3056:	38 8b       	std	Y+16, r19	; 0x10
    3058:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    305a:	89 85       	ldd	r24, Y+9	; 0x09
    305c:	9a 85       	ldd	r25, Y+10	; 0x0a
    305e:	98 87       	std	Y+8, r25	; 0x08
    3060:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3062:	1e 82       	std	Y+6, r1	; 0x06
    3064:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3066:	ef 81       	ldd	r30, Y+7	; 0x07
    3068:	f8 85       	ldd	r31, Y+8	; 0x08
    306a:	86 85       	ldd	r24, Z+14	; 0x0e
    306c:	88 2f       	mov	r24, r24
    306e:	90 e0       	ldi	r25, 0x00	; 0
    3070:	81 70       	andi	r24, 0x01	; 1
    3072:	90 70       	andi	r25, 0x00	; 0
    3074:	88 23       	and	r24, r24
    3076:	29 f0       	breq	.+10     	; 0x3082 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3078:	82 e0       	ldi	r24, 0x02	; 2
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	9a 83       	std	Y+2, r25	; 0x02
    307e:	89 83       	std	Y+1, r24	; 0x01
    3080:	02 c0       	rjmp	.+4      	; 0x3086 <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3082:	1a 82       	std	Y+2, r1	; 0x02
    3084:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3086:	8f 85       	ldd	r24, Y+15	; 0x0f
    3088:	98 89       	ldd	r25, Y+16	; 0x10
    308a:	00 97       	sbiw	r24, 0x00	; 0
    308c:	09 f4       	brne	.+2      	; 0x3090 <xStreamBufferReceive+0x62>
    308e:	3d c0       	rjmp	.+122    	; 0x310a <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3090:	0f b6       	in	r0, 0x3f	; 63
    3092:	f8 94       	cli
    3094:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3096:	8f 81       	ldd	r24, Y+7	; 0x07
    3098:	98 85       	ldd	r25, Y+8	; 0x08
    309a:	0e 94 2c 1c 	call	0x3858	; 0x3858 <prvBytesInBuffer>
    309e:	9c 83       	std	Y+4, r25	; 0x04
    30a0:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    30a2:	2b 81       	ldd	r18, Y+3	; 0x03
    30a4:	3c 81       	ldd	r19, Y+4	; 0x04
    30a6:	89 81       	ldd	r24, Y+1	; 0x01
    30a8:	9a 81       	ldd	r25, Y+2	; 0x02
    30aa:	82 17       	cp	r24, r18
    30ac:	93 07       	cpc	r25, r19
    30ae:	50 f0       	brcs	.+20     	; 0x30c4 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    30b0:	80 e0       	ldi	r24, 0x00	; 0
    30b2:	90 e0       	ldi	r25, 0x00	; 0
    30b4:	0e 94 05 29 	call	0x520a	; 0x520a <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    30b8:	0e 94 5e 25 	call	0x4abc	; 0x4abc <xTaskGetCurrentTaskHandle>
    30bc:	ef 81       	ldd	r30, Y+7	; 0x07
    30be:	f8 85       	ldd	r31, Y+8	; 0x08
    30c0:	91 87       	std	Z+9, r25	; 0x09
    30c2:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    30c4:	0f 90       	pop	r0
    30c6:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    30c8:	2b 81       	ldd	r18, Y+3	; 0x03
    30ca:	3c 81       	ldd	r19, Y+4	; 0x04
    30cc:	89 81       	ldd	r24, Y+1	; 0x01
    30ce:	9a 81       	ldd	r25, Y+2	; 0x02
    30d0:	82 17       	cp	r24, r18
    30d2:	93 07       	cpc	r25, r19
    30d4:	00 f1       	brcs	.+64     	; 0x3116 <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    30d6:	ef 85       	ldd	r30, Y+15	; 0x0f
    30d8:	f8 89       	ldd	r31, Y+16	; 0x10
    30da:	60 e0       	ldi	r22, 0x00	; 0
    30dc:	70 e0       	ldi	r23, 0x00	; 0
    30de:	80 e0       	ldi	r24, 0x00	; 0
    30e0:	90 e0       	ldi	r25, 0x00	; 0
    30e2:	20 e0       	ldi	r18, 0x00	; 0
    30e4:	30 e0       	ldi	r19, 0x00	; 0
    30e6:	40 e0       	ldi	r20, 0x00	; 0
    30e8:	50 e0       	ldi	r21, 0x00	; 0
    30ea:	00 e0       	ldi	r16, 0x00	; 0
    30ec:	10 e0       	ldi	r17, 0x00	; 0
    30ee:	7f 01       	movw	r14, r30
    30f0:	0e 94 0e 26 	call	0x4c1c	; 0x4c1c <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    30f4:	ef 81       	ldd	r30, Y+7	; 0x07
    30f6:	f8 85       	ldd	r31, Y+8	; 0x08
    30f8:	11 86       	std	Z+9, r1	; 0x09
    30fa:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    30fc:	8f 81       	ldd	r24, Y+7	; 0x07
    30fe:	98 85       	ldd	r25, Y+8	; 0x08
    3100:	0e 94 2c 1c 	call	0x3858	; 0x3858 <prvBytesInBuffer>
    3104:	9c 83       	std	Y+4, r25	; 0x04
    3106:	8b 83       	std	Y+3, r24	; 0x03
    3108:	06 c0       	rjmp	.+12     	; 0x3116 <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    310a:	8f 81       	ldd	r24, Y+7	; 0x07
    310c:	98 85       	ldd	r25, Y+8	; 0x08
    310e:	0e 94 2c 1c 	call	0x3858	; 0x3858 <prvBytesInBuffer>
    3112:	9c 83       	std	Y+4, r25	; 0x04
    3114:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3116:	2b 81       	ldd	r18, Y+3	; 0x03
    3118:	3c 81       	ldd	r19, Y+4	; 0x04
    311a:	89 81       	ldd	r24, Y+1	; 0x01
    311c:	9a 81       	ldd	r25, Y+2	; 0x02
    311e:	82 17       	cp	r24, r18
    3120:	93 07       	cpc	r25, r19
    3122:	80 f5       	brcc	.+96     	; 0x3184 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3124:	8f 81       	ldd	r24, Y+7	; 0x07
    3126:	98 85       	ldd	r25, Y+8	; 0x08
    3128:	2b 85       	ldd	r18, Y+11	; 0x0b
    312a:	3c 85       	ldd	r19, Y+12	; 0x0c
    312c:	4d 85       	ldd	r20, Y+13	; 0x0d
    312e:	5e 85       	ldd	r21, Y+14	; 0x0e
    3130:	eb 81       	ldd	r30, Y+3	; 0x03
    3132:	fc 81       	ldd	r31, Y+4	; 0x04
    3134:	a9 81       	ldd	r26, Y+1	; 0x01
    3136:	ba 81       	ldd	r27, Y+2	; 0x02
    3138:	b9 01       	movw	r22, r18
    313a:	9f 01       	movw	r18, r30
    313c:	8d 01       	movw	r16, r26
    313e:	0e 94 9b 19 	call	0x3336	; 0x3336 <prvReadMessageFromBuffer>
    3142:	9e 83       	std	Y+6, r25	; 0x06
    3144:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    3146:	8d 81       	ldd	r24, Y+5	; 0x05
    3148:	9e 81       	ldd	r25, Y+6	; 0x06
    314a:	00 97       	sbiw	r24, 0x00	; 0
    314c:	d9 f0       	breq	.+54     	; 0x3184 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    314e:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
    3152:	ef 81       	ldd	r30, Y+7	; 0x07
    3154:	f8 85       	ldd	r31, Y+8	; 0x08
    3156:	82 85       	ldd	r24, Z+10	; 0x0a
    3158:	93 85       	ldd	r25, Z+11	; 0x0b
    315a:	00 97       	sbiw	r24, 0x00	; 0
    315c:	89 f0       	breq	.+34     	; 0x3180 <xStreamBufferReceive+0x152>
    315e:	ef 81       	ldd	r30, Y+7	; 0x07
    3160:	f8 85       	ldd	r31, Y+8	; 0x08
    3162:	82 85       	ldd	r24, Z+10	; 0x0a
    3164:	93 85       	ldd	r25, Z+11	; 0x0b
    3166:	40 e0       	ldi	r20, 0x00	; 0
    3168:	50 e0       	ldi	r21, 0x00	; 0
    316a:	60 e0       	ldi	r22, 0x00	; 0
    316c:	70 e0       	ldi	r23, 0x00	; 0
    316e:	20 e0       	ldi	r18, 0x00	; 0
    3170:	00 e0       	ldi	r16, 0x00	; 0
    3172:	10 e0       	ldi	r17, 0x00	; 0
    3174:	0e 94 aa 26 	call	0x4d54	; 0x4d54 <xTaskGenericNotify>
    3178:	ef 81       	ldd	r30, Y+7	; 0x07
    317a:	f8 85       	ldd	r31, Y+8	; 0x08
    317c:	13 86       	std	Z+11, r1	; 0x0b
    317e:	12 86       	std	Z+10, r1	; 0x0a
    3180:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    3184:	8d 81       	ldd	r24, Y+5	; 0x05
    3186:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3188:	60 96       	adiw	r28, 0x10	; 16
    318a:	0f b6       	in	r0, 0x3f	; 63
    318c:	f8 94       	cli
    318e:	de bf       	out	0x3e, r29	; 62
    3190:	0f be       	out	0x3f, r0	; 63
    3192:	cd bf       	out	0x3d, r28	; 61
    3194:	cf 91       	pop	r28
    3196:	df 91       	pop	r29
    3198:	1f 91       	pop	r17
    319a:	0f 91       	pop	r16
    319c:	ff 90       	pop	r15
    319e:	ef 90       	pop	r14
    31a0:	08 95       	ret

000031a2 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    31a2:	df 93       	push	r29
    31a4:	cf 93       	push	r28
    31a6:	cd b7       	in	r28, 0x3d	; 61
    31a8:	de b7       	in	r29, 0x3e	; 62
    31aa:	2c 97       	sbiw	r28, 0x0c	; 12
    31ac:	0f b6       	in	r0, 0x3f	; 63
    31ae:	f8 94       	cli
    31b0:	de bf       	out	0x3e, r29	; 62
    31b2:	0f be       	out	0x3f, r0	; 63
    31b4:	cd bf       	out	0x3d, r28	; 61
    31b6:	9c 87       	std	Y+12, r25	; 0x0c
    31b8:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    31ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    31bc:	9c 85       	ldd	r25, Y+12	; 0x0c
    31be:	98 87       	std	Y+8, r25	; 0x08
    31c0:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    31c2:	ef 81       	ldd	r30, Y+7	; 0x07
    31c4:	f8 85       	ldd	r31, Y+8	; 0x08
    31c6:	86 85       	ldd	r24, Z+14	; 0x0e
    31c8:	88 2f       	mov	r24, r24
    31ca:	90 e0       	ldi	r25, 0x00	; 0
    31cc:	81 70       	andi	r24, 0x01	; 1
    31ce:	90 70       	andi	r25, 0x00	; 0
    31d0:	88 23       	and	r24, r24
    31d2:	61 f1       	breq	.+88     	; 0x322c <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    31d4:	8f 81       	ldd	r24, Y+7	; 0x07
    31d6:	98 85       	ldd	r25, Y+8	; 0x08
    31d8:	0e 94 2c 1c 	call	0x3858	; 0x3858 <prvBytesInBuffer>
    31dc:	9c 83       	std	Y+4, r25	; 0x04
    31de:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    31e0:	8b 81       	ldd	r24, Y+3	; 0x03
    31e2:	9c 81       	ldd	r25, Y+4	; 0x04
    31e4:	83 30       	cpi	r24, 0x03	; 3
    31e6:	91 05       	cpc	r25, r1
    31e8:	f0 f0       	brcs	.+60     	; 0x3226 <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    31ea:	ef 81       	ldd	r30, Y+7	; 0x07
    31ec:	f8 85       	ldd	r31, Y+8	; 0x08
    31ee:	80 81       	ld	r24, Z
    31f0:	91 81       	ldd	r25, Z+1	; 0x01
    31f2:	9a 83       	std	Y+2, r25	; 0x02
    31f4:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    31f6:	9e 01       	movw	r18, r28
    31f8:	27 5f       	subi	r18, 0xF7	; 247
    31fa:	3f 4f       	sbci	r19, 0xFF	; 255
    31fc:	8f 81       	ldd	r24, Y+7	; 0x07
    31fe:	98 85       	ldd	r25, Y+8	; 0x08
    3200:	eb 81       	ldd	r30, Y+3	; 0x03
    3202:	fc 81       	ldd	r31, Y+4	; 0x04
    3204:	b9 01       	movw	r22, r18
    3206:	42 e0       	ldi	r20, 0x02	; 2
    3208:	50 e0       	ldi	r21, 0x00	; 0
    320a:	9f 01       	movw	r18, r30
    320c:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3210:	89 85       	ldd	r24, Y+9	; 0x09
    3212:	9a 85       	ldd	r25, Y+10	; 0x0a
    3214:	9e 83       	std	Y+6, r25	; 0x06
    3216:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    3218:	ef 81       	ldd	r30, Y+7	; 0x07
    321a:	f8 85       	ldd	r31, Y+8	; 0x08
    321c:	89 81       	ldd	r24, Y+1	; 0x01
    321e:	9a 81       	ldd	r25, Y+2	; 0x02
    3220:	91 83       	std	Z+1, r25	; 0x01
    3222:	80 83       	st	Z, r24
    3224:	05 c0       	rjmp	.+10     	; 0x3230 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    3226:	1e 82       	std	Y+6, r1	; 0x06
    3228:	1d 82       	std	Y+5, r1	; 0x05
    322a:	02 c0       	rjmp	.+4      	; 0x3230 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    322c:	1e 82       	std	Y+6, r1	; 0x06
    322e:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3230:	8d 81       	ldd	r24, Y+5	; 0x05
    3232:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3234:	2c 96       	adiw	r28, 0x0c	; 12
    3236:	0f b6       	in	r0, 0x3f	; 63
    3238:	f8 94       	cli
    323a:	de bf       	out	0x3e, r29	; 62
    323c:	0f be       	out	0x3f, r0	; 63
    323e:	cd bf       	out	0x3d, r28	; 61
    3240:	cf 91       	pop	r28
    3242:	df 91       	pop	r29
    3244:	08 95       	ret

00003246 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    3246:	ef 92       	push	r14
    3248:	ff 92       	push	r15
    324a:	0f 93       	push	r16
    324c:	1f 93       	push	r17
    324e:	df 93       	push	r29
    3250:	cf 93       	push	r28
    3252:	cd b7       	in	r28, 0x3d	; 61
    3254:	de b7       	in	r29, 0x3e	; 62
    3256:	61 97       	sbiw	r28, 0x11	; 17
    3258:	0f b6       	in	r0, 0x3f	; 63
    325a:	f8 94       	cli
    325c:	de bf       	out	0x3e, r29	; 62
    325e:	0f be       	out	0x3f, r0	; 63
    3260:	cd bf       	out	0x3d, r28	; 61
    3262:	9b 87       	std	Y+11, r25	; 0x0b
    3264:	8a 87       	std	Y+10, r24	; 0x0a
    3266:	7d 87       	std	Y+13, r23	; 0x0d
    3268:	6c 87       	std	Y+12, r22	; 0x0c
    326a:	5f 87       	std	Y+15, r21	; 0x0f
    326c:	4e 87       	std	Y+14, r20	; 0x0e
    326e:	39 8b       	std	Y+17, r19	; 0x11
    3270:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3272:	8a 85       	ldd	r24, Y+10	; 0x0a
    3274:	9b 85       	ldd	r25, Y+11	; 0x0b
    3276:	99 87       	std	Y+9, r25	; 0x09
    3278:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    327a:	1f 82       	std	Y+7, r1	; 0x07
    327c:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    327e:	e8 85       	ldd	r30, Y+8	; 0x08
    3280:	f9 85       	ldd	r31, Y+9	; 0x09
    3282:	86 85       	ldd	r24, Z+14	; 0x0e
    3284:	88 2f       	mov	r24, r24
    3286:	90 e0       	ldi	r25, 0x00	; 0
    3288:	81 70       	andi	r24, 0x01	; 1
    328a:	90 70       	andi	r25, 0x00	; 0
    328c:	88 23       	and	r24, r24
    328e:	29 f0       	breq	.+10     	; 0x329a <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3290:	82 e0       	ldi	r24, 0x02	; 2
    3292:	90 e0       	ldi	r25, 0x00	; 0
    3294:	9b 83       	std	Y+3, r25	; 0x03
    3296:	8a 83       	std	Y+2, r24	; 0x02
    3298:	02 c0       	rjmp	.+4      	; 0x329e <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    329a:	1b 82       	std	Y+3, r1	; 0x03
    329c:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    329e:	88 85       	ldd	r24, Y+8	; 0x08
    32a0:	99 85       	ldd	r25, Y+9	; 0x09
    32a2:	0e 94 2c 1c 	call	0x3858	; 0x3858 <prvBytesInBuffer>
    32a6:	9d 83       	std	Y+5, r25	; 0x05
    32a8:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    32aa:	2c 81       	ldd	r18, Y+4	; 0x04
    32ac:	3d 81       	ldd	r19, Y+5	; 0x05
    32ae:	8a 81       	ldd	r24, Y+2	; 0x02
    32b0:	9b 81       	ldd	r25, Y+3	; 0x03
    32b2:	82 17       	cp	r24, r18
    32b4:	93 07       	cpc	r25, r19
    32b6:	80 f5       	brcc	.+96     	; 0x3318 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    32b8:	88 85       	ldd	r24, Y+8	; 0x08
    32ba:	99 85       	ldd	r25, Y+9	; 0x09
    32bc:	2c 85       	ldd	r18, Y+12	; 0x0c
    32be:	3d 85       	ldd	r19, Y+13	; 0x0d
    32c0:	4e 85       	ldd	r20, Y+14	; 0x0e
    32c2:	5f 85       	ldd	r21, Y+15	; 0x0f
    32c4:	ec 81       	ldd	r30, Y+4	; 0x04
    32c6:	fd 81       	ldd	r31, Y+5	; 0x05
    32c8:	aa 81       	ldd	r26, Y+2	; 0x02
    32ca:	bb 81       	ldd	r27, Y+3	; 0x03
    32cc:	b9 01       	movw	r22, r18
    32ce:	9f 01       	movw	r18, r30
    32d0:	8d 01       	movw	r16, r26
    32d2:	0e 94 9b 19 	call	0x3336	; 0x3336 <prvReadMessageFromBuffer>
    32d6:	9f 83       	std	Y+7, r25	; 0x07
    32d8:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    32da:	8e 81       	ldd	r24, Y+6	; 0x06
    32dc:	9f 81       	ldd	r25, Y+7	; 0x07
    32de:	00 97       	sbiw	r24, 0x00	; 0
    32e0:	d9 f0       	breq	.+54     	; 0x3318 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    32e2:	19 82       	std	Y+1, r1	; 0x01
    32e4:	e8 85       	ldd	r30, Y+8	; 0x08
    32e6:	f9 85       	ldd	r31, Y+9	; 0x09
    32e8:	82 85       	ldd	r24, Z+10	; 0x0a
    32ea:	93 85       	ldd	r25, Z+11	; 0x0b
    32ec:	00 97       	sbiw	r24, 0x00	; 0
    32ee:	a1 f0       	breq	.+40     	; 0x3318 <xStreamBufferReceiveFromISR+0xd2>
    32f0:	e8 85       	ldd	r30, Y+8	; 0x08
    32f2:	f9 85       	ldd	r31, Y+9	; 0x09
    32f4:	82 85       	ldd	r24, Z+10	; 0x0a
    32f6:	93 85       	ldd	r25, Z+11	; 0x0b
    32f8:	e8 89       	ldd	r30, Y+16	; 0x10
    32fa:	f9 89       	ldd	r31, Y+17	; 0x11
    32fc:	40 e0       	ldi	r20, 0x00	; 0
    32fe:	50 e0       	ldi	r21, 0x00	; 0
    3300:	60 e0       	ldi	r22, 0x00	; 0
    3302:	70 e0       	ldi	r23, 0x00	; 0
    3304:	20 e0       	ldi	r18, 0x00	; 0
    3306:	00 e0       	ldi	r16, 0x00	; 0
    3308:	10 e0       	ldi	r17, 0x00	; 0
    330a:	7f 01       	movw	r14, r30
    330c:	0e 94 87 27 	call	0x4f0e	; 0x4f0e <xTaskGenericNotifyFromISR>
    3310:	e8 85       	ldd	r30, Y+8	; 0x08
    3312:	f9 85       	ldd	r31, Y+9	; 0x09
    3314:	13 86       	std	Z+11, r1	; 0x0b
    3316:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    3318:	8e 81       	ldd	r24, Y+6	; 0x06
    331a:	9f 81       	ldd	r25, Y+7	; 0x07
}
    331c:	61 96       	adiw	r28, 0x11	; 17
    331e:	0f b6       	in	r0, 0x3f	; 63
    3320:	f8 94       	cli
    3322:	de bf       	out	0x3e, r29	; 62
    3324:	0f be       	out	0x3f, r0	; 63
    3326:	cd bf       	out	0x3d, r28	; 61
    3328:	cf 91       	pop	r28
    332a:	df 91       	pop	r29
    332c:	1f 91       	pop	r17
    332e:	0f 91       	pop	r16
    3330:	ff 90       	pop	r15
    3332:	ef 90       	pop	r14
    3334:	08 95       	ret

00003336 <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    3336:	0f 93       	push	r16
    3338:	1f 93       	push	r17
    333a:	df 93       	push	r29
    333c:	cf 93       	push	r28
    333e:	cd b7       	in	r28, 0x3d	; 61
    3340:	de b7       	in	r29, 0x3e	; 62
    3342:	62 97       	sbiw	r28, 0x12	; 18
    3344:	0f b6       	in	r0, 0x3f	; 63
    3346:	f8 94       	cli
    3348:	de bf       	out	0x3e, r29	; 62
    334a:	0f be       	out	0x3f, r0	; 63
    334c:	cd bf       	out	0x3d, r28	; 61
    334e:	9a 87       	std	Y+10, r25	; 0x0a
    3350:	89 87       	std	Y+9, r24	; 0x09
    3352:	7c 87       	std	Y+12, r23	; 0x0c
    3354:	6b 87       	std	Y+11, r22	; 0x0b
    3356:	5e 87       	std	Y+14, r21	; 0x0e
    3358:	4d 87       	std	Y+13, r20	; 0x0d
    335a:	38 8b       	std	Y+16, r19	; 0x10
    335c:	2f 87       	std	Y+15, r18	; 0x0f
    335e:	1a 8b       	std	Y+18, r17	; 0x12
    3360:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    3362:	89 89       	ldd	r24, Y+17	; 0x11
    3364:	9a 89       	ldd	r25, Y+18	; 0x12
    3366:	00 97       	sbiw	r24, 0x00	; 0
    3368:	91 f1       	breq	.+100    	; 0x33ce <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    336a:	e9 85       	ldd	r30, Y+9	; 0x09
    336c:	fa 85       	ldd	r31, Y+10	; 0x0a
    336e:	80 81       	ld	r24, Z
    3370:	91 81       	ldd	r25, Z+1	; 0x01
    3372:	9e 83       	std	Y+6, r25	; 0x06
    3374:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    3376:	ae 01       	movw	r20, r28
    3378:	49 5f       	subi	r20, 0xF9	; 249
    337a:	5f 4f       	sbci	r21, 0xFF	; 255
    337c:	89 85       	ldd	r24, Y+9	; 0x09
    337e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3380:	29 89       	ldd	r18, Y+17	; 0x11
    3382:	3a 89       	ldd	r19, Y+18	; 0x12
    3384:	ef 85       	ldd	r30, Y+15	; 0x0f
    3386:	f8 89       	ldd	r31, Y+16	; 0x10
    3388:	ba 01       	movw	r22, r20
    338a:	a9 01       	movw	r20, r18
    338c:	9f 01       	movw	r18, r30
    338e:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    3392:	8f 81       	ldd	r24, Y+7	; 0x07
    3394:	98 85       	ldd	r25, Y+8	; 0x08
    3396:	9a 83       	std	Y+2, r25	; 0x02
    3398:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    339a:	2f 85       	ldd	r18, Y+15	; 0x0f
    339c:	38 89       	ldd	r19, Y+16	; 0x10
    339e:	89 89       	ldd	r24, Y+17	; 0x11
    33a0:	9a 89       	ldd	r25, Y+18	; 0x12
    33a2:	a9 01       	movw	r20, r18
    33a4:	48 1b       	sub	r20, r24
    33a6:	59 0b       	sbc	r21, r25
    33a8:	ca 01       	movw	r24, r20
    33aa:	98 8b       	std	Y+16, r25	; 0x10
    33ac:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    33ae:	29 81       	ldd	r18, Y+1	; 0x01
    33b0:	3a 81       	ldd	r19, Y+2	; 0x02
    33b2:	8d 85       	ldd	r24, Y+13	; 0x0d
    33b4:	9e 85       	ldd	r25, Y+14	; 0x0e
    33b6:	82 17       	cp	r24, r18
    33b8:	93 07       	cpc	r25, r19
    33ba:	68 f4       	brcc	.+26     	; 0x33d6 <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    33bc:	e9 85       	ldd	r30, Y+9	; 0x09
    33be:	fa 85       	ldd	r31, Y+10	; 0x0a
    33c0:	8d 81       	ldd	r24, Y+5	; 0x05
    33c2:	9e 81       	ldd	r25, Y+6	; 0x06
    33c4:	91 83       	std	Z+1, r25	; 0x01
    33c6:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    33c8:	1a 82       	std	Y+2, r1	; 0x02
    33ca:	19 82       	std	Y+1, r1	; 0x01
    33cc:	04 c0       	rjmp	.+8      	; 0x33d6 <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    33ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    33d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    33d2:	9a 83       	std	Y+2, r25	; 0x02
    33d4:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    33d6:	4b 85       	ldd	r20, Y+11	; 0x0b
    33d8:	5c 85       	ldd	r21, Y+12	; 0x0c
    33da:	89 85       	ldd	r24, Y+9	; 0x09
    33dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    33de:	29 81       	ldd	r18, Y+1	; 0x01
    33e0:	3a 81       	ldd	r19, Y+2	; 0x02
    33e2:	ef 85       	ldd	r30, Y+15	; 0x0f
    33e4:	f8 89       	ldd	r31, Y+16	; 0x10
    33e6:	ba 01       	movw	r22, r20
    33e8:	a9 01       	movw	r20, r18
    33ea:	9f 01       	movw	r18, r30
    33ec:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <prvReadBytesFromBuffer>
    33f0:	9c 83       	std	Y+4, r25	; 0x04
    33f2:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    33f4:	8b 81       	ldd	r24, Y+3	; 0x03
    33f6:	9c 81       	ldd	r25, Y+4	; 0x04
}
    33f8:	62 96       	adiw	r28, 0x12	; 18
    33fa:	0f b6       	in	r0, 0x3f	; 63
    33fc:	f8 94       	cli
    33fe:	de bf       	out	0x3e, r29	; 62
    3400:	0f be       	out	0x3f, r0	; 63
    3402:	cd bf       	out	0x3d, r28	; 61
    3404:	cf 91       	pop	r28
    3406:	df 91       	pop	r29
    3408:	1f 91       	pop	r17
    340a:	0f 91       	pop	r16
    340c:	08 95       	ret

0000340e <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    340e:	df 93       	push	r29
    3410:	cf 93       	push	r28
    3412:	cd b7       	in	r28, 0x3d	; 61
    3414:	de b7       	in	r29, 0x3e	; 62
    3416:	27 97       	sbiw	r28, 0x07	; 7
    3418:	0f b6       	in	r0, 0x3f	; 63
    341a:	f8 94       	cli
    341c:	de bf       	out	0x3e, r29	; 62
    341e:	0f be       	out	0x3f, r0	; 63
    3420:	cd bf       	out	0x3d, r28	; 61
    3422:	9f 83       	std	Y+7, r25	; 0x07
    3424:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3426:	8e 81       	ldd	r24, Y+6	; 0x06
    3428:	9f 81       	ldd	r25, Y+7	; 0x07
    342a:	9d 83       	std	Y+5, r25	; 0x05
    342c:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    342e:	ec 81       	ldd	r30, Y+4	; 0x04
    3430:	fd 81       	ldd	r31, Y+5	; 0x05
    3432:	80 81       	ld	r24, Z
    3434:	91 81       	ldd	r25, Z+1	; 0x01
    3436:	9a 83       	std	Y+2, r25	; 0x02
    3438:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    343a:	ec 81       	ldd	r30, Y+4	; 0x04
    343c:	fd 81       	ldd	r31, Y+5	; 0x05
    343e:	22 81       	ldd	r18, Z+2	; 0x02
    3440:	33 81       	ldd	r19, Z+3	; 0x03
    3442:	89 81       	ldd	r24, Y+1	; 0x01
    3444:	9a 81       	ldd	r25, Y+2	; 0x02
    3446:	28 17       	cp	r18, r24
    3448:	39 07       	cpc	r19, r25
    344a:	19 f4       	brne	.+6      	; 0x3452 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    344c:	81 e0       	ldi	r24, 0x01	; 1
    344e:	8b 83       	std	Y+3, r24	; 0x03
    3450:	01 c0       	rjmp	.+2      	; 0x3454 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    3452:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3454:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3456:	27 96       	adiw	r28, 0x07	; 7
    3458:	0f b6       	in	r0, 0x3f	; 63
    345a:	f8 94       	cli
    345c:	de bf       	out	0x3e, r29	; 62
    345e:	0f be       	out	0x3f, r0	; 63
    3460:	cd bf       	out	0x3d, r28	; 61
    3462:	cf 91       	pop	r28
    3464:	df 91       	pop	r29
    3466:	08 95       	ret

00003468 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    3468:	df 93       	push	r29
    346a:	cf 93       	push	r28
    346c:	cd b7       	in	r28, 0x3d	; 61
    346e:	de b7       	in	r29, 0x3e	; 62
    3470:	27 97       	sbiw	r28, 0x07	; 7
    3472:	0f b6       	in	r0, 0x3f	; 63
    3474:	f8 94       	cli
    3476:	de bf       	out	0x3e, r29	; 62
    3478:	0f be       	out	0x3f, r0	; 63
    347a:	cd bf       	out	0x3d, r28	; 61
    347c:	9f 83       	std	Y+7, r25	; 0x07
    347e:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3480:	8e 81       	ldd	r24, Y+6	; 0x06
    3482:	9f 81       	ldd	r25, Y+7	; 0x07
    3484:	9a 83       	std	Y+2, r25	; 0x02
    3486:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3488:	e9 81       	ldd	r30, Y+1	; 0x01
    348a:	fa 81       	ldd	r31, Y+2	; 0x02
    348c:	86 85       	ldd	r24, Z+14	; 0x0e
    348e:	88 2f       	mov	r24, r24
    3490:	90 e0       	ldi	r25, 0x00	; 0
    3492:	81 70       	andi	r24, 0x01	; 1
    3494:	90 70       	andi	r25, 0x00	; 0
    3496:	88 23       	and	r24, r24
    3498:	29 f0       	breq	.+10     	; 0x34a4 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    349a:	82 e0       	ldi	r24, 0x02	; 2
    349c:	90 e0       	ldi	r25, 0x00	; 0
    349e:	9c 83       	std	Y+4, r25	; 0x04
    34a0:	8b 83       	std	Y+3, r24	; 0x03
    34a2:	02 c0       	rjmp	.+4      	; 0x34a8 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    34a4:	1c 82       	std	Y+4, r1	; 0x04
    34a6:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    34a8:	8e 81       	ldd	r24, Y+6	; 0x06
    34aa:	9f 81       	ldd	r25, Y+7	; 0x07
    34ac:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <xStreamBufferSpacesAvailable>
    34b0:	9c 01       	movw	r18, r24
    34b2:	8b 81       	ldd	r24, Y+3	; 0x03
    34b4:	9c 81       	ldd	r25, Y+4	; 0x04
    34b6:	82 17       	cp	r24, r18
    34b8:	93 07       	cpc	r25, r19
    34ba:	18 f0       	brcs	.+6      	; 0x34c2 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    34bc:	81 e0       	ldi	r24, 0x01	; 1
    34be:	8d 83       	std	Y+5, r24	; 0x05
    34c0:	01 c0       	rjmp	.+2      	; 0x34c4 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    34c2:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    34c4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    34c6:	27 96       	adiw	r28, 0x07	; 7
    34c8:	0f b6       	in	r0, 0x3f	; 63
    34ca:	f8 94       	cli
    34cc:	de bf       	out	0x3e, r29	; 62
    34ce:	0f be       	out	0x3f, r0	; 63
    34d0:	cd bf       	out	0x3d, r28	; 61
    34d2:	cf 91       	pop	r28
    34d4:	df 91       	pop	r29
    34d6:	08 95       	ret

000034d8 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    34d8:	ef 92       	push	r14
    34da:	ff 92       	push	r15
    34dc:	0f 93       	push	r16
    34de:	1f 93       	push	r17
    34e0:	df 93       	push	r29
    34e2:	cf 93       	push	r28
    34e4:	cd b7       	in	r28, 0x3d	; 61
    34e6:	de b7       	in	r29, 0x3e	; 62
    34e8:	28 97       	sbiw	r28, 0x08	; 8
    34ea:	0f b6       	in	r0, 0x3f	; 63
    34ec:	f8 94       	cli
    34ee:	de bf       	out	0x3e, r29	; 62
    34f0:	0f be       	out	0x3f, r0	; 63
    34f2:	cd bf       	out	0x3d, r28	; 61
    34f4:	9e 83       	std	Y+6, r25	; 0x06
    34f6:	8d 83       	std	Y+5, r24	; 0x05
    34f8:	78 87       	std	Y+8, r23	; 0x08
    34fa:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    34fc:	8d 81       	ldd	r24, Y+5	; 0x05
    34fe:	9e 81       	ldd	r25, Y+6	; 0x06
    3500:	9c 83       	std	Y+4, r25	; 0x04
    3502:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3504:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    3506:	eb 81       	ldd	r30, Y+3	; 0x03
    3508:	fc 81       	ldd	r31, Y+4	; 0x04
    350a:	80 85       	ldd	r24, Z+8	; 0x08
    350c:	91 85       	ldd	r25, Z+9	; 0x09
    350e:	00 97       	sbiw	r24, 0x00	; 0
    3510:	b9 f0       	breq	.+46     	; 0x3540 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    3512:	eb 81       	ldd	r30, Y+3	; 0x03
    3514:	fc 81       	ldd	r31, Y+4	; 0x04
    3516:	80 85       	ldd	r24, Z+8	; 0x08
    3518:	91 85       	ldd	r25, Z+9	; 0x09
    351a:	ef 81       	ldd	r30, Y+7	; 0x07
    351c:	f8 85       	ldd	r31, Y+8	; 0x08
    351e:	40 e0       	ldi	r20, 0x00	; 0
    3520:	50 e0       	ldi	r21, 0x00	; 0
    3522:	60 e0       	ldi	r22, 0x00	; 0
    3524:	70 e0       	ldi	r23, 0x00	; 0
    3526:	20 e0       	ldi	r18, 0x00	; 0
    3528:	00 e0       	ldi	r16, 0x00	; 0
    352a:	10 e0       	ldi	r17, 0x00	; 0
    352c:	7f 01       	movw	r14, r30
    352e:	0e 94 87 27 	call	0x4f0e	; 0x4f0e <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    3532:	eb 81       	ldd	r30, Y+3	; 0x03
    3534:	fc 81       	ldd	r31, Y+4	; 0x04
    3536:	11 86       	std	Z+9, r1	; 0x09
    3538:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    353a:	81 e0       	ldi	r24, 0x01	; 1
    353c:	8a 83       	std	Y+2, r24	; 0x02
    353e:	01 c0       	rjmp	.+2      	; 0x3542 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3540:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3542:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3544:	28 96       	adiw	r28, 0x08	; 8
    3546:	0f b6       	in	r0, 0x3f	; 63
    3548:	f8 94       	cli
    354a:	de bf       	out	0x3e, r29	; 62
    354c:	0f be       	out	0x3f, r0	; 63
    354e:	cd bf       	out	0x3d, r28	; 61
    3550:	cf 91       	pop	r28
    3552:	df 91       	pop	r29
    3554:	1f 91       	pop	r17
    3556:	0f 91       	pop	r16
    3558:	ff 90       	pop	r15
    355a:	ef 90       	pop	r14
    355c:	08 95       	ret

0000355e <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    355e:	ef 92       	push	r14
    3560:	ff 92       	push	r15
    3562:	0f 93       	push	r16
    3564:	1f 93       	push	r17
    3566:	df 93       	push	r29
    3568:	cf 93       	push	r28
    356a:	cd b7       	in	r28, 0x3d	; 61
    356c:	de b7       	in	r29, 0x3e	; 62
    356e:	28 97       	sbiw	r28, 0x08	; 8
    3570:	0f b6       	in	r0, 0x3f	; 63
    3572:	f8 94       	cli
    3574:	de bf       	out	0x3e, r29	; 62
    3576:	0f be       	out	0x3f, r0	; 63
    3578:	cd bf       	out	0x3d, r28	; 61
    357a:	9e 83       	std	Y+6, r25	; 0x06
    357c:	8d 83       	std	Y+5, r24	; 0x05
    357e:	78 87       	std	Y+8, r23	; 0x08
    3580:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3582:	8d 81       	ldd	r24, Y+5	; 0x05
    3584:	9e 81       	ldd	r25, Y+6	; 0x06
    3586:	9c 83       	std	Y+4, r25	; 0x04
    3588:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    358a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    358c:	eb 81       	ldd	r30, Y+3	; 0x03
    358e:	fc 81       	ldd	r31, Y+4	; 0x04
    3590:	82 85       	ldd	r24, Z+10	; 0x0a
    3592:	93 85       	ldd	r25, Z+11	; 0x0b
    3594:	00 97       	sbiw	r24, 0x00	; 0
    3596:	b9 f0       	breq	.+46     	; 0x35c6 <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    3598:	eb 81       	ldd	r30, Y+3	; 0x03
    359a:	fc 81       	ldd	r31, Y+4	; 0x04
    359c:	82 85       	ldd	r24, Z+10	; 0x0a
    359e:	93 85       	ldd	r25, Z+11	; 0x0b
    35a0:	ef 81       	ldd	r30, Y+7	; 0x07
    35a2:	f8 85       	ldd	r31, Y+8	; 0x08
    35a4:	40 e0       	ldi	r20, 0x00	; 0
    35a6:	50 e0       	ldi	r21, 0x00	; 0
    35a8:	60 e0       	ldi	r22, 0x00	; 0
    35aa:	70 e0       	ldi	r23, 0x00	; 0
    35ac:	20 e0       	ldi	r18, 0x00	; 0
    35ae:	00 e0       	ldi	r16, 0x00	; 0
    35b0:	10 e0       	ldi	r17, 0x00	; 0
    35b2:	7f 01       	movw	r14, r30
    35b4:	0e 94 87 27 	call	0x4f0e	; 0x4f0e <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    35b8:	eb 81       	ldd	r30, Y+3	; 0x03
    35ba:	fc 81       	ldd	r31, Y+4	; 0x04
    35bc:	13 86       	std	Z+11, r1	; 0x0b
    35be:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    35c0:	81 e0       	ldi	r24, 0x01	; 1
    35c2:	8a 83       	std	Y+2, r24	; 0x02
    35c4:	01 c0       	rjmp	.+2      	; 0x35c8 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    35c6:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    35c8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    35ca:	28 96       	adiw	r28, 0x08	; 8
    35cc:	0f b6       	in	r0, 0x3f	; 63
    35ce:	f8 94       	cli
    35d0:	de bf       	out	0x3e, r29	; 62
    35d2:	0f be       	out	0x3f, r0	; 63
    35d4:	cd bf       	out	0x3d, r28	; 61
    35d6:	cf 91       	pop	r28
    35d8:	df 91       	pop	r29
    35da:	1f 91       	pop	r17
    35dc:	0f 91       	pop	r16
    35de:	ff 90       	pop	r15
    35e0:	ef 90       	pop	r14
    35e2:	08 95       	ret

000035e4 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    35e4:	df 93       	push	r29
    35e6:	cf 93       	push	r28
    35e8:	cd b7       	in	r28, 0x3d	; 61
    35ea:	de b7       	in	r29, 0x3e	; 62
    35ec:	2e 97       	sbiw	r28, 0x0e	; 14
    35ee:	0f b6       	in	r0, 0x3f	; 63
    35f0:	f8 94       	cli
    35f2:	de bf       	out	0x3e, r29	; 62
    35f4:	0f be       	out	0x3f, r0	; 63
    35f6:	cd bf       	out	0x3d, r28	; 61
    35f8:	9e 83       	std	Y+6, r25	; 0x06
    35fa:	8d 83       	std	Y+5, r24	; 0x05
    35fc:	78 87       	std	Y+8, r23	; 0x08
    35fe:	6f 83       	std	Y+7, r22	; 0x07
    3600:	5a 87       	std	Y+10, r21	; 0x0a
    3602:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    3604:	ed 81       	ldd	r30, Y+5	; 0x05
    3606:	fe 81       	ldd	r31, Y+6	; 0x06
    3608:	82 81       	ldd	r24, Z+2	; 0x02
    360a:	93 81       	ldd	r25, Z+3	; 0x03
    360c:	9c 83       	std	Y+4, r25	; 0x04
    360e:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3610:	ed 81       	ldd	r30, Y+5	; 0x05
    3612:	fe 81       	ldd	r31, Y+6	; 0x06
    3614:	24 81       	ldd	r18, Z+4	; 0x04
    3616:	35 81       	ldd	r19, Z+5	; 0x05
    3618:	8b 81       	ldd	r24, Y+3	; 0x03
    361a:	9c 81       	ldd	r25, Y+4	; 0x04
    361c:	a9 01       	movw	r20, r18
    361e:	48 1b       	sub	r20, r24
    3620:	59 0b       	sbc	r21, r25
    3622:	ca 01       	movw	r24, r20
    3624:	29 85       	ldd	r18, Y+9	; 0x09
    3626:	3a 85       	ldd	r19, Y+10	; 0x0a
    3628:	3e 87       	std	Y+14, r19	; 0x0e
    362a:	2d 87       	std	Y+13, r18	; 0x0d
    362c:	9c 87       	std	Y+12, r25	; 0x0c
    362e:	8b 87       	std	Y+11, r24	; 0x0b
    3630:	4b 85       	ldd	r20, Y+11	; 0x0b
    3632:	5c 85       	ldd	r21, Y+12	; 0x0c
    3634:	8d 85       	ldd	r24, Y+13	; 0x0d
    3636:	9e 85       	ldd	r25, Y+14	; 0x0e
    3638:	84 17       	cp	r24, r20
    363a:	95 07       	cpc	r25, r21
    363c:	20 f4       	brcc	.+8      	; 0x3646 <prvWriteBytesToBuffer+0x62>
    363e:	2d 85       	ldd	r18, Y+13	; 0x0d
    3640:	3e 85       	ldd	r19, Y+14	; 0x0e
    3642:	3c 87       	std	Y+12, r19	; 0x0c
    3644:	2b 87       	std	Y+11, r18	; 0x0b
    3646:	4b 85       	ldd	r20, Y+11	; 0x0b
    3648:	5c 85       	ldd	r21, Y+12	; 0x0c
    364a:	5a 83       	std	Y+2, r21	; 0x02
    364c:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    364e:	ed 81       	ldd	r30, Y+5	; 0x05
    3650:	fe 81       	ldd	r31, Y+6	; 0x06
    3652:	24 85       	ldd	r18, Z+12	; 0x0c
    3654:	35 85       	ldd	r19, Z+13	; 0x0d
    3656:	8b 81       	ldd	r24, Y+3	; 0x03
    3658:	9c 81       	ldd	r25, Y+4	; 0x04
    365a:	82 0f       	add	r24, r18
    365c:	93 1f       	adc	r25, r19
    365e:	2f 81       	ldd	r18, Y+7	; 0x07
    3660:	38 85       	ldd	r19, Y+8	; 0x08
    3662:	49 81       	ldd	r20, Y+1	; 0x01
    3664:	5a 81       	ldd	r21, Y+2	; 0x02
    3666:	b9 01       	movw	r22, r18
    3668:	0e 94 bb 29 	call	0x5376	; 0x5376 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    366c:	29 85       	ldd	r18, Y+9	; 0x09
    366e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3670:	89 81       	ldd	r24, Y+1	; 0x01
    3672:	9a 81       	ldd	r25, Y+2	; 0x02
    3674:	82 17       	cp	r24, r18
    3676:	93 07       	cpc	r25, r19
    3678:	b0 f4       	brcc	.+44     	; 0x36a6 <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    367a:	ed 81       	ldd	r30, Y+5	; 0x05
    367c:	fe 81       	ldd	r31, Y+6	; 0x06
    367e:	64 85       	ldd	r22, Z+12	; 0x0c
    3680:	75 85       	ldd	r23, Z+13	; 0x0d
    3682:	2f 81       	ldd	r18, Y+7	; 0x07
    3684:	38 85       	ldd	r19, Y+8	; 0x08
    3686:	89 81       	ldd	r24, Y+1	; 0x01
    3688:	9a 81       	ldd	r25, Y+2	; 0x02
    368a:	a9 01       	movw	r20, r18
    368c:	48 0f       	add	r20, r24
    368e:	59 1f       	adc	r21, r25
    3690:	29 85       	ldd	r18, Y+9	; 0x09
    3692:	3a 85       	ldd	r19, Y+10	; 0x0a
    3694:	89 81       	ldd	r24, Y+1	; 0x01
    3696:	9a 81       	ldd	r25, Y+2	; 0x02
    3698:	28 1b       	sub	r18, r24
    369a:	39 0b       	sbc	r19, r25
    369c:	cb 01       	movw	r24, r22
    369e:	ba 01       	movw	r22, r20
    36a0:	a9 01       	movw	r20, r18
    36a2:	0e 94 bb 29 	call	0x5376	; 0x5376 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    36a6:	2b 81       	ldd	r18, Y+3	; 0x03
    36a8:	3c 81       	ldd	r19, Y+4	; 0x04
    36aa:	89 85       	ldd	r24, Y+9	; 0x09
    36ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    36ae:	82 0f       	add	r24, r18
    36b0:	93 1f       	adc	r25, r19
    36b2:	9c 83       	std	Y+4, r25	; 0x04
    36b4:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    36b6:	ed 81       	ldd	r30, Y+5	; 0x05
    36b8:	fe 81       	ldd	r31, Y+6	; 0x06
    36ba:	24 81       	ldd	r18, Z+4	; 0x04
    36bc:	35 81       	ldd	r19, Z+5	; 0x05
    36be:	8b 81       	ldd	r24, Y+3	; 0x03
    36c0:	9c 81       	ldd	r25, Y+4	; 0x04
    36c2:	82 17       	cp	r24, r18
    36c4:	93 07       	cpc	r25, r19
    36c6:	50 f0       	brcs	.+20     	; 0x36dc <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    36c8:	ed 81       	ldd	r30, Y+5	; 0x05
    36ca:	fe 81       	ldd	r31, Y+6	; 0x06
    36cc:	24 81       	ldd	r18, Z+4	; 0x04
    36ce:	35 81       	ldd	r19, Z+5	; 0x05
    36d0:	8b 81       	ldd	r24, Y+3	; 0x03
    36d2:	9c 81       	ldd	r25, Y+4	; 0x04
    36d4:	82 1b       	sub	r24, r18
    36d6:	93 0b       	sbc	r25, r19
    36d8:	9c 83       	std	Y+4, r25	; 0x04
    36da:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    36dc:	ed 81       	ldd	r30, Y+5	; 0x05
    36de:	fe 81       	ldd	r31, Y+6	; 0x06
    36e0:	8b 81       	ldd	r24, Y+3	; 0x03
    36e2:	9c 81       	ldd	r25, Y+4	; 0x04
    36e4:	93 83       	std	Z+3, r25	; 0x03
    36e6:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    36e8:	89 85       	ldd	r24, Y+9	; 0x09
    36ea:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    36ec:	2e 96       	adiw	r28, 0x0e	; 14
    36ee:	0f b6       	in	r0, 0x3f	; 63
    36f0:	f8 94       	cli
    36f2:	de bf       	out	0x3e, r29	; 62
    36f4:	0f be       	out	0x3f, r0	; 63
    36f6:	cd bf       	out	0x3d, r28	; 61
    36f8:	cf 91       	pop	r28
    36fa:	df 91       	pop	r29
    36fc:	08 95       	ret

000036fe <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    36fe:	df 93       	push	r29
    3700:	cf 93       	push	r28
    3702:	cd b7       	in	r28, 0x3d	; 61
    3704:	de b7       	in	r29, 0x3e	; 62
    3706:	66 97       	sbiw	r28, 0x16	; 22
    3708:	0f b6       	in	r0, 0x3f	; 63
    370a:	f8 94       	cli
    370c:	de bf       	out	0x3e, r29	; 62
    370e:	0f be       	out	0x3f, r0	; 63
    3710:	cd bf       	out	0x3d, r28	; 61
    3712:	98 87       	std	Y+8, r25	; 0x08
    3714:	8f 83       	std	Y+7, r24	; 0x07
    3716:	7a 87       	std	Y+10, r23	; 0x0a
    3718:	69 87       	std	Y+9, r22	; 0x09
    371a:	5c 87       	std	Y+12, r21	; 0x0c
    371c:	4b 87       	std	Y+11, r20	; 0x0b
    371e:	3e 87       	std	Y+14, r19	; 0x0e
    3720:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    3722:	2d 85       	ldd	r18, Y+13	; 0x0d
    3724:	3e 85       	ldd	r19, Y+14	; 0x0e
    3726:	3a 8b       	std	Y+18, r19	; 0x12
    3728:	29 8b       	std	Y+17, r18	; 0x11
    372a:	4b 85       	ldd	r20, Y+11	; 0x0b
    372c:	5c 85       	ldd	r21, Y+12	; 0x0c
    372e:	58 8b       	std	Y+16, r21	; 0x10
    3730:	4f 87       	std	Y+15, r20	; 0x0f
    3732:	8f 85       	ldd	r24, Y+15	; 0x0f
    3734:	98 89       	ldd	r25, Y+16	; 0x10
    3736:	29 89       	ldd	r18, Y+17	; 0x11
    3738:	3a 89       	ldd	r19, Y+18	; 0x12
    373a:	28 17       	cp	r18, r24
    373c:	39 07       	cpc	r19, r25
    373e:	20 f4       	brcc	.+8      	; 0x3748 <prvReadBytesFromBuffer+0x4a>
    3740:	49 89       	ldd	r20, Y+17	; 0x11
    3742:	5a 89       	ldd	r21, Y+18	; 0x12
    3744:	58 8b       	std	Y+16, r21	; 0x10
    3746:	4f 87       	std	Y+15, r20	; 0x0f
    3748:	8f 85       	ldd	r24, Y+15	; 0x0f
    374a:	98 89       	ldd	r25, Y+16	; 0x10
    374c:	9e 83       	std	Y+6, r25	; 0x06
    374e:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    3750:	8d 81       	ldd	r24, Y+5	; 0x05
    3752:	9e 81       	ldd	r25, Y+6	; 0x06
    3754:	00 97       	sbiw	r24, 0x00	; 0
    3756:	09 f4       	brne	.+2      	; 0x375a <prvReadBytesFromBuffer+0x5c>
    3758:	74 c0       	rjmp	.+232    	; 0x3842 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    375a:	ef 81       	ldd	r30, Y+7	; 0x07
    375c:	f8 85       	ldd	r31, Y+8	; 0x08
    375e:	80 81       	ld	r24, Z
    3760:	91 81       	ldd	r25, Z+1	; 0x01
    3762:	9a 83       	std	Y+2, r25	; 0x02
    3764:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    3766:	ef 81       	ldd	r30, Y+7	; 0x07
    3768:	f8 85       	ldd	r31, Y+8	; 0x08
    376a:	24 81       	ldd	r18, Z+4	; 0x04
    376c:	35 81       	ldd	r19, Z+5	; 0x05
    376e:	89 81       	ldd	r24, Y+1	; 0x01
    3770:	9a 81       	ldd	r25, Y+2	; 0x02
    3772:	a9 01       	movw	r20, r18
    3774:	48 1b       	sub	r20, r24
    3776:	59 0b       	sbc	r21, r25
    3778:	ca 01       	movw	r24, r20
    377a:	2d 81       	ldd	r18, Y+5	; 0x05
    377c:	3e 81       	ldd	r19, Y+6	; 0x06
    377e:	3e 8b       	std	Y+22, r19	; 0x16
    3780:	2d 8b       	std	Y+21, r18	; 0x15
    3782:	9c 8b       	std	Y+20, r25	; 0x14
    3784:	8b 8b       	std	Y+19, r24	; 0x13
    3786:	4b 89       	ldd	r20, Y+19	; 0x13
    3788:	5c 89       	ldd	r21, Y+20	; 0x14
    378a:	8d 89       	ldd	r24, Y+21	; 0x15
    378c:	9e 89       	ldd	r25, Y+22	; 0x16
    378e:	84 17       	cp	r24, r20
    3790:	95 07       	cpc	r25, r21
    3792:	20 f4       	brcc	.+8      	; 0x379c <prvReadBytesFromBuffer+0x9e>
    3794:	2d 89       	ldd	r18, Y+21	; 0x15
    3796:	3e 89       	ldd	r19, Y+22	; 0x16
    3798:	3c 8b       	std	Y+20, r19	; 0x14
    379a:	2b 8b       	std	Y+19, r18	; 0x13
    379c:	4b 89       	ldd	r20, Y+19	; 0x13
    379e:	5c 89       	ldd	r21, Y+20	; 0x14
    37a0:	5c 83       	std	Y+4, r21	; 0x04
    37a2:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    37a4:	ef 81       	ldd	r30, Y+7	; 0x07
    37a6:	f8 85       	ldd	r31, Y+8	; 0x08
    37a8:	24 85       	ldd	r18, Z+12	; 0x0c
    37aa:	35 85       	ldd	r19, Z+13	; 0x0d
    37ac:	89 81       	ldd	r24, Y+1	; 0x01
    37ae:	9a 81       	ldd	r25, Y+2	; 0x02
    37b0:	a9 01       	movw	r20, r18
    37b2:	48 0f       	add	r20, r24
    37b4:	59 1f       	adc	r21, r25
    37b6:	89 85       	ldd	r24, Y+9	; 0x09
    37b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    37ba:	2b 81       	ldd	r18, Y+3	; 0x03
    37bc:	3c 81       	ldd	r19, Y+4	; 0x04
    37be:	ba 01       	movw	r22, r20
    37c0:	a9 01       	movw	r20, r18
    37c2:	0e 94 bb 29 	call	0x5376	; 0x5376 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    37c6:	2d 81       	ldd	r18, Y+5	; 0x05
    37c8:	3e 81       	ldd	r19, Y+6	; 0x06
    37ca:	8b 81       	ldd	r24, Y+3	; 0x03
    37cc:	9c 81       	ldd	r25, Y+4	; 0x04
    37ce:	82 17       	cp	r24, r18
    37d0:	93 07       	cpc	r25, r19
    37d2:	b0 f4       	brcc	.+44     	; 0x3800 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    37d4:	29 85       	ldd	r18, Y+9	; 0x09
    37d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    37d8:	8b 81       	ldd	r24, Y+3	; 0x03
    37da:	9c 81       	ldd	r25, Y+4	; 0x04
    37dc:	b9 01       	movw	r22, r18
    37de:	68 0f       	add	r22, r24
    37e0:	79 1f       	adc	r23, r25
    37e2:	ef 81       	ldd	r30, Y+7	; 0x07
    37e4:	f8 85       	ldd	r31, Y+8	; 0x08
    37e6:	44 85       	ldd	r20, Z+12	; 0x0c
    37e8:	55 85       	ldd	r21, Z+13	; 0x0d
    37ea:	2d 81       	ldd	r18, Y+5	; 0x05
    37ec:	3e 81       	ldd	r19, Y+6	; 0x06
    37ee:	8b 81       	ldd	r24, Y+3	; 0x03
    37f0:	9c 81       	ldd	r25, Y+4	; 0x04
    37f2:	28 1b       	sub	r18, r24
    37f4:	39 0b       	sbc	r19, r25
    37f6:	cb 01       	movw	r24, r22
    37f8:	ba 01       	movw	r22, r20
    37fa:	a9 01       	movw	r20, r18
    37fc:	0e 94 bb 29 	call	0x5376	; 0x5376 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3800:	29 81       	ldd	r18, Y+1	; 0x01
    3802:	3a 81       	ldd	r19, Y+2	; 0x02
    3804:	8d 81       	ldd	r24, Y+5	; 0x05
    3806:	9e 81       	ldd	r25, Y+6	; 0x06
    3808:	82 0f       	add	r24, r18
    380a:	93 1f       	adc	r25, r19
    380c:	9a 83       	std	Y+2, r25	; 0x02
    380e:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    3810:	ef 81       	ldd	r30, Y+7	; 0x07
    3812:	f8 85       	ldd	r31, Y+8	; 0x08
    3814:	24 81       	ldd	r18, Z+4	; 0x04
    3816:	35 81       	ldd	r19, Z+5	; 0x05
    3818:	89 81       	ldd	r24, Y+1	; 0x01
    381a:	9a 81       	ldd	r25, Y+2	; 0x02
    381c:	82 17       	cp	r24, r18
    381e:	93 07       	cpc	r25, r19
    3820:	50 f0       	brcs	.+20     	; 0x3836 <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    3822:	ef 81       	ldd	r30, Y+7	; 0x07
    3824:	f8 85       	ldd	r31, Y+8	; 0x08
    3826:	24 81       	ldd	r18, Z+4	; 0x04
    3828:	35 81       	ldd	r19, Z+5	; 0x05
    382a:	89 81       	ldd	r24, Y+1	; 0x01
    382c:	9a 81       	ldd	r25, Y+2	; 0x02
    382e:	82 1b       	sub	r24, r18
    3830:	93 0b       	sbc	r25, r19
    3832:	9a 83       	std	Y+2, r25	; 0x02
    3834:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    3836:	ef 81       	ldd	r30, Y+7	; 0x07
    3838:	f8 85       	ldd	r31, Y+8	; 0x08
    383a:	89 81       	ldd	r24, Y+1	; 0x01
    383c:	9a 81       	ldd	r25, Y+2	; 0x02
    383e:	91 83       	std	Z+1, r25	; 0x01
    3840:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3842:	8d 81       	ldd	r24, Y+5	; 0x05
    3844:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3846:	66 96       	adiw	r28, 0x16	; 22
    3848:	0f b6       	in	r0, 0x3f	; 63
    384a:	f8 94       	cli
    384c:	de bf       	out	0x3e, r29	; 62
    384e:	0f be       	out	0x3f, r0	; 63
    3850:	cd bf       	out	0x3d, r28	; 61
    3852:	cf 91       	pop	r28
    3854:	df 91       	pop	r29
    3856:	08 95       	ret

00003858 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3858:	df 93       	push	r29
    385a:	cf 93       	push	r28
    385c:	00 d0       	rcall	.+0      	; 0x385e <prvBytesInBuffer+0x6>
    385e:	00 d0       	rcall	.+0      	; 0x3860 <prvBytesInBuffer+0x8>
    3860:	cd b7       	in	r28, 0x3d	; 61
    3862:	de b7       	in	r29, 0x3e	; 62
    3864:	9c 83       	std	Y+4, r25	; 0x04
    3866:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3868:	eb 81       	ldd	r30, Y+3	; 0x03
    386a:	fc 81       	ldd	r31, Y+4	; 0x04
    386c:	24 81       	ldd	r18, Z+4	; 0x04
    386e:	35 81       	ldd	r19, Z+5	; 0x05
    3870:	eb 81       	ldd	r30, Y+3	; 0x03
    3872:	fc 81       	ldd	r31, Y+4	; 0x04
    3874:	82 81       	ldd	r24, Z+2	; 0x02
    3876:	93 81       	ldd	r25, Z+3	; 0x03
    3878:	82 0f       	add	r24, r18
    387a:	93 1f       	adc	r25, r19
    387c:	9a 83       	std	Y+2, r25	; 0x02
    387e:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3880:	eb 81       	ldd	r30, Y+3	; 0x03
    3882:	fc 81       	ldd	r31, Y+4	; 0x04
    3884:	20 81       	ld	r18, Z
    3886:	31 81       	ldd	r19, Z+1	; 0x01
    3888:	89 81       	ldd	r24, Y+1	; 0x01
    388a:	9a 81       	ldd	r25, Y+2	; 0x02
    388c:	82 1b       	sub	r24, r18
    388e:	93 0b       	sbc	r25, r19
    3890:	9a 83       	std	Y+2, r25	; 0x02
    3892:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    3894:	eb 81       	ldd	r30, Y+3	; 0x03
    3896:	fc 81       	ldd	r31, Y+4	; 0x04
    3898:	24 81       	ldd	r18, Z+4	; 0x04
    389a:	35 81       	ldd	r19, Z+5	; 0x05
    389c:	89 81       	ldd	r24, Y+1	; 0x01
    389e:	9a 81       	ldd	r25, Y+2	; 0x02
    38a0:	82 17       	cp	r24, r18
    38a2:	93 07       	cpc	r25, r19
    38a4:	50 f0       	brcs	.+20     	; 0x38ba <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    38a6:	eb 81       	ldd	r30, Y+3	; 0x03
    38a8:	fc 81       	ldd	r31, Y+4	; 0x04
    38aa:	24 81       	ldd	r18, Z+4	; 0x04
    38ac:	35 81       	ldd	r19, Z+5	; 0x05
    38ae:	89 81       	ldd	r24, Y+1	; 0x01
    38b0:	9a 81       	ldd	r25, Y+2	; 0x02
    38b2:	82 1b       	sub	r24, r18
    38b4:	93 0b       	sbc	r25, r19
    38b6:	9a 83       	std	Y+2, r25	; 0x02
    38b8:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    38ba:	89 81       	ldd	r24, Y+1	; 0x01
    38bc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    38be:	0f 90       	pop	r0
    38c0:	0f 90       	pop	r0
    38c2:	0f 90       	pop	r0
    38c4:	0f 90       	pop	r0
    38c6:	cf 91       	pop	r28
    38c8:	df 91       	pop	r29
    38ca:	08 95       	ret

000038cc <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    38cc:	0f 93       	push	r16
    38ce:	df 93       	push	r29
    38d0:	cf 93       	push	r28
    38d2:	cd b7       	in	r28, 0x3d	; 61
    38d4:	de b7       	in	r29, 0x3e	; 62
    38d6:	29 97       	sbiw	r28, 0x09	; 9
    38d8:	0f b6       	in	r0, 0x3f	; 63
    38da:	f8 94       	cli
    38dc:	de bf       	out	0x3e, r29	; 62
    38de:	0f be       	out	0x3f, r0	; 63
    38e0:	cd bf       	out	0x3d, r28	; 61
    38e2:	9a 83       	std	Y+2, r25	; 0x02
    38e4:	89 83       	std	Y+1, r24	; 0x01
    38e6:	7c 83       	std	Y+4, r23	; 0x04
    38e8:	6b 83       	std	Y+3, r22	; 0x03
    38ea:	5e 83       	std	Y+6, r21	; 0x06
    38ec:	4d 83       	std	Y+5, r20	; 0x05
    38ee:	38 87       	std	Y+8, r19	; 0x08
    38f0:	2f 83       	std	Y+7, r18	; 0x07
    38f2:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    38f4:	89 81       	ldd	r24, Y+1	; 0x01
    38f6:	9a 81       	ldd	r25, Y+2	; 0x02
    38f8:	60 e0       	ldi	r22, 0x00	; 0
    38fa:	70 e0       	ldi	r23, 0x00	; 0
    38fc:	4f e0       	ldi	r20, 0x0F	; 15
    38fe:	50 e0       	ldi	r21, 0x00	; 0
    3900:	0e 94 c4 29 	call	0x5388	; 0x5388 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3904:	e9 81       	ldd	r30, Y+1	; 0x01
    3906:	fa 81       	ldd	r31, Y+2	; 0x02
    3908:	8b 81       	ldd	r24, Y+3	; 0x03
    390a:	9c 81       	ldd	r25, Y+4	; 0x04
    390c:	95 87       	std	Z+13, r25	; 0x0d
    390e:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3910:	e9 81       	ldd	r30, Y+1	; 0x01
    3912:	fa 81       	ldd	r31, Y+2	; 0x02
    3914:	8d 81       	ldd	r24, Y+5	; 0x05
    3916:	9e 81       	ldd	r25, Y+6	; 0x06
    3918:	95 83       	std	Z+5, r25	; 0x05
    391a:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    391c:	e9 81       	ldd	r30, Y+1	; 0x01
    391e:	fa 81       	ldd	r31, Y+2	; 0x02
    3920:	8f 81       	ldd	r24, Y+7	; 0x07
    3922:	98 85       	ldd	r25, Y+8	; 0x08
    3924:	97 83       	std	Z+7, r25	; 0x07
    3926:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3928:	e9 81       	ldd	r30, Y+1	; 0x01
    392a:	fa 81       	ldd	r31, Y+2	; 0x02
    392c:	89 85       	ldd	r24, Y+9	; 0x09
    392e:	86 87       	std	Z+14, r24	; 0x0e
}
    3930:	29 96       	adiw	r28, 0x09	; 9
    3932:	0f b6       	in	r0, 0x3f	; 63
    3934:	f8 94       	cli
    3936:	de bf       	out	0x3e, r29	; 62
    3938:	0f be       	out	0x3f, r0	; 63
    393a:	cd bf       	out	0x3d, r28	; 61
    393c:	cf 91       	pop	r28
    393e:	df 91       	pop	r29
    3940:	0f 91       	pop	r16
    3942:	08 95       	ret

00003944 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3944:	8f 92       	push	r8
    3946:	9f 92       	push	r9
    3948:	af 92       	push	r10
    394a:	bf 92       	push	r11
    394c:	cf 92       	push	r12
    394e:	df 92       	push	r13
    3950:	ef 92       	push	r14
    3952:	ff 92       	push	r15
    3954:	0f 93       	push	r16
    3956:	1f 93       	push	r17
    3958:	df 93       	push	r29
    395a:	cf 93       	push	r28
    395c:	cd b7       	in	r28, 0x3d	; 61
    395e:	de b7       	in	r29, 0x3e	; 62
    3960:	60 97       	sbiw	r28, 0x10	; 16
    3962:	0f b6       	in	r0, 0x3f	; 63
    3964:	f8 94       	cli
    3966:	de bf       	out	0x3e, r29	; 62
    3968:	0f be       	out	0x3f, r0	; 63
    396a:	cd bf       	out	0x3d, r28	; 61
    396c:	9f 83       	std	Y+7, r25	; 0x07
    396e:	8e 83       	std	Y+6, r24	; 0x06
    3970:	79 87       	std	Y+9, r23	; 0x09
    3972:	68 87       	std	Y+8, r22	; 0x08
    3974:	5b 87       	std	Y+11, r21	; 0x0b
    3976:	4a 87       	std	Y+10, r20	; 0x0a
    3978:	3d 87       	std	Y+13, r19	; 0x0d
    397a:	2c 87       	std	Y+12, r18	; 0x0c
    397c:	0e 87       	std	Y+14, r16	; 0x0e
    397e:	f8 8a       	std	Y+16, r15	; 0x10
    3980:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3982:	8a 85       	ldd	r24, Y+10	; 0x0a
    3984:	9b 85       	ldd	r25, Y+11	; 0x0b
    3986:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
    398a:	9a 83       	std	Y+2, r25	; 0x02
    398c:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    398e:	89 81       	ldd	r24, Y+1	; 0x01
    3990:	9a 81       	ldd	r25, Y+2	; 0x02
    3992:	00 97       	sbiw	r24, 0x00	; 0
    3994:	b1 f0       	breq	.+44     	; 0x39c2 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3996:	86 e2       	ldi	r24, 0x26	; 38
    3998:	90 e0       	ldi	r25, 0x00	; 0
    399a:	0e 94 c4 07 	call	0xf88	; 0xf88 <pvPortMalloc>
    399e:	9d 83       	std	Y+5, r25	; 0x05
    39a0:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    39a2:	8c 81       	ldd	r24, Y+4	; 0x04
    39a4:	9d 81       	ldd	r25, Y+5	; 0x05
    39a6:	00 97       	sbiw	r24, 0x00	; 0
    39a8:	39 f0       	breq	.+14     	; 0x39b8 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    39aa:	ec 81       	ldd	r30, Y+4	; 0x04
    39ac:	fd 81       	ldd	r31, Y+5	; 0x05
    39ae:	89 81       	ldd	r24, Y+1	; 0x01
    39b0:	9a 81       	ldd	r25, Y+2	; 0x02
    39b2:	90 8f       	std	Z+24, r25	; 0x18
    39b4:	87 8b       	std	Z+23, r24	; 0x17
    39b6:	07 c0       	rjmp	.+14     	; 0x39c6 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    39b8:	89 81       	ldd	r24, Y+1	; 0x01
    39ba:	9a 81       	ldd	r25, Y+2	; 0x02
    39bc:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
    39c0:	02 c0       	rjmp	.+4      	; 0x39c6 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    39c2:	1d 82       	std	Y+5, r1	; 0x05
    39c4:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    39c6:	8c 81       	ldd	r24, Y+4	; 0x04
    39c8:	9d 81       	ldd	r25, Y+5	; 0x05
    39ca:	00 97       	sbiw	r24, 0x00	; 0
    39cc:	e9 f0       	breq	.+58     	; 0x3a08 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    39ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    39d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    39d2:	9c 01       	movw	r18, r24
    39d4:	40 e0       	ldi	r20, 0x00	; 0
    39d6:	50 e0       	ldi	r21, 0x00	; 0
    39d8:	8e 81       	ldd	r24, Y+6	; 0x06
    39da:	9f 81       	ldd	r25, Y+7	; 0x07
    39dc:	68 85       	ldd	r22, Y+8	; 0x08
    39de:	79 85       	ldd	r23, Y+9	; 0x09
    39e0:	ec 85       	ldd	r30, Y+12	; 0x0c
    39e2:	fd 85       	ldd	r31, Y+13	; 0x0d
    39e4:	af 85       	ldd	r26, Y+15	; 0x0f
    39e6:	b8 89       	ldd	r27, Y+16	; 0x10
    39e8:	ac 80       	ldd	r10, Y+4	; 0x04
    39ea:	bd 80       	ldd	r11, Y+5	; 0x05
    39ec:	8f 01       	movw	r16, r30
    39ee:	ee 84       	ldd	r14, Y+14	; 0x0e
    39f0:	6d 01       	movw	r12, r26
    39f2:	88 24       	eor	r8, r8
    39f4:	99 24       	eor	r9, r9
    39f6:	0e 94 1a 1d 	call	0x3a34	; 0x3a34 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    39fa:	8c 81       	ldd	r24, Y+4	; 0x04
    39fc:	9d 81       	ldd	r25, Y+5	; 0x05
    39fe:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3a02:	81 e0       	ldi	r24, 0x01	; 1
    3a04:	8b 83       	std	Y+3, r24	; 0x03
    3a06:	02 c0       	rjmp	.+4      	; 0x3a0c <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3a08:	8f ef       	ldi	r24, 0xFF	; 255
    3a0a:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3a0c:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3a0e:	60 96       	adiw	r28, 0x10	; 16
    3a10:	0f b6       	in	r0, 0x3f	; 63
    3a12:	f8 94       	cli
    3a14:	de bf       	out	0x3e, r29	; 62
    3a16:	0f be       	out	0x3f, r0	; 63
    3a18:	cd bf       	out	0x3d, r28	; 61
    3a1a:	cf 91       	pop	r28
    3a1c:	df 91       	pop	r29
    3a1e:	1f 91       	pop	r17
    3a20:	0f 91       	pop	r16
    3a22:	ff 90       	pop	r15
    3a24:	ef 90       	pop	r14
    3a26:	df 90       	pop	r13
    3a28:	cf 90       	pop	r12
    3a2a:	bf 90       	pop	r11
    3a2c:	af 90       	pop	r10
    3a2e:	9f 90       	pop	r9
    3a30:	8f 90       	pop	r8
    3a32:	08 95       	ret

00003a34 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3a34:	8f 92       	push	r8
    3a36:	9f 92       	push	r9
    3a38:	af 92       	push	r10
    3a3a:	bf 92       	push	r11
    3a3c:	cf 92       	push	r12
    3a3e:	df 92       	push	r13
    3a40:	ef 92       	push	r14
    3a42:	0f 93       	push	r16
    3a44:	1f 93       	push	r17
    3a46:	df 93       	push	r29
    3a48:	cf 93       	push	r28
    3a4a:	cd b7       	in	r28, 0x3d	; 61
    3a4c:	de b7       	in	r29, 0x3e	; 62
    3a4e:	64 97       	sbiw	r28, 0x14	; 20
    3a50:	0f b6       	in	r0, 0x3f	; 63
    3a52:	f8 94       	cli
    3a54:	de bf       	out	0x3e, r29	; 62
    3a56:	0f be       	out	0x3f, r0	; 63
    3a58:	cd bf       	out	0x3d, r28	; 61
    3a5a:	9d 83       	std	Y+5, r25	; 0x05
    3a5c:	8c 83       	std	Y+4, r24	; 0x04
    3a5e:	7f 83       	std	Y+7, r23	; 0x07
    3a60:	6e 83       	std	Y+6, r22	; 0x06
    3a62:	28 87       	std	Y+8, r18	; 0x08
    3a64:	39 87       	std	Y+9, r19	; 0x09
    3a66:	4a 87       	std	Y+10, r20	; 0x0a
    3a68:	5b 87       	std	Y+11, r21	; 0x0b
    3a6a:	1d 87       	std	Y+13, r17	; 0x0d
    3a6c:	0c 87       	std	Y+12, r16	; 0x0c
    3a6e:	ee 86       	std	Y+14, r14	; 0x0e
    3a70:	d8 8a       	std	Y+16, r13	; 0x10
    3a72:	cf 86       	std	Y+15, r12	; 0x0f
    3a74:	ba 8a       	std	Y+18, r11	; 0x12
    3a76:	a9 8a       	std	Y+17, r10	; 0x11
    3a78:	9c 8a       	std	Y+20, r9	; 0x14
    3a7a:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3a7c:	e9 89       	ldd	r30, Y+17	; 0x11
    3a7e:	fa 89       	ldd	r31, Y+18	; 0x12
    3a80:	27 89       	ldd	r18, Z+23	; 0x17
    3a82:	30 8d       	ldd	r19, Z+24	; 0x18
    3a84:	88 85       	ldd	r24, Y+8	; 0x08
    3a86:	99 85       	ldd	r25, Y+9	; 0x09
    3a88:	01 97       	sbiw	r24, 0x01	; 1
    3a8a:	82 0f       	add	r24, r18
    3a8c:	93 1f       	adc	r25, r19
    3a8e:	9b 83       	std	Y+3, r25	; 0x03
    3a90:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3a92:	8e 81       	ldd	r24, Y+6	; 0x06
    3a94:	9f 81       	ldd	r25, Y+7	; 0x07
    3a96:	00 97       	sbiw	r24, 0x00	; 0
    3a98:	51 f1       	breq	.+84     	; 0x3aee <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3a9a:	19 82       	std	Y+1, r1	; 0x01
    3a9c:	21 c0       	rjmp	.+66     	; 0x3ae0 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3a9e:	89 81       	ldd	r24, Y+1	; 0x01
    3aa0:	48 2f       	mov	r20, r24
    3aa2:	50 e0       	ldi	r21, 0x00	; 0
    3aa4:	89 81       	ldd	r24, Y+1	; 0x01
    3aa6:	28 2f       	mov	r18, r24
    3aa8:	30 e0       	ldi	r19, 0x00	; 0
    3aaa:	8e 81       	ldd	r24, Y+6	; 0x06
    3aac:	9f 81       	ldd	r25, Y+7	; 0x07
    3aae:	fc 01       	movw	r30, r24
    3ab0:	e2 0f       	add	r30, r18
    3ab2:	f3 1f       	adc	r31, r19
    3ab4:	20 81       	ld	r18, Z
    3ab6:	89 89       	ldd	r24, Y+17	; 0x11
    3ab8:	9a 89       	ldd	r25, Y+18	; 0x12
    3aba:	84 0f       	add	r24, r20
    3abc:	95 1f       	adc	r25, r21
    3abe:	fc 01       	movw	r30, r24
    3ac0:	79 96       	adiw	r30, 0x19	; 25
    3ac2:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3ac4:	89 81       	ldd	r24, Y+1	; 0x01
    3ac6:	28 2f       	mov	r18, r24
    3ac8:	30 e0       	ldi	r19, 0x00	; 0
    3aca:	8e 81       	ldd	r24, Y+6	; 0x06
    3acc:	9f 81       	ldd	r25, Y+7	; 0x07
    3ace:	fc 01       	movw	r30, r24
    3ad0:	e2 0f       	add	r30, r18
    3ad2:	f3 1f       	adc	r31, r19
    3ad4:	80 81       	ld	r24, Z
    3ad6:	88 23       	and	r24, r24
    3ad8:	31 f0       	breq	.+12     	; 0x3ae6 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3ada:	89 81       	ldd	r24, Y+1	; 0x01
    3adc:	8f 5f       	subi	r24, 0xFF	; 255
    3ade:	89 83       	std	Y+1, r24	; 0x01
    3ae0:	89 81       	ldd	r24, Y+1	; 0x01
    3ae2:	88 30       	cpi	r24, 0x08	; 8
    3ae4:	e0 f2       	brcs	.-72     	; 0x3a9e <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3ae6:	e9 89       	ldd	r30, Y+17	; 0x11
    3ae8:	fa 89       	ldd	r31, Y+18	; 0x12
    3aea:	10 a2       	std	Z+32, r1	; 0x20
    3aec:	03 c0       	rjmp	.+6      	; 0x3af4 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3aee:	e9 89       	ldd	r30, Y+17	; 0x11
    3af0:	fa 89       	ldd	r31, Y+18	; 0x12
    3af2:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3af4:	8e 85       	ldd	r24, Y+14	; 0x0e
    3af6:	85 30       	cpi	r24, 0x05	; 5
    3af8:	10 f0       	brcs	.+4      	; 0x3afe <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3afa:	84 e0       	ldi	r24, 0x04	; 4
    3afc:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3afe:	e9 89       	ldd	r30, Y+17	; 0x11
    3b00:	fa 89       	ldd	r31, Y+18	; 0x12
    3b02:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b04:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3b06:	89 89       	ldd	r24, Y+17	; 0x11
    3b08:	9a 89       	ldd	r25, Y+18	; 0x12
    3b0a:	02 96       	adiw	r24, 0x02	; 2
    3b0c:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3b10:	89 89       	ldd	r24, Y+17	; 0x11
    3b12:	9a 89       	ldd	r25, Y+18	; 0x12
    3b14:	0c 96       	adiw	r24, 0x0c	; 12
    3b16:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3b1a:	e9 89       	ldd	r30, Y+17	; 0x11
    3b1c:	fa 89       	ldd	r31, Y+18	; 0x12
    3b1e:	89 89       	ldd	r24, Y+17	; 0x11
    3b20:	9a 89       	ldd	r25, Y+18	; 0x12
    3b22:	91 87       	std	Z+9, r25	; 0x09
    3b24:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3b26:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b28:	28 2f       	mov	r18, r24
    3b2a:	30 e0       	ldi	r19, 0x00	; 0
    3b2c:	85 e0       	ldi	r24, 0x05	; 5
    3b2e:	90 e0       	ldi	r25, 0x00	; 0
    3b30:	82 1b       	sub	r24, r18
    3b32:	93 0b       	sbc	r25, r19
    3b34:	e9 89       	ldd	r30, Y+17	; 0x11
    3b36:	fa 89       	ldd	r31, Y+18	; 0x12
    3b38:	95 87       	std	Z+13, r25	; 0x0d
    3b3a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3b3c:	e9 89       	ldd	r30, Y+17	; 0x11
    3b3e:	fa 89       	ldd	r31, Y+18	; 0x12
    3b40:	89 89       	ldd	r24, Y+17	; 0x11
    3b42:	9a 89       	ldd	r25, Y+18	; 0x12
    3b44:	93 8b       	std	Z+19, r25	; 0x13
    3b46:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    3b48:	e9 89       	ldd	r30, Y+17	; 0x11
    3b4a:	fa 89       	ldd	r31, Y+18	; 0x12
    3b4c:	11 a2       	std	Z+33, r1	; 0x21
    3b4e:	12 a2       	std	Z+34, r1	; 0x22
    3b50:	13 a2       	std	Z+35, r1	; 0x23
    3b52:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3b54:	e9 89       	ldd	r30, Y+17	; 0x11
    3b56:	fa 89       	ldd	r31, Y+18	; 0x12
    3b58:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3b5a:	8a 81       	ldd	r24, Y+2	; 0x02
    3b5c:	9b 81       	ldd	r25, Y+3	; 0x03
    3b5e:	2c 81       	ldd	r18, Y+4	; 0x04
    3b60:	3d 81       	ldd	r19, Y+5	; 0x05
    3b62:	4c 85       	ldd	r20, Y+12	; 0x0c
    3b64:	5d 85       	ldd	r21, Y+13	; 0x0d
    3b66:	b9 01       	movw	r22, r18
    3b68:	0e 94 18 0b 	call	0x1630	; 0x1630 <pxPortInitialiseStack>
    3b6c:	e9 89       	ldd	r30, Y+17	; 0x11
    3b6e:	fa 89       	ldd	r31, Y+18	; 0x12
    3b70:	91 83       	std	Z+1, r25	; 0x01
    3b72:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3b74:	8f 85       	ldd	r24, Y+15	; 0x0f
    3b76:	98 89       	ldd	r25, Y+16	; 0x10
    3b78:	00 97       	sbiw	r24, 0x00	; 0
    3b7a:	31 f0       	breq	.+12     	; 0x3b88 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3b7c:	ef 85       	ldd	r30, Y+15	; 0x0f
    3b7e:	f8 89       	ldd	r31, Y+16	; 0x10
    3b80:	89 89       	ldd	r24, Y+17	; 0x11
    3b82:	9a 89       	ldd	r25, Y+18	; 0x12
    3b84:	91 83       	std	Z+1, r25	; 0x01
    3b86:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3b88:	64 96       	adiw	r28, 0x14	; 20
    3b8a:	0f b6       	in	r0, 0x3f	; 63
    3b8c:	f8 94       	cli
    3b8e:	de bf       	out	0x3e, r29	; 62
    3b90:	0f be       	out	0x3f, r0	; 63
    3b92:	cd bf       	out	0x3d, r28	; 61
    3b94:	cf 91       	pop	r28
    3b96:	df 91       	pop	r29
    3b98:	1f 91       	pop	r17
    3b9a:	0f 91       	pop	r16
    3b9c:	ef 90       	pop	r14
    3b9e:	df 90       	pop	r13
    3ba0:	cf 90       	pop	r12
    3ba2:	bf 90       	pop	r11
    3ba4:	af 90       	pop	r10
    3ba6:	9f 90       	pop	r9
    3ba8:	8f 90       	pop	r8
    3baa:	08 95       	ret

00003bac <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3bac:	df 93       	push	r29
    3bae:	cf 93       	push	r28
    3bb0:	00 d0       	rcall	.+0      	; 0x3bb2 <prvAddNewTaskToReadyList+0x6>
    3bb2:	cd b7       	in	r28, 0x3d	; 61
    3bb4:	de b7       	in	r29, 0x3e	; 62
    3bb6:	9a 83       	std	Y+2, r25	; 0x02
    3bb8:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3bba:	0f b6       	in	r0, 0x3f	; 63
    3bbc:	f8 94       	cli
    3bbe:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3bc0:	80 91 ab 06 	lds	r24, 0x06AB
    3bc4:	8f 5f       	subi	r24, 0xFF	; 255
    3bc6:	80 93 ab 06 	sts	0x06AB, r24
		if( pxCurrentTCB == NULL )
    3bca:	80 91 a8 06 	lds	r24, 0x06A8
    3bce:	90 91 a9 06 	lds	r25, 0x06A9
    3bd2:	00 97       	sbiw	r24, 0x00	; 0
    3bd4:	69 f4       	brne	.+26     	; 0x3bf0 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3bd6:	89 81       	ldd	r24, Y+1	; 0x01
    3bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    3bda:	90 93 a9 06 	sts	0x06A9, r25
    3bde:	80 93 a8 06 	sts	0x06A8, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3be2:	80 91 ab 06 	lds	r24, 0x06AB
    3be6:	81 30       	cpi	r24, 0x01	; 1
    3be8:	b9 f4       	brne	.+46     	; 0x3c18 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3bea:	0e 94 ad 24 	call	0x495a	; 0x495a <prvInitialiseTaskLists>
    3bee:	14 c0       	rjmp	.+40     	; 0x3c18 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3bf0:	80 91 af 06 	lds	r24, 0x06AF
    3bf4:	88 23       	and	r24, r24
    3bf6:	81 f4       	brne	.+32     	; 0x3c18 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3bf8:	e0 91 a8 06 	lds	r30, 0x06A8
    3bfc:	f0 91 a9 06 	lds	r31, 0x06A9
    3c00:	96 89       	ldd	r25, Z+22	; 0x16
    3c02:	e9 81       	ldd	r30, Y+1	; 0x01
    3c04:	fa 81       	ldd	r31, Y+2	; 0x02
    3c06:	86 89       	ldd	r24, Z+22	; 0x16
    3c08:	89 17       	cp	r24, r25
    3c0a:	30 f0       	brcs	.+12     	; 0x3c18 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3c0c:	89 81       	ldd	r24, Y+1	; 0x01
    3c0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c10:	90 93 a9 06 	sts	0x06A9, r25
    3c14:	80 93 a8 06 	sts	0x06A8, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3c18:	80 91 b3 06 	lds	r24, 0x06B3
    3c1c:	8f 5f       	subi	r24, 0xFF	; 255
    3c1e:	80 93 b3 06 	sts	0x06B3, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3c22:	e9 81       	ldd	r30, Y+1	; 0x01
    3c24:	fa 81       	ldd	r31, Y+2	; 0x02
    3c26:	96 89       	ldd	r25, Z+22	; 0x16
    3c28:	80 91 ae 06 	lds	r24, 0x06AE
    3c2c:	89 17       	cp	r24, r25
    3c2e:	28 f4       	brcc	.+10     	; 0x3c3a <prvAddNewTaskToReadyList+0x8e>
    3c30:	e9 81       	ldd	r30, Y+1	; 0x01
    3c32:	fa 81       	ldd	r31, Y+2	; 0x02
    3c34:	86 89       	ldd	r24, Z+22	; 0x16
    3c36:	80 93 ae 06 	sts	0x06AE, r24
    3c3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c3e:	86 89       	ldd	r24, Z+22	; 0x16
    3c40:	28 2f       	mov	r18, r24
    3c42:	30 e0       	ldi	r19, 0x00	; 0
    3c44:	c9 01       	movw	r24, r18
    3c46:	88 0f       	add	r24, r24
    3c48:	99 1f       	adc	r25, r25
    3c4a:	88 0f       	add	r24, r24
    3c4c:	99 1f       	adc	r25, r25
    3c4e:	88 0f       	add	r24, r24
    3c50:	99 1f       	adc	r25, r25
    3c52:	82 0f       	add	r24, r18
    3c54:	93 1f       	adc	r25, r19
    3c56:	ac 01       	movw	r20, r24
    3c58:	47 54       	subi	r20, 0x47	; 71
    3c5a:	59 4f       	sbci	r21, 0xF9	; 249
    3c5c:	89 81       	ldd	r24, Y+1	; 0x01
    3c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c60:	9c 01       	movw	r18, r24
    3c62:	2e 5f       	subi	r18, 0xFE	; 254
    3c64:	3f 4f       	sbci	r19, 0xFF	; 255
    3c66:	ca 01       	movw	r24, r20
    3c68:	b9 01       	movw	r22, r18
    3c6a:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3c6e:	0f 90       	pop	r0
    3c70:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3c72:	80 91 af 06 	lds	r24, 0x06AF
    3c76:	88 23       	and	r24, r24
    3c78:	61 f0       	breq	.+24     	; 0x3c92 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3c7a:	e0 91 a8 06 	lds	r30, 0x06A8
    3c7e:	f0 91 a9 06 	lds	r31, 0x06A9
    3c82:	96 89       	ldd	r25, Z+22	; 0x16
    3c84:	e9 81       	ldd	r30, Y+1	; 0x01
    3c86:	fa 81       	ldd	r31, Y+2	; 0x02
    3c88:	86 89       	ldd	r24, Z+22	; 0x16
    3c8a:	98 17       	cp	r25, r24
    3c8c:	10 f4       	brcc	.+4      	; 0x3c92 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3c8e:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3c92:	0f 90       	pop	r0
    3c94:	0f 90       	pop	r0
    3c96:	cf 91       	pop	r28
    3c98:	df 91       	pop	r29
    3c9a:	08 95       	ret

00003c9c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3c9c:	df 93       	push	r29
    3c9e:	cf 93       	push	r28
    3ca0:	00 d0       	rcall	.+0      	; 0x3ca2 <vTaskDelete+0x6>
    3ca2:	00 d0       	rcall	.+0      	; 0x3ca4 <vTaskDelete+0x8>
    3ca4:	00 d0       	rcall	.+0      	; 0x3ca6 <vTaskDelete+0xa>
    3ca6:	cd b7       	in	r28, 0x3d	; 61
    3ca8:	de b7       	in	r29, 0x3e	; 62
    3caa:	9c 83       	std	Y+4, r25	; 0x04
    3cac:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3cae:	0f b6       	in	r0, 0x3f	; 63
    3cb0:	f8 94       	cli
    3cb2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cb8:	00 97       	sbiw	r24, 0x00	; 0
    3cba:	39 f4       	brne	.+14     	; 0x3cca <vTaskDelete+0x2e>
    3cbc:	80 91 a8 06 	lds	r24, 0x06A8
    3cc0:	90 91 a9 06 	lds	r25, 0x06A9
    3cc4:	9e 83       	std	Y+6, r25	; 0x06
    3cc6:	8d 83       	std	Y+5, r24	; 0x05
    3cc8:	04 c0       	rjmp	.+8      	; 0x3cd2 <vTaskDelete+0x36>
    3cca:	8b 81       	ldd	r24, Y+3	; 0x03
    3ccc:	9c 81       	ldd	r25, Y+4	; 0x04
    3cce:	9e 83       	std	Y+6, r25	; 0x06
    3cd0:	8d 83       	std	Y+5, r24	; 0x05
    3cd2:	8d 81       	ldd	r24, Y+5	; 0x05
    3cd4:	9e 81       	ldd	r25, Y+6	; 0x06
    3cd6:	9a 83       	std	Y+2, r25	; 0x02
    3cd8:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3cda:	89 81       	ldd	r24, Y+1	; 0x01
    3cdc:	9a 81       	ldd	r25, Y+2	; 0x02
    3cde:	02 96       	adiw	r24, 0x02	; 2
    3ce0:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce8:	84 89       	ldd	r24, Z+20	; 0x14
    3cea:	95 89       	ldd	r25, Z+21	; 0x15
    3cec:	00 97       	sbiw	r24, 0x00	; 0
    3cee:	29 f0       	breq	.+10     	; 0x3cfa <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3cf0:	89 81       	ldd	r24, Y+1	; 0x01
    3cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    3cf4:	0c 96       	adiw	r24, 0x0c	; 12
    3cf6:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    3cfa:	80 91 b3 06 	lds	r24, 0x06B3
    3cfe:	8f 5f       	subi	r24, 0xFF	; 255
    3d00:	80 93 b3 06 	sts	0x06B3, r24

			if( pxTCB == pxCurrentTCB )
    3d04:	20 91 a8 06 	lds	r18, 0x06A8
    3d08:	30 91 a9 06 	lds	r19, 0x06A9
    3d0c:	89 81       	ldd	r24, Y+1	; 0x01
    3d0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d10:	82 17       	cp	r24, r18
    3d12:	93 07       	cpc	r25, r19
    3d14:	81 f4       	brne	.+32     	; 0x3d36 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3d16:	89 81       	ldd	r24, Y+1	; 0x01
    3d18:	9a 81       	ldd	r25, Y+2	; 0x02
    3d1a:	9c 01       	movw	r18, r24
    3d1c:	2e 5f       	subi	r18, 0xFE	; 254
    3d1e:	3f 4f       	sbci	r19, 0xFF	; 255
    3d20:	85 e0       	ldi	r24, 0x05	; 5
    3d22:	97 e0       	ldi	r25, 0x07	; 7
    3d24:	b9 01       	movw	r22, r18
    3d26:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    3d2a:	80 91 aa 06 	lds	r24, 0x06AA
    3d2e:	8f 5f       	subi	r24, 0xFF	; 255
    3d30:	80 93 aa 06 	sts	0x06AA, r24
    3d34:	0b c0       	rjmp	.+22     	; 0x3d4c <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    3d36:	80 91 ab 06 	lds	r24, 0x06AB
    3d3a:	81 50       	subi	r24, 0x01	; 1
    3d3c:	80 93 ab 06 	sts	0x06AB, r24
				prvDeleteTCB( pxTCB );
    3d40:	89 81       	ldd	r24, Y+1	; 0x01
    3d42:	9a 81       	ldd	r25, Y+2	; 0x02
    3d44:	0e 94 1d 25 	call	0x4a3a	; 0x4a3a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    3d48:	0e 94 33 25 	call	0x4a66	; 0x4a66 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3d4c:	0f 90       	pop	r0
    3d4e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3d50:	80 91 af 06 	lds	r24, 0x06AF
    3d54:	88 23       	and	r24, r24
    3d56:	59 f0       	breq	.+22     	; 0x3d6e <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    3d58:	20 91 a8 06 	lds	r18, 0x06A8
    3d5c:	30 91 a9 06 	lds	r19, 0x06A9
    3d60:	89 81       	ldd	r24, Y+1	; 0x01
    3d62:	9a 81       	ldd	r25, Y+2	; 0x02
    3d64:	82 17       	cp	r24, r18
    3d66:	93 07       	cpc	r25, r19
    3d68:	11 f4       	brne	.+4      	; 0x3d6e <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3d6a:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3d6e:	26 96       	adiw	r28, 0x06	; 6
    3d70:	0f b6       	in	r0, 0x3f	; 63
    3d72:	f8 94       	cli
    3d74:	de bf       	out	0x3e, r29	; 62
    3d76:	0f be       	out	0x3f, r0	; 63
    3d78:	cd bf       	out	0x3d, r28	; 61
    3d7a:	cf 91       	pop	r28
    3d7c:	df 91       	pop	r29
    3d7e:	08 95       	ret

00003d80 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3d80:	df 93       	push	r29
    3d82:	cf 93       	push	r28
    3d84:	00 d0       	rcall	.+0      	; 0x3d86 <vTaskDelay+0x6>
    3d86:	0f 92       	push	r0
    3d88:	cd b7       	in	r28, 0x3d	; 61
    3d8a:	de b7       	in	r29, 0x3e	; 62
    3d8c:	9b 83       	std	Y+3, r25	; 0x03
    3d8e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3d90:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3d92:	8a 81       	ldd	r24, Y+2	; 0x02
    3d94:	9b 81       	ldd	r25, Y+3	; 0x03
    3d96:	00 97       	sbiw	r24, 0x00	; 0
    3d98:	51 f0       	breq	.+20     	; 0x3dae <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3d9a:	0e 94 8d 20 	call	0x411a	; 0x411a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    3da0:	9b 81       	ldd	r25, Y+3	; 0x03
    3da2:	60 e0       	ldi	r22, 0x00	; 0
    3da4:	0e 94 3f 29 	call	0x527e	; 0x527e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3da8:	0e 94 99 20 	call	0x4132	; 0x4132 <xTaskResumeAll>
    3dac:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3dae:	89 81       	ldd	r24, Y+1	; 0x01
    3db0:	88 23       	and	r24, r24
    3db2:	11 f4       	brne	.+4      	; 0x3db8 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3db4:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3db8:	0f 90       	pop	r0
    3dba:	0f 90       	pop	r0
    3dbc:	0f 90       	pop	r0
    3dbe:	cf 91       	pop	r28
    3dc0:	df 91       	pop	r29
    3dc2:	08 95       	ret

00003dc4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3dc4:	df 93       	push	r29
    3dc6:	cf 93       	push	r28
    3dc8:	00 d0       	rcall	.+0      	; 0x3dca <vTaskSuspend+0x6>
    3dca:	00 d0       	rcall	.+0      	; 0x3dcc <vTaskSuspend+0x8>
    3dcc:	00 d0       	rcall	.+0      	; 0x3dce <vTaskSuspend+0xa>
    3dce:	cd b7       	in	r28, 0x3d	; 61
    3dd0:	de b7       	in	r29, 0x3e	; 62
    3dd2:	9c 83       	std	Y+4, r25	; 0x04
    3dd4:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3dd6:	0f b6       	in	r0, 0x3f	; 63
    3dd8:	f8 94       	cli
    3dda:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    3dde:	9c 81       	ldd	r25, Y+4	; 0x04
    3de0:	00 97       	sbiw	r24, 0x00	; 0
    3de2:	39 f4       	brne	.+14     	; 0x3df2 <vTaskSuspend+0x2e>
    3de4:	80 91 a8 06 	lds	r24, 0x06A8
    3de8:	90 91 a9 06 	lds	r25, 0x06A9
    3dec:	9e 83       	std	Y+6, r25	; 0x06
    3dee:	8d 83       	std	Y+5, r24	; 0x05
    3df0:	04 c0       	rjmp	.+8      	; 0x3dfa <vTaskSuspend+0x36>
    3df2:	8b 81       	ldd	r24, Y+3	; 0x03
    3df4:	9c 81       	ldd	r25, Y+4	; 0x04
    3df6:	9e 83       	std	Y+6, r25	; 0x06
    3df8:	8d 83       	std	Y+5, r24	; 0x05
    3dfa:	8d 81       	ldd	r24, Y+5	; 0x05
    3dfc:	9e 81       	ldd	r25, Y+6	; 0x06
    3dfe:	9a 83       	std	Y+2, r25	; 0x02
    3e00:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3e02:	89 81       	ldd	r24, Y+1	; 0x01
    3e04:	9a 81       	ldd	r25, Y+2	; 0x02
    3e06:	02 96       	adiw	r24, 0x02	; 2
    3e08:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e10:	84 89       	ldd	r24, Z+20	; 0x14
    3e12:	95 89       	ldd	r25, Z+21	; 0x15
    3e14:	00 97       	sbiw	r24, 0x00	; 0
    3e16:	29 f0       	breq	.+10     	; 0x3e22 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3e18:	89 81       	ldd	r24, Y+1	; 0x01
    3e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e1c:	0c 96       	adiw	r24, 0x0c	; 12
    3e1e:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3e22:	89 81       	ldd	r24, Y+1	; 0x01
    3e24:	9a 81       	ldd	r25, Y+2	; 0x02
    3e26:	9c 01       	movw	r18, r24
    3e28:	2e 5f       	subi	r18, 0xFE	; 254
    3e2a:	3f 4f       	sbci	r19, 0xFF	; 255
    3e2c:	8e e0       	ldi	r24, 0x0E	; 14
    3e2e:	97 e0       	ldi	r25, 0x07	; 7
    3e30:	b9 01       	movw	r22, r18
    3e32:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3e36:	e9 81       	ldd	r30, Y+1	; 0x01
    3e38:	fa 81       	ldd	r31, Y+2	; 0x02
    3e3a:	85 a1       	ldd	r24, Z+37	; 0x25
    3e3c:	81 30       	cpi	r24, 0x01	; 1
    3e3e:	19 f4       	brne	.+6      	; 0x3e46 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3e40:	e9 81       	ldd	r30, Y+1	; 0x01
    3e42:	fa 81       	ldd	r31, Y+2	; 0x02
    3e44:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    3e46:	0f 90       	pop	r0
    3e48:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3e4a:	80 91 af 06 	lds	r24, 0x06AF
    3e4e:	88 23       	and	r24, r24
    3e50:	39 f0       	breq	.+14     	; 0x3e60 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3e52:	0f b6       	in	r0, 0x3f	; 63
    3e54:	f8 94       	cli
    3e56:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3e58:	0e 94 33 25 	call	0x4a66	; 0x4a66 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3e5c:	0f 90       	pop	r0
    3e5e:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3e60:	20 91 a8 06 	lds	r18, 0x06A8
    3e64:	30 91 a9 06 	lds	r19, 0x06A9
    3e68:	89 81       	ldd	r24, Y+1	; 0x01
    3e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e6c:	82 17       	cp	r24, r18
    3e6e:	93 07       	cpc	r25, r19
    3e70:	a1 f4       	brne	.+40     	; 0x3e9a <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3e72:	80 91 af 06 	lds	r24, 0x06AF
    3e76:	88 23       	and	r24, r24
    3e78:	19 f0       	breq	.+6      	; 0x3e80 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3e7a:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
    3e7e:	0d c0       	rjmp	.+26     	; 0x3e9a <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3e80:	90 91 0e 07 	lds	r25, 0x070E
    3e84:	80 91 ab 06 	lds	r24, 0x06AB
    3e88:	98 17       	cp	r25, r24
    3e8a:	29 f4       	brne	.+10     	; 0x3e96 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3e8c:	10 92 a9 06 	sts	0x06A9, r1
    3e90:	10 92 a8 06 	sts	0x06A8, r1
    3e94:	02 c0       	rjmp	.+4      	; 0x3e9a <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    3e96:	0e 94 6e 22 	call	0x44dc	; 0x44dc <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3e9a:	26 96       	adiw	r28, 0x06	; 6
    3e9c:	0f b6       	in	r0, 0x3f	; 63
    3e9e:	f8 94       	cli
    3ea0:	de bf       	out	0x3e, r29	; 62
    3ea2:	0f be       	out	0x3f, r0	; 63
    3ea4:	cd bf       	out	0x3d, r28	; 61
    3ea6:	cf 91       	pop	r28
    3ea8:	df 91       	pop	r29
    3eaa:	08 95       	ret

00003eac <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3eac:	df 93       	push	r29
    3eae:	cf 93       	push	r28
    3eb0:	00 d0       	rcall	.+0      	; 0x3eb2 <prvTaskIsTaskSuspended+0x6>
    3eb2:	00 d0       	rcall	.+0      	; 0x3eb4 <prvTaskIsTaskSuspended+0x8>
    3eb4:	0f 92       	push	r0
    3eb6:	cd b7       	in	r28, 0x3d	; 61
    3eb8:	de b7       	in	r29, 0x3e	; 62
    3eba:	9d 83       	std	Y+5, r25	; 0x05
    3ebc:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3ebe:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3ec0:	8c 81       	ldd	r24, Y+4	; 0x04
    3ec2:	9d 81       	ldd	r25, Y+5	; 0x05
    3ec4:	9a 83       	std	Y+2, r25	; 0x02
    3ec6:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3ec8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eca:	fa 81       	ldd	r31, Y+2	; 0x02
    3ecc:	82 85       	ldd	r24, Z+10	; 0x0a
    3ece:	93 85       	ldd	r25, Z+11	; 0x0b
    3ed0:	27 e0       	ldi	r18, 0x07	; 7
    3ed2:	8e 30       	cpi	r24, 0x0E	; 14
    3ed4:	92 07       	cpc	r25, r18
    3ed6:	81 f4       	brne	.+32     	; 0x3ef8 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3ed8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eda:	fa 81       	ldd	r31, Y+2	; 0x02
    3edc:	84 89       	ldd	r24, Z+20	; 0x14
    3ede:	95 89       	ldd	r25, Z+21	; 0x15
    3ee0:	26 e0       	ldi	r18, 0x06	; 6
    3ee2:	8c 3f       	cpi	r24, 0xFC	; 252
    3ee4:	92 07       	cpc	r25, r18
    3ee6:	41 f0       	breq	.+16     	; 0x3ef8 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3ee8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eea:	fa 81       	ldd	r31, Y+2	; 0x02
    3eec:	84 89       	ldd	r24, Z+20	; 0x14
    3eee:	95 89       	ldd	r25, Z+21	; 0x15
    3ef0:	00 97       	sbiw	r24, 0x00	; 0
    3ef2:	11 f4       	brne	.+4      	; 0x3ef8 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3ef4:	81 e0       	ldi	r24, 0x01	; 1
    3ef6:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3ef8:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3efa:	0f 90       	pop	r0
    3efc:	0f 90       	pop	r0
    3efe:	0f 90       	pop	r0
    3f00:	0f 90       	pop	r0
    3f02:	0f 90       	pop	r0
    3f04:	cf 91       	pop	r28
    3f06:	df 91       	pop	r29
    3f08:	08 95       	ret

00003f0a <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3f0a:	df 93       	push	r29
    3f0c:	cf 93       	push	r28
    3f0e:	00 d0       	rcall	.+0      	; 0x3f10 <vTaskResume+0x6>
    3f10:	00 d0       	rcall	.+0      	; 0x3f12 <vTaskResume+0x8>
    3f12:	cd b7       	in	r28, 0x3d	; 61
    3f14:	de b7       	in	r29, 0x3e	; 62
    3f16:	9c 83       	std	Y+4, r25	; 0x04
    3f18:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    3f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    3f1c:	9c 81       	ldd	r25, Y+4	; 0x04
    3f1e:	9a 83       	std	Y+2, r25	; 0x02
    3f20:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3f22:	20 91 a8 06 	lds	r18, 0x06A8
    3f26:	30 91 a9 06 	lds	r19, 0x06A9
    3f2a:	89 81       	ldd	r24, Y+1	; 0x01
    3f2c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f2e:	82 17       	cp	r24, r18
    3f30:	93 07       	cpc	r25, r19
    3f32:	09 f4       	brne	.+2      	; 0x3f36 <vTaskResume+0x2c>
    3f34:	47 c0       	rjmp	.+142    	; 0x3fc4 <vTaskResume+0xba>
    3f36:	89 81       	ldd	r24, Y+1	; 0x01
    3f38:	9a 81       	ldd	r25, Y+2	; 0x02
    3f3a:	00 97       	sbiw	r24, 0x00	; 0
    3f3c:	09 f4       	brne	.+2      	; 0x3f40 <vTaskResume+0x36>
    3f3e:	42 c0       	rjmp	.+132    	; 0x3fc4 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3f40:	0f b6       	in	r0, 0x3f	; 63
    3f42:	f8 94       	cli
    3f44:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3f46:	89 81       	ldd	r24, Y+1	; 0x01
    3f48:	9a 81       	ldd	r25, Y+2	; 0x02
    3f4a:	0e 94 56 1f 	call	0x3eac	; 0x3eac <prvTaskIsTaskSuspended>
    3f4e:	88 23       	and	r24, r24
    3f50:	b9 f1       	breq	.+110    	; 0x3fc0 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    3f52:	89 81       	ldd	r24, Y+1	; 0x01
    3f54:	9a 81       	ldd	r25, Y+2	; 0x02
    3f56:	02 96       	adiw	r24, 0x02	; 2
    3f58:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3f5c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f5e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f60:	96 89       	ldd	r25, Z+22	; 0x16
    3f62:	80 91 ae 06 	lds	r24, 0x06AE
    3f66:	89 17       	cp	r24, r25
    3f68:	28 f4       	brcc	.+10     	; 0x3f74 <vTaskResume+0x6a>
    3f6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f6e:	86 89       	ldd	r24, Z+22	; 0x16
    3f70:	80 93 ae 06 	sts	0x06AE, r24
    3f74:	e9 81       	ldd	r30, Y+1	; 0x01
    3f76:	fa 81       	ldd	r31, Y+2	; 0x02
    3f78:	86 89       	ldd	r24, Z+22	; 0x16
    3f7a:	28 2f       	mov	r18, r24
    3f7c:	30 e0       	ldi	r19, 0x00	; 0
    3f7e:	c9 01       	movw	r24, r18
    3f80:	88 0f       	add	r24, r24
    3f82:	99 1f       	adc	r25, r25
    3f84:	88 0f       	add	r24, r24
    3f86:	99 1f       	adc	r25, r25
    3f88:	88 0f       	add	r24, r24
    3f8a:	99 1f       	adc	r25, r25
    3f8c:	82 0f       	add	r24, r18
    3f8e:	93 1f       	adc	r25, r19
    3f90:	ac 01       	movw	r20, r24
    3f92:	47 54       	subi	r20, 0x47	; 71
    3f94:	59 4f       	sbci	r21, 0xF9	; 249
    3f96:	89 81       	ldd	r24, Y+1	; 0x01
    3f98:	9a 81       	ldd	r25, Y+2	; 0x02
    3f9a:	9c 01       	movw	r18, r24
    3f9c:	2e 5f       	subi	r18, 0xFE	; 254
    3f9e:	3f 4f       	sbci	r19, 0xFF	; 255
    3fa0:	ca 01       	movw	r24, r20
    3fa2:	b9 01       	movw	r22, r18
    3fa4:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3fa8:	e9 81       	ldd	r30, Y+1	; 0x01
    3faa:	fa 81       	ldd	r31, Y+2	; 0x02
    3fac:	96 89       	ldd	r25, Z+22	; 0x16
    3fae:	e0 91 a8 06 	lds	r30, 0x06A8
    3fb2:	f0 91 a9 06 	lds	r31, 0x06A9
    3fb6:	86 89       	ldd	r24, Z+22	; 0x16
    3fb8:	98 17       	cp	r25, r24
    3fba:	10 f0       	brcs	.+4      	; 0x3fc0 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    3fbc:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3fc0:	0f 90       	pop	r0
    3fc2:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3fc4:	0f 90       	pop	r0
    3fc6:	0f 90       	pop	r0
    3fc8:	0f 90       	pop	r0
    3fca:	0f 90       	pop	r0
    3fcc:	cf 91       	pop	r28
    3fce:	df 91       	pop	r29
    3fd0:	08 95       	ret

00003fd2 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    3fd2:	df 93       	push	r29
    3fd4:	cf 93       	push	r28
    3fd6:	00 d0       	rcall	.+0      	; 0x3fd8 <xTaskResumeFromISR+0x6>
    3fd8:	00 d0       	rcall	.+0      	; 0x3fda <xTaskResumeFromISR+0x8>
    3fda:	00 d0       	rcall	.+0      	; 0x3fdc <xTaskResumeFromISR+0xa>
    3fdc:	cd b7       	in	r28, 0x3d	; 61
    3fde:	de b7       	in	r29, 0x3e	; 62
    3fe0:	9e 83       	std	Y+6, r25	; 0x06
    3fe2:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    3fe4:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    3fe6:	8d 81       	ldd	r24, Y+5	; 0x05
    3fe8:	9e 81       	ldd	r25, Y+6	; 0x06
    3fea:	9b 83       	std	Y+3, r25	; 0x03
    3fec:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3fee:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3ff0:	8a 81       	ldd	r24, Y+2	; 0x02
    3ff2:	9b 81       	ldd	r25, Y+3	; 0x03
    3ff4:	0e 94 56 1f 	call	0x3eac	; 0x3eac <prvTaskIsTaskSuspended>
    3ff8:	88 23       	and	r24, r24
    3ffa:	09 f4       	brne	.+2      	; 0x3ffe <xTaskResumeFromISR+0x2c>
    3ffc:	46 c0       	rjmp	.+140    	; 0x408a <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ffe:	80 91 b8 06 	lds	r24, 0x06B8
    4002:	88 23       	and	r24, r24
    4004:	c1 f5       	brne	.+112    	; 0x4076 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4006:	ea 81       	ldd	r30, Y+2	; 0x02
    4008:	fb 81       	ldd	r31, Y+3	; 0x03
    400a:	96 89       	ldd	r25, Z+22	; 0x16
    400c:	e0 91 a8 06 	lds	r30, 0x06A8
    4010:	f0 91 a9 06 	lds	r31, 0x06A9
    4014:	86 89       	ldd	r24, Z+22	; 0x16
    4016:	98 17       	cp	r25, r24
    4018:	10 f0       	brcs	.+4      	; 0x401e <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    401a:	81 e0       	ldi	r24, 0x01	; 1
    401c:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    401e:	8a 81       	ldd	r24, Y+2	; 0x02
    4020:	9b 81       	ldd	r25, Y+3	; 0x03
    4022:	02 96       	adiw	r24, 0x02	; 2
    4024:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4028:	ea 81       	ldd	r30, Y+2	; 0x02
    402a:	fb 81       	ldd	r31, Y+3	; 0x03
    402c:	96 89       	ldd	r25, Z+22	; 0x16
    402e:	80 91 ae 06 	lds	r24, 0x06AE
    4032:	89 17       	cp	r24, r25
    4034:	28 f4       	brcc	.+10     	; 0x4040 <xTaskResumeFromISR+0x6e>
    4036:	ea 81       	ldd	r30, Y+2	; 0x02
    4038:	fb 81       	ldd	r31, Y+3	; 0x03
    403a:	86 89       	ldd	r24, Z+22	; 0x16
    403c:	80 93 ae 06 	sts	0x06AE, r24
    4040:	ea 81       	ldd	r30, Y+2	; 0x02
    4042:	fb 81       	ldd	r31, Y+3	; 0x03
    4044:	86 89       	ldd	r24, Z+22	; 0x16
    4046:	28 2f       	mov	r18, r24
    4048:	30 e0       	ldi	r19, 0x00	; 0
    404a:	c9 01       	movw	r24, r18
    404c:	88 0f       	add	r24, r24
    404e:	99 1f       	adc	r25, r25
    4050:	88 0f       	add	r24, r24
    4052:	99 1f       	adc	r25, r25
    4054:	88 0f       	add	r24, r24
    4056:	99 1f       	adc	r25, r25
    4058:	82 0f       	add	r24, r18
    405a:	93 1f       	adc	r25, r19
    405c:	ac 01       	movw	r20, r24
    405e:	47 54       	subi	r20, 0x47	; 71
    4060:	59 4f       	sbci	r21, 0xF9	; 249
    4062:	8a 81       	ldd	r24, Y+2	; 0x02
    4064:	9b 81       	ldd	r25, Y+3	; 0x03
    4066:	9c 01       	movw	r18, r24
    4068:	2e 5f       	subi	r18, 0xFE	; 254
    406a:	3f 4f       	sbci	r19, 0xFF	; 255
    406c:	ca 01       	movw	r24, r20
    406e:	b9 01       	movw	r22, r18
    4070:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    4074:	0a c0       	rjmp	.+20     	; 0x408a <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4076:	8a 81       	ldd	r24, Y+2	; 0x02
    4078:	9b 81       	ldd	r25, Y+3	; 0x03
    407a:	9c 01       	movw	r18, r24
    407c:	24 5f       	subi	r18, 0xF4	; 244
    407e:	3f 4f       	sbci	r19, 0xFF	; 255
    4080:	8c ef       	ldi	r24, 0xFC	; 252
    4082:	96 e0       	ldi	r25, 0x06	; 6
    4084:	b9 01       	movw	r22, r18
    4086:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    408a:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    408c:	26 96       	adiw	r28, 0x06	; 6
    408e:	0f b6       	in	r0, 0x3f	; 63
    4090:	f8 94       	cli
    4092:	de bf       	out	0x3e, r29	; 62
    4094:	0f be       	out	0x3f, r0	; 63
    4096:	cd bf       	out	0x3d, r28	; 61
    4098:	cf 91       	pop	r28
    409a:	df 91       	pop	r29
    409c:	08 95       	ret

0000409e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    409e:	ef 92       	push	r14
    40a0:	ff 92       	push	r15
    40a2:	0f 93       	push	r16
    40a4:	df 93       	push	r29
    40a6:	cf 93       	push	r28
    40a8:	0f 92       	push	r0
    40aa:	cd b7       	in	r28, 0x3d	; 61
    40ac:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    40ae:	83 ea       	ldi	r24, 0xA3	; 163
    40b0:	94 e2       	ldi	r25, 0x24	; 36
    40b2:	2a eb       	ldi	r18, 0xBA	; 186
    40b4:	30 e0       	ldi	r19, 0x00	; 0
    40b6:	e6 eb       	ldi	r30, 0xB6	; 182
    40b8:	f6 e0       	ldi	r31, 0x06	; 6
    40ba:	b9 01       	movw	r22, r18
    40bc:	46 e9       	ldi	r20, 0x96	; 150
    40be:	50 e0       	ldi	r21, 0x00	; 0
    40c0:	20 e0       	ldi	r18, 0x00	; 0
    40c2:	30 e0       	ldi	r19, 0x00	; 0
    40c4:	00 e0       	ldi	r16, 0x00	; 0
    40c6:	7f 01       	movw	r14, r30
    40c8:	0e 94 a2 1c 	call	0x3944	; 0x3944 <xTaskCreate>
    40cc:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    40ce:	89 81       	ldd	r24, Y+1	; 0x01
    40d0:	81 30       	cpi	r24, 0x01	; 1
    40d2:	81 f4       	brne	.+32     	; 0x40f4 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    40d4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    40d6:	8f ef       	ldi	r24, 0xFF	; 255
    40d8:	9f ef       	ldi	r25, 0xFF	; 255
    40da:	90 93 b5 06 	sts	0x06B5, r25
    40de:	80 93 b4 06 	sts	0x06B4, r24
		xSchedulerRunning = pdTRUE;
    40e2:	81 e0       	ldi	r24, 0x01	; 1
    40e4:	80 93 af 06 	sts	0x06AF, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    40e8:	10 92 ad 06 	sts	0x06AD, r1
    40ec:	10 92 ac 06 	sts	0x06AC, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    40f0:	0e 94 9b 0c 	call	0x1936	; 0x1936 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    40f4:	0f 90       	pop	r0
    40f6:	cf 91       	pop	r28
    40f8:	df 91       	pop	r29
    40fa:	0f 91       	pop	r16
    40fc:	ff 90       	pop	r15
    40fe:	ef 90       	pop	r14
    4100:	08 95       	ret

00004102 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4102:	df 93       	push	r29
    4104:	cf 93       	push	r28
    4106:	cd b7       	in	r28, 0x3d	; 61
    4108:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    410a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    410c:	10 92 af 06 	sts	0x06AF, r1
	vPortEndScheduler();
    4110:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <vPortEndScheduler>
}
    4114:	cf 91       	pop	r28
    4116:	df 91       	pop	r29
    4118:	08 95       	ret

0000411a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    411a:	df 93       	push	r29
    411c:	cf 93       	push	r28
    411e:	cd b7       	in	r28, 0x3d	; 61
    4120:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4122:	80 91 b8 06 	lds	r24, 0x06B8
    4126:	8f 5f       	subi	r24, 0xFF	; 255
    4128:	80 93 b8 06 	sts	0x06B8, r24
}
    412c:	cf 91       	pop	r28
    412e:	df 91       	pop	r29
    4130:	08 95       	ret

00004132 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4132:	df 93       	push	r29
    4134:	cf 93       	push	r28
    4136:	00 d0       	rcall	.+0      	; 0x4138 <xTaskResumeAll+0x6>
    4138:	00 d0       	rcall	.+0      	; 0x413a <xTaskResumeAll+0x8>
    413a:	cd b7       	in	r28, 0x3d	; 61
    413c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    413e:	1c 82       	std	Y+4, r1	; 0x04
    4140:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    4142:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4144:	0f b6       	in	r0, 0x3f	; 63
    4146:	f8 94       	cli
    4148:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    414a:	80 91 b8 06 	lds	r24, 0x06B8
    414e:	81 50       	subi	r24, 0x01	; 1
    4150:	80 93 b8 06 	sts	0x06B8, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4154:	80 91 b8 06 	lds	r24, 0x06B8
    4158:	88 23       	and	r24, r24
    415a:	09 f0       	breq	.+2      	; 0x415e <xTaskResumeAll+0x2c>
    415c:	73 c0       	rjmp	.+230    	; 0x4244 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    415e:	80 91 ab 06 	lds	r24, 0x06AB
    4162:	88 23       	and	r24, r24
    4164:	09 f4       	brne	.+2      	; 0x4168 <xTaskResumeAll+0x36>
    4166:	6e c0       	rjmp	.+220    	; 0x4244 <xTaskResumeAll+0x112>
    4168:	45 c0       	rjmp	.+138    	; 0x41f4 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    416a:	e0 91 01 07 	lds	r30, 0x0701
    416e:	f0 91 02 07 	lds	r31, 0x0702
    4172:	86 81       	ldd	r24, Z+6	; 0x06
    4174:	97 81       	ldd	r25, Z+7	; 0x07
    4176:	9c 83       	std	Y+4, r25	; 0x04
    4178:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    417a:	8b 81       	ldd	r24, Y+3	; 0x03
    417c:	9c 81       	ldd	r25, Y+4	; 0x04
    417e:	0c 96       	adiw	r24, 0x0c	; 12
    4180:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4184:	8b 81       	ldd	r24, Y+3	; 0x03
    4186:	9c 81       	ldd	r25, Y+4	; 0x04
    4188:	02 96       	adiw	r24, 0x02	; 2
    418a:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    418e:	eb 81       	ldd	r30, Y+3	; 0x03
    4190:	fc 81       	ldd	r31, Y+4	; 0x04
    4192:	96 89       	ldd	r25, Z+22	; 0x16
    4194:	80 91 ae 06 	lds	r24, 0x06AE
    4198:	89 17       	cp	r24, r25
    419a:	28 f4       	brcc	.+10     	; 0x41a6 <xTaskResumeAll+0x74>
    419c:	eb 81       	ldd	r30, Y+3	; 0x03
    419e:	fc 81       	ldd	r31, Y+4	; 0x04
    41a0:	86 89       	ldd	r24, Z+22	; 0x16
    41a2:	80 93 ae 06 	sts	0x06AE, r24
    41a6:	eb 81       	ldd	r30, Y+3	; 0x03
    41a8:	fc 81       	ldd	r31, Y+4	; 0x04
    41aa:	86 89       	ldd	r24, Z+22	; 0x16
    41ac:	28 2f       	mov	r18, r24
    41ae:	30 e0       	ldi	r19, 0x00	; 0
    41b0:	c9 01       	movw	r24, r18
    41b2:	88 0f       	add	r24, r24
    41b4:	99 1f       	adc	r25, r25
    41b6:	88 0f       	add	r24, r24
    41b8:	99 1f       	adc	r25, r25
    41ba:	88 0f       	add	r24, r24
    41bc:	99 1f       	adc	r25, r25
    41be:	82 0f       	add	r24, r18
    41c0:	93 1f       	adc	r25, r19
    41c2:	ac 01       	movw	r20, r24
    41c4:	47 54       	subi	r20, 0x47	; 71
    41c6:	59 4f       	sbci	r21, 0xF9	; 249
    41c8:	8b 81       	ldd	r24, Y+3	; 0x03
    41ca:	9c 81       	ldd	r25, Y+4	; 0x04
    41cc:	9c 01       	movw	r18, r24
    41ce:	2e 5f       	subi	r18, 0xFE	; 254
    41d0:	3f 4f       	sbci	r19, 0xFF	; 255
    41d2:	ca 01       	movw	r24, r20
    41d4:	b9 01       	movw	r22, r18
    41d6:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    41da:	eb 81       	ldd	r30, Y+3	; 0x03
    41dc:	fc 81       	ldd	r31, Y+4	; 0x04
    41de:	96 89       	ldd	r25, Z+22	; 0x16
    41e0:	e0 91 a8 06 	lds	r30, 0x06A8
    41e4:	f0 91 a9 06 	lds	r31, 0x06A9
    41e8:	86 89       	ldd	r24, Z+22	; 0x16
    41ea:	98 17       	cp	r25, r24
    41ec:	18 f0       	brcs	.+6      	; 0x41f4 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    41ee:	81 e0       	ldi	r24, 0x01	; 1
    41f0:	80 93 b1 06 	sts	0x06B1, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    41f4:	80 91 fc 06 	lds	r24, 0x06FC
    41f8:	88 23       	and	r24, r24
    41fa:	09 f0       	breq	.+2      	; 0x41fe <xTaskResumeAll+0xcc>
    41fc:	b6 cf       	rjmp	.-148    	; 0x416a <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    41fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4200:	9c 81       	ldd	r25, Y+4	; 0x04
    4202:	00 97       	sbiw	r24, 0x00	; 0
    4204:	11 f0       	breq	.+4      	; 0x420a <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4206:	0e 94 33 25 	call	0x4a66	; 0x4a66 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    420a:	80 91 b0 06 	lds	r24, 0x06B0
    420e:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4210:	89 81       	ldd	r24, Y+1	; 0x01
    4212:	88 23       	and	r24, r24
    4214:	79 f0       	breq	.+30     	; 0x4234 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4216:	0e 94 89 21 	call	0x4312	; 0x4312 <xTaskIncrementTick>
    421a:	88 23       	and	r24, r24
    421c:	19 f0       	breq	.+6      	; 0x4224 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    421e:	81 e0       	ldi	r24, 0x01	; 1
    4220:	80 93 b1 06 	sts	0x06B1, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4224:	89 81       	ldd	r24, Y+1	; 0x01
    4226:	81 50       	subi	r24, 0x01	; 1
    4228:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    422a:	89 81       	ldd	r24, Y+1	; 0x01
    422c:	88 23       	and	r24, r24
    422e:	99 f7       	brne	.-26     	; 0x4216 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    4230:	10 92 b0 06 	sts	0x06B0, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4234:	80 91 b1 06 	lds	r24, 0x06B1
    4238:	88 23       	and	r24, r24
    423a:	21 f0       	breq	.+8      	; 0x4244 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    423c:	81 e0       	ldi	r24, 0x01	; 1
    423e:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4240:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4244:	0f 90       	pop	r0
    4246:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4248:	8a 81       	ldd	r24, Y+2	; 0x02
}
    424a:	0f 90       	pop	r0
    424c:	0f 90       	pop	r0
    424e:	0f 90       	pop	r0
    4250:	0f 90       	pop	r0
    4252:	cf 91       	pop	r28
    4254:	df 91       	pop	r29
    4256:	08 95       	ret

00004258 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4258:	df 93       	push	r29
    425a:	cf 93       	push	r28
    425c:	00 d0       	rcall	.+0      	; 0x425e <xTaskGetTickCount+0x6>
    425e:	cd b7       	in	r28, 0x3d	; 61
    4260:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4262:	0f b6       	in	r0, 0x3f	; 63
    4264:	f8 94       	cli
    4266:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4268:	80 91 ac 06 	lds	r24, 0x06AC
    426c:	90 91 ad 06 	lds	r25, 0x06AD
    4270:	9a 83       	std	Y+2, r25	; 0x02
    4272:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4274:	0f 90       	pop	r0
    4276:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4278:	89 81       	ldd	r24, Y+1	; 0x01
    427a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    427c:	0f 90       	pop	r0
    427e:	0f 90       	pop	r0
    4280:	cf 91       	pop	r28
    4282:	df 91       	pop	r29
    4284:	08 95       	ret

00004286 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    4286:	df 93       	push	r29
    4288:	cf 93       	push	r28
    428a:	00 d0       	rcall	.+0      	; 0x428c <xTaskGetTickCountFromISR+0x6>
    428c:	0f 92       	push	r0
    428e:	cd b7       	in	r28, 0x3d	; 61
    4290:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    4292:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    4294:	80 91 ac 06 	lds	r24, 0x06AC
    4298:	90 91 ad 06 	lds	r25, 0x06AD
    429c:	9b 83       	std	Y+3, r25	; 0x03
    429e:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    42a0:	8a 81       	ldd	r24, Y+2	; 0x02
    42a2:	9b 81       	ldd	r25, Y+3	; 0x03
}
    42a4:	0f 90       	pop	r0
    42a6:	0f 90       	pop	r0
    42a8:	0f 90       	pop	r0
    42aa:	cf 91       	pop	r28
    42ac:	df 91       	pop	r29
    42ae:	08 95       	ret

000042b0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    42b0:	df 93       	push	r29
    42b2:	cf 93       	push	r28
    42b4:	cd b7       	in	r28, 0x3d	; 61
    42b6:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    42b8:	80 91 ab 06 	lds	r24, 0x06AB
}
    42bc:	cf 91       	pop	r28
    42be:	df 91       	pop	r29
    42c0:	08 95       	ret

000042c2 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    42c2:	df 93       	push	r29
    42c4:	cf 93       	push	r28
    42c6:	00 d0       	rcall	.+0      	; 0x42c8 <pcTaskGetName+0x6>
    42c8:	00 d0       	rcall	.+0      	; 0x42ca <pcTaskGetName+0x8>
    42ca:	00 d0       	rcall	.+0      	; 0x42cc <pcTaskGetName+0xa>
    42cc:	cd b7       	in	r28, 0x3d	; 61
    42ce:	de b7       	in	r29, 0x3e	; 62
    42d0:	9c 83       	std	Y+4, r25	; 0x04
    42d2:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    42d4:	8b 81       	ldd	r24, Y+3	; 0x03
    42d6:	9c 81       	ldd	r25, Y+4	; 0x04
    42d8:	00 97       	sbiw	r24, 0x00	; 0
    42da:	39 f4       	brne	.+14     	; 0x42ea <pcTaskGetName+0x28>
    42dc:	80 91 a8 06 	lds	r24, 0x06A8
    42e0:	90 91 a9 06 	lds	r25, 0x06A9
    42e4:	9e 83       	std	Y+6, r25	; 0x06
    42e6:	8d 83       	std	Y+5, r24	; 0x05
    42e8:	04 c0       	rjmp	.+8      	; 0x42f2 <pcTaskGetName+0x30>
    42ea:	8b 81       	ldd	r24, Y+3	; 0x03
    42ec:	9c 81       	ldd	r25, Y+4	; 0x04
    42ee:	9e 83       	std	Y+6, r25	; 0x06
    42f0:	8d 83       	std	Y+5, r24	; 0x05
    42f2:	8d 81       	ldd	r24, Y+5	; 0x05
    42f4:	9e 81       	ldd	r25, Y+6	; 0x06
    42f6:	9a 83       	std	Y+2, r25	; 0x02
    42f8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    42fa:	89 81       	ldd	r24, Y+1	; 0x01
    42fc:	9a 81       	ldd	r25, Y+2	; 0x02
    42fe:	49 96       	adiw	r24, 0x19	; 25
}
    4300:	26 96       	adiw	r28, 0x06	; 6
    4302:	0f b6       	in	r0, 0x3f	; 63
    4304:	f8 94       	cli
    4306:	de bf       	out	0x3e, r29	; 62
    4308:	0f be       	out	0x3f, r0	; 63
    430a:	cd bf       	out	0x3d, r28	; 61
    430c:	cf 91       	pop	r28
    430e:	df 91       	pop	r29
    4310:	08 95       	ret

00004312 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4312:	df 93       	push	r29
    4314:	cf 93       	push	r28
    4316:	cd b7       	in	r28, 0x3d	; 61
    4318:	de b7       	in	r29, 0x3e	; 62
    431a:	29 97       	sbiw	r28, 0x09	; 9
    431c:	0f b6       	in	r0, 0x3f	; 63
    431e:	f8 94       	cli
    4320:	de bf       	out	0x3e, r29	; 62
    4322:	0f be       	out	0x3f, r0	; 63
    4324:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4326:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4328:	80 91 b8 06 	lds	r24, 0x06B8
    432c:	88 23       	and	r24, r24
    432e:	09 f0       	breq	.+2      	; 0x4332 <xTaskIncrementTick+0x20>
    4330:	c0 c0       	rjmp	.+384    	; 0x44b2 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4332:	80 91 ac 06 	lds	r24, 0x06AC
    4336:	90 91 ad 06 	lds	r25, 0x06AD
    433a:	01 96       	adiw	r24, 0x01	; 1
    433c:	9c 83       	std	Y+4, r25	; 0x04
    433e:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4340:	8b 81       	ldd	r24, Y+3	; 0x03
    4342:	9c 81       	ldd	r25, Y+4	; 0x04
    4344:	90 93 ad 06 	sts	0x06AD, r25
    4348:	80 93 ac 06 	sts	0x06AC, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    434c:	8b 81       	ldd	r24, Y+3	; 0x03
    434e:	9c 81       	ldd	r25, Y+4	; 0x04
    4350:	00 97       	sbiw	r24, 0x00	; 0
    4352:	d9 f4       	brne	.+54     	; 0x438a <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4354:	80 91 f8 06 	lds	r24, 0x06F8
    4358:	90 91 f9 06 	lds	r25, 0x06F9
    435c:	9a 83       	std	Y+2, r25	; 0x02
    435e:	89 83       	std	Y+1, r24	; 0x01
    4360:	80 91 fa 06 	lds	r24, 0x06FA
    4364:	90 91 fb 06 	lds	r25, 0x06FB
    4368:	90 93 f9 06 	sts	0x06F9, r25
    436c:	80 93 f8 06 	sts	0x06F8, r24
    4370:	89 81       	ldd	r24, Y+1	; 0x01
    4372:	9a 81       	ldd	r25, Y+2	; 0x02
    4374:	90 93 fb 06 	sts	0x06FB, r25
    4378:	80 93 fa 06 	sts	0x06FA, r24
    437c:	80 91 b2 06 	lds	r24, 0x06B2
    4380:	8f 5f       	subi	r24, 0xFF	; 255
    4382:	80 93 b2 06 	sts	0x06B2, r24
    4386:	0e 94 33 25 	call	0x4a66	; 0x4a66 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    438a:	20 91 b4 06 	lds	r18, 0x06B4
    438e:	30 91 b5 06 	lds	r19, 0x06B5
    4392:	8b 81       	ldd	r24, Y+3	; 0x03
    4394:	9c 81       	ldd	r25, Y+4	; 0x04
    4396:	82 17       	cp	r24, r18
    4398:	93 07       	cpc	r25, r19
    439a:	08 f4       	brcc	.+2      	; 0x439e <xTaskIncrementTick+0x8c>
    439c:	71 c0       	rjmp	.+226    	; 0x4480 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    439e:	e0 91 f8 06 	lds	r30, 0x06F8
    43a2:	f0 91 f9 06 	lds	r31, 0x06F9
    43a6:	80 81       	ld	r24, Z
    43a8:	88 23       	and	r24, r24
    43aa:	39 f4       	brne	.+14     	; 0x43ba <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    43ac:	8f ef       	ldi	r24, 0xFF	; 255
    43ae:	9f ef       	ldi	r25, 0xFF	; 255
    43b0:	90 93 b5 06 	sts	0x06B5, r25
    43b4:	80 93 b4 06 	sts	0x06B4, r24
    43b8:	63 c0       	rjmp	.+198    	; 0x4480 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    43ba:	e0 91 f8 06 	lds	r30, 0x06F8
    43be:	f0 91 f9 06 	lds	r31, 0x06F9
    43c2:	05 80       	ldd	r0, Z+5	; 0x05
    43c4:	f6 81       	ldd	r31, Z+6	; 0x06
    43c6:	e0 2d       	mov	r30, r0
    43c8:	86 81       	ldd	r24, Z+6	; 0x06
    43ca:	97 81       	ldd	r25, Z+7	; 0x07
    43cc:	99 87       	std	Y+9, r25	; 0x09
    43ce:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    43d0:	e8 85       	ldd	r30, Y+8	; 0x08
    43d2:	f9 85       	ldd	r31, Y+9	; 0x09
    43d4:	82 81       	ldd	r24, Z+2	; 0x02
    43d6:	93 81       	ldd	r25, Z+3	; 0x03
    43d8:	9f 83       	std	Y+7, r25	; 0x07
    43da:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    43dc:	2b 81       	ldd	r18, Y+3	; 0x03
    43de:	3c 81       	ldd	r19, Y+4	; 0x04
    43e0:	8e 81       	ldd	r24, Y+6	; 0x06
    43e2:	9f 81       	ldd	r25, Y+7	; 0x07
    43e4:	28 17       	cp	r18, r24
    43e6:	39 07       	cpc	r19, r25
    43e8:	38 f4       	brcc	.+14     	; 0x43f8 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    43ea:	8e 81       	ldd	r24, Y+6	; 0x06
    43ec:	9f 81       	ldd	r25, Y+7	; 0x07
    43ee:	90 93 b5 06 	sts	0x06B5, r25
    43f2:	80 93 b4 06 	sts	0x06B4, r24
    43f6:	44 c0       	rjmp	.+136    	; 0x4480 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    43f8:	88 85       	ldd	r24, Y+8	; 0x08
    43fa:	99 85       	ldd	r25, Y+9	; 0x09
    43fc:	02 96       	adiw	r24, 0x02	; 2
    43fe:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4402:	e8 85       	ldd	r30, Y+8	; 0x08
    4404:	f9 85       	ldd	r31, Y+9	; 0x09
    4406:	84 89       	ldd	r24, Z+20	; 0x14
    4408:	95 89       	ldd	r25, Z+21	; 0x15
    440a:	00 97       	sbiw	r24, 0x00	; 0
    440c:	29 f0       	breq	.+10     	; 0x4418 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    440e:	88 85       	ldd	r24, Y+8	; 0x08
    4410:	99 85       	ldd	r25, Y+9	; 0x09
    4412:	0c 96       	adiw	r24, 0x0c	; 12
    4414:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    4418:	e8 85       	ldd	r30, Y+8	; 0x08
    441a:	f9 85       	ldd	r31, Y+9	; 0x09
    441c:	96 89       	ldd	r25, Z+22	; 0x16
    441e:	80 91 ae 06 	lds	r24, 0x06AE
    4422:	89 17       	cp	r24, r25
    4424:	28 f4       	brcc	.+10     	; 0x4430 <xTaskIncrementTick+0x11e>
    4426:	e8 85       	ldd	r30, Y+8	; 0x08
    4428:	f9 85       	ldd	r31, Y+9	; 0x09
    442a:	86 89       	ldd	r24, Z+22	; 0x16
    442c:	80 93 ae 06 	sts	0x06AE, r24
    4430:	e8 85       	ldd	r30, Y+8	; 0x08
    4432:	f9 85       	ldd	r31, Y+9	; 0x09
    4434:	86 89       	ldd	r24, Z+22	; 0x16
    4436:	28 2f       	mov	r18, r24
    4438:	30 e0       	ldi	r19, 0x00	; 0
    443a:	c9 01       	movw	r24, r18
    443c:	88 0f       	add	r24, r24
    443e:	99 1f       	adc	r25, r25
    4440:	88 0f       	add	r24, r24
    4442:	99 1f       	adc	r25, r25
    4444:	88 0f       	add	r24, r24
    4446:	99 1f       	adc	r25, r25
    4448:	82 0f       	add	r24, r18
    444a:	93 1f       	adc	r25, r19
    444c:	ac 01       	movw	r20, r24
    444e:	47 54       	subi	r20, 0x47	; 71
    4450:	59 4f       	sbci	r21, 0xF9	; 249
    4452:	88 85       	ldd	r24, Y+8	; 0x08
    4454:	99 85       	ldd	r25, Y+9	; 0x09
    4456:	9c 01       	movw	r18, r24
    4458:	2e 5f       	subi	r18, 0xFE	; 254
    445a:	3f 4f       	sbci	r19, 0xFF	; 255
    445c:	ca 01       	movw	r24, r20
    445e:	b9 01       	movw	r22, r18
    4460:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4464:	e8 85       	ldd	r30, Y+8	; 0x08
    4466:	f9 85       	ldd	r31, Y+9	; 0x09
    4468:	96 89       	ldd	r25, Z+22	; 0x16
    446a:	e0 91 a8 06 	lds	r30, 0x06A8
    446e:	f0 91 a9 06 	lds	r31, 0x06A9
    4472:	86 89       	ldd	r24, Z+22	; 0x16
    4474:	98 17       	cp	r25, r24
    4476:	08 f4       	brcc	.+2      	; 0x447a <xTaskIncrementTick+0x168>
    4478:	92 cf       	rjmp	.-220    	; 0x439e <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    447a:	81 e0       	ldi	r24, 0x01	; 1
    447c:	8d 83       	std	Y+5, r24	; 0x05
    447e:	8f cf       	rjmp	.-226    	; 0x439e <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4480:	e0 91 a8 06 	lds	r30, 0x06A8
    4484:	f0 91 a9 06 	lds	r31, 0x06A9
    4488:	86 89       	ldd	r24, Z+22	; 0x16
    448a:	28 2f       	mov	r18, r24
    448c:	30 e0       	ldi	r19, 0x00	; 0
    448e:	c9 01       	movw	r24, r18
    4490:	88 0f       	add	r24, r24
    4492:	99 1f       	adc	r25, r25
    4494:	88 0f       	add	r24, r24
    4496:	99 1f       	adc	r25, r25
    4498:	88 0f       	add	r24, r24
    449a:	99 1f       	adc	r25, r25
    449c:	82 0f       	add	r24, r18
    449e:	93 1f       	adc	r25, r19
    44a0:	fc 01       	movw	r30, r24
    44a2:	e7 54       	subi	r30, 0x47	; 71
    44a4:	f9 4f       	sbci	r31, 0xF9	; 249
    44a6:	80 81       	ld	r24, Z
    44a8:	82 30       	cpi	r24, 0x02	; 2
    44aa:	40 f0       	brcs	.+16     	; 0x44bc <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    44ac:	81 e0       	ldi	r24, 0x01	; 1
    44ae:	8d 83       	std	Y+5, r24	; 0x05
    44b0:	05 c0       	rjmp	.+10     	; 0x44bc <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    44b2:	80 91 b0 06 	lds	r24, 0x06B0
    44b6:	8f 5f       	subi	r24, 0xFF	; 255
    44b8:	80 93 b0 06 	sts	0x06B0, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    44bc:	80 91 b1 06 	lds	r24, 0x06B1
    44c0:	88 23       	and	r24, r24
    44c2:	11 f0       	breq	.+4      	; 0x44c8 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    44c4:	81 e0       	ldi	r24, 0x01	; 1
    44c6:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    44c8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    44ca:	29 96       	adiw	r28, 0x09	; 9
    44cc:	0f b6       	in	r0, 0x3f	; 63
    44ce:	f8 94       	cli
    44d0:	de bf       	out	0x3e, r29	; 62
    44d2:	0f be       	out	0x3f, r0	; 63
    44d4:	cd bf       	out	0x3d, r28	; 61
    44d6:	cf 91       	pop	r28
    44d8:	df 91       	pop	r29
    44da:	08 95       	ret

000044dc <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    44dc:	df 93       	push	r29
    44de:	cf 93       	push	r28
    44e0:	00 d0       	rcall	.+0      	; 0x44e2 <vTaskSwitchContext+0x6>
    44e2:	0f 92       	push	r0
    44e4:	cd b7       	in	r28, 0x3d	; 61
    44e6:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    44e8:	80 91 b8 06 	lds	r24, 0x06B8
    44ec:	88 23       	and	r24, r24
    44ee:	21 f0       	breq	.+8      	; 0x44f8 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    44f0:	81 e0       	ldi	r24, 0x01	; 1
    44f2:	80 93 b1 06 	sts	0x06B1, r24
    44f6:	59 c0       	rjmp	.+178    	; 0x45aa <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    44f8:	10 92 b1 06 	sts	0x06B1, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    44fc:	80 91 ae 06 	lds	r24, 0x06AE
    4500:	8b 83       	std	Y+3, r24	; 0x03
    4502:	03 c0       	rjmp	.+6      	; 0x450a <vTaskSwitchContext+0x2e>
    4504:	8b 81       	ldd	r24, Y+3	; 0x03
    4506:	81 50       	subi	r24, 0x01	; 1
    4508:	8b 83       	std	Y+3, r24	; 0x03
    450a:	8b 81       	ldd	r24, Y+3	; 0x03
    450c:	28 2f       	mov	r18, r24
    450e:	30 e0       	ldi	r19, 0x00	; 0
    4510:	c9 01       	movw	r24, r18
    4512:	88 0f       	add	r24, r24
    4514:	99 1f       	adc	r25, r25
    4516:	88 0f       	add	r24, r24
    4518:	99 1f       	adc	r25, r25
    451a:	88 0f       	add	r24, r24
    451c:	99 1f       	adc	r25, r25
    451e:	82 0f       	add	r24, r18
    4520:	93 1f       	adc	r25, r19
    4522:	fc 01       	movw	r30, r24
    4524:	e7 54       	subi	r30, 0x47	; 71
    4526:	f9 4f       	sbci	r31, 0xF9	; 249
    4528:	80 81       	ld	r24, Z
    452a:	88 23       	and	r24, r24
    452c:	59 f3       	breq	.-42     	; 0x4504 <vTaskSwitchContext+0x28>
    452e:	8b 81       	ldd	r24, Y+3	; 0x03
    4530:	28 2f       	mov	r18, r24
    4532:	30 e0       	ldi	r19, 0x00	; 0
    4534:	c9 01       	movw	r24, r18
    4536:	88 0f       	add	r24, r24
    4538:	99 1f       	adc	r25, r25
    453a:	88 0f       	add	r24, r24
    453c:	99 1f       	adc	r25, r25
    453e:	88 0f       	add	r24, r24
    4540:	99 1f       	adc	r25, r25
    4542:	82 0f       	add	r24, r18
    4544:	93 1f       	adc	r25, r19
    4546:	87 54       	subi	r24, 0x47	; 71
    4548:	99 4f       	sbci	r25, 0xF9	; 249
    454a:	9a 83       	std	Y+2, r25	; 0x02
    454c:	89 83       	std	Y+1, r24	; 0x01
    454e:	e9 81       	ldd	r30, Y+1	; 0x01
    4550:	fa 81       	ldd	r31, Y+2	; 0x02
    4552:	01 80       	ldd	r0, Z+1	; 0x01
    4554:	f2 81       	ldd	r31, Z+2	; 0x02
    4556:	e0 2d       	mov	r30, r0
    4558:	82 81       	ldd	r24, Z+2	; 0x02
    455a:	93 81       	ldd	r25, Z+3	; 0x03
    455c:	e9 81       	ldd	r30, Y+1	; 0x01
    455e:	fa 81       	ldd	r31, Y+2	; 0x02
    4560:	92 83       	std	Z+2, r25	; 0x02
    4562:	81 83       	std	Z+1, r24	; 0x01
    4564:	e9 81       	ldd	r30, Y+1	; 0x01
    4566:	fa 81       	ldd	r31, Y+2	; 0x02
    4568:	21 81       	ldd	r18, Z+1	; 0x01
    456a:	32 81       	ldd	r19, Z+2	; 0x02
    456c:	89 81       	ldd	r24, Y+1	; 0x01
    456e:	9a 81       	ldd	r25, Y+2	; 0x02
    4570:	03 96       	adiw	r24, 0x03	; 3
    4572:	28 17       	cp	r18, r24
    4574:	39 07       	cpc	r19, r25
    4576:	59 f4       	brne	.+22     	; 0x458e <vTaskSwitchContext+0xb2>
    4578:	e9 81       	ldd	r30, Y+1	; 0x01
    457a:	fa 81       	ldd	r31, Y+2	; 0x02
    457c:	01 80       	ldd	r0, Z+1	; 0x01
    457e:	f2 81       	ldd	r31, Z+2	; 0x02
    4580:	e0 2d       	mov	r30, r0
    4582:	82 81       	ldd	r24, Z+2	; 0x02
    4584:	93 81       	ldd	r25, Z+3	; 0x03
    4586:	e9 81       	ldd	r30, Y+1	; 0x01
    4588:	fa 81       	ldd	r31, Y+2	; 0x02
    458a:	92 83       	std	Z+2, r25	; 0x02
    458c:	81 83       	std	Z+1, r24	; 0x01
    458e:	e9 81       	ldd	r30, Y+1	; 0x01
    4590:	fa 81       	ldd	r31, Y+2	; 0x02
    4592:	01 80       	ldd	r0, Z+1	; 0x01
    4594:	f2 81       	ldd	r31, Z+2	; 0x02
    4596:	e0 2d       	mov	r30, r0
    4598:	86 81       	ldd	r24, Z+6	; 0x06
    459a:	97 81       	ldd	r25, Z+7	; 0x07
    459c:	90 93 a9 06 	sts	0x06A9, r25
    45a0:	80 93 a8 06 	sts	0x06A8, r24
    45a4:	8b 81       	ldd	r24, Y+3	; 0x03
    45a6:	80 93 ae 06 	sts	0x06AE, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    45aa:	0f 90       	pop	r0
    45ac:	0f 90       	pop	r0
    45ae:	0f 90       	pop	r0
    45b0:	cf 91       	pop	r28
    45b2:	df 91       	pop	r29
    45b4:	08 95       	ret

000045b6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    45b6:	df 93       	push	r29
    45b8:	cf 93       	push	r28
    45ba:	00 d0       	rcall	.+0      	; 0x45bc <vTaskPlaceOnEventList+0x6>
    45bc:	00 d0       	rcall	.+0      	; 0x45be <vTaskPlaceOnEventList+0x8>
    45be:	cd b7       	in	r28, 0x3d	; 61
    45c0:	de b7       	in	r29, 0x3e	; 62
    45c2:	9a 83       	std	Y+2, r25	; 0x02
    45c4:	89 83       	std	Y+1, r24	; 0x01
    45c6:	7c 83       	std	Y+4, r23	; 0x04
    45c8:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    45ca:	80 91 a8 06 	lds	r24, 0x06A8
    45ce:	90 91 a9 06 	lds	r25, 0x06A9
    45d2:	9c 01       	movw	r18, r24
    45d4:	24 5f       	subi	r18, 0xF4	; 244
    45d6:	3f 4f       	sbci	r19, 0xFF	; 255
    45d8:	89 81       	ldd	r24, Y+1	; 0x01
    45da:	9a 81       	ldd	r25, Y+2	; 0x02
    45dc:	b9 01       	movw	r22, r18
    45de:	0e 94 47 0a 	call	0x148e	; 0x148e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    45e2:	8b 81       	ldd	r24, Y+3	; 0x03
    45e4:	9c 81       	ldd	r25, Y+4	; 0x04
    45e6:	61 e0       	ldi	r22, 0x01	; 1
    45e8:	0e 94 3f 29 	call	0x527e	; 0x527e <prvAddCurrentTaskToDelayedList>
}
    45ec:	0f 90       	pop	r0
    45ee:	0f 90       	pop	r0
    45f0:	0f 90       	pop	r0
    45f2:	0f 90       	pop	r0
    45f4:	cf 91       	pop	r28
    45f6:	df 91       	pop	r29
    45f8:	08 95       	ret

000045fa <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    45fa:	df 93       	push	r29
    45fc:	cf 93       	push	r28
    45fe:	00 d0       	rcall	.+0      	; 0x4600 <vTaskPlaceOnUnorderedEventList+0x6>
    4600:	00 d0       	rcall	.+0      	; 0x4602 <vTaskPlaceOnUnorderedEventList+0x8>
    4602:	00 d0       	rcall	.+0      	; 0x4604 <vTaskPlaceOnUnorderedEventList+0xa>
    4604:	cd b7       	in	r28, 0x3d	; 61
    4606:	de b7       	in	r29, 0x3e	; 62
    4608:	9a 83       	std	Y+2, r25	; 0x02
    460a:	89 83       	std	Y+1, r24	; 0x01
    460c:	7c 83       	std	Y+4, r23	; 0x04
    460e:	6b 83       	std	Y+3, r22	; 0x03
    4610:	5e 83       	std	Y+6, r21	; 0x06
    4612:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4614:	e0 91 a8 06 	lds	r30, 0x06A8
    4618:	f0 91 a9 06 	lds	r31, 0x06A9
    461c:	8b 81       	ldd	r24, Y+3	; 0x03
    461e:	9c 81       	ldd	r25, Y+4	; 0x04
    4620:	90 68       	ori	r25, 0x80	; 128
    4622:	95 87       	std	Z+13, r25	; 0x0d
    4624:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4626:	80 91 a8 06 	lds	r24, 0x06A8
    462a:	90 91 a9 06 	lds	r25, 0x06A9
    462e:	9c 01       	movw	r18, r24
    4630:	24 5f       	subi	r18, 0xF4	; 244
    4632:	3f 4f       	sbci	r19, 0xFF	; 255
    4634:	89 81       	ldd	r24, Y+1	; 0x01
    4636:	9a 81       	ldd	r25, Y+2	; 0x02
    4638:	b9 01       	movw	r22, r18
    463a:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    463e:	8d 81       	ldd	r24, Y+5	; 0x05
    4640:	9e 81       	ldd	r25, Y+6	; 0x06
    4642:	61 e0       	ldi	r22, 0x01	; 1
    4644:	0e 94 3f 29 	call	0x527e	; 0x527e <prvAddCurrentTaskToDelayedList>
}
    4648:	26 96       	adiw	r28, 0x06	; 6
    464a:	0f b6       	in	r0, 0x3f	; 63
    464c:	f8 94       	cli
    464e:	de bf       	out	0x3e, r29	; 62
    4650:	0f be       	out	0x3f, r0	; 63
    4652:	cd bf       	out	0x3d, r28	; 61
    4654:	cf 91       	pop	r28
    4656:	df 91       	pop	r29
    4658:	08 95       	ret

0000465a <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    465a:	df 93       	push	r29
    465c:	cf 93       	push	r28
    465e:	00 d0       	rcall	.+0      	; 0x4660 <xTaskRemoveFromEventList+0x6>
    4660:	00 d0       	rcall	.+0      	; 0x4662 <xTaskRemoveFromEventList+0x8>
    4662:	0f 92       	push	r0
    4664:	cd b7       	in	r28, 0x3d	; 61
    4666:	de b7       	in	r29, 0x3e	; 62
    4668:	9d 83       	std	Y+5, r25	; 0x05
    466a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    466c:	ec 81       	ldd	r30, Y+4	; 0x04
    466e:	fd 81       	ldd	r31, Y+5	; 0x05
    4670:	05 80       	ldd	r0, Z+5	; 0x05
    4672:	f6 81       	ldd	r31, Z+6	; 0x06
    4674:	e0 2d       	mov	r30, r0
    4676:	86 81       	ldd	r24, Z+6	; 0x06
    4678:	97 81       	ldd	r25, Z+7	; 0x07
    467a:	9b 83       	std	Y+3, r25	; 0x03
    467c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    467e:	8a 81       	ldd	r24, Y+2	; 0x02
    4680:	9b 81       	ldd	r25, Y+3	; 0x03
    4682:	0c 96       	adiw	r24, 0x0c	; 12
    4684:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4688:	80 91 b8 06 	lds	r24, 0x06B8
    468c:	88 23       	and	r24, r24
    468e:	61 f5       	brne	.+88     	; 0x46e8 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4690:	8a 81       	ldd	r24, Y+2	; 0x02
    4692:	9b 81       	ldd	r25, Y+3	; 0x03
    4694:	02 96       	adiw	r24, 0x02	; 2
    4696:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    469a:	ea 81       	ldd	r30, Y+2	; 0x02
    469c:	fb 81       	ldd	r31, Y+3	; 0x03
    469e:	96 89       	ldd	r25, Z+22	; 0x16
    46a0:	80 91 ae 06 	lds	r24, 0x06AE
    46a4:	89 17       	cp	r24, r25
    46a6:	28 f4       	brcc	.+10     	; 0x46b2 <xTaskRemoveFromEventList+0x58>
    46a8:	ea 81       	ldd	r30, Y+2	; 0x02
    46aa:	fb 81       	ldd	r31, Y+3	; 0x03
    46ac:	86 89       	ldd	r24, Z+22	; 0x16
    46ae:	80 93 ae 06 	sts	0x06AE, r24
    46b2:	ea 81       	ldd	r30, Y+2	; 0x02
    46b4:	fb 81       	ldd	r31, Y+3	; 0x03
    46b6:	86 89       	ldd	r24, Z+22	; 0x16
    46b8:	28 2f       	mov	r18, r24
    46ba:	30 e0       	ldi	r19, 0x00	; 0
    46bc:	c9 01       	movw	r24, r18
    46be:	88 0f       	add	r24, r24
    46c0:	99 1f       	adc	r25, r25
    46c2:	88 0f       	add	r24, r24
    46c4:	99 1f       	adc	r25, r25
    46c6:	88 0f       	add	r24, r24
    46c8:	99 1f       	adc	r25, r25
    46ca:	82 0f       	add	r24, r18
    46cc:	93 1f       	adc	r25, r19
    46ce:	ac 01       	movw	r20, r24
    46d0:	47 54       	subi	r20, 0x47	; 71
    46d2:	59 4f       	sbci	r21, 0xF9	; 249
    46d4:	8a 81       	ldd	r24, Y+2	; 0x02
    46d6:	9b 81       	ldd	r25, Y+3	; 0x03
    46d8:	9c 01       	movw	r18, r24
    46da:	2e 5f       	subi	r18, 0xFE	; 254
    46dc:	3f 4f       	sbci	r19, 0xFF	; 255
    46de:	ca 01       	movw	r24, r20
    46e0:	b9 01       	movw	r22, r18
    46e2:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    46e6:	0a c0       	rjmp	.+20     	; 0x46fc <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    46e8:	8a 81       	ldd	r24, Y+2	; 0x02
    46ea:	9b 81       	ldd	r25, Y+3	; 0x03
    46ec:	9c 01       	movw	r18, r24
    46ee:	24 5f       	subi	r18, 0xF4	; 244
    46f0:	3f 4f       	sbci	r19, 0xFF	; 255
    46f2:	8c ef       	ldi	r24, 0xFC	; 252
    46f4:	96 e0       	ldi	r25, 0x06	; 6
    46f6:	b9 01       	movw	r22, r18
    46f8:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    46fc:	ea 81       	ldd	r30, Y+2	; 0x02
    46fe:	fb 81       	ldd	r31, Y+3	; 0x03
    4700:	96 89       	ldd	r25, Z+22	; 0x16
    4702:	e0 91 a8 06 	lds	r30, 0x06A8
    4706:	f0 91 a9 06 	lds	r31, 0x06A9
    470a:	86 89       	ldd	r24, Z+22	; 0x16
    470c:	89 17       	cp	r24, r25
    470e:	30 f4       	brcc	.+12     	; 0x471c <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4710:	81 e0       	ldi	r24, 0x01	; 1
    4712:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4714:	81 e0       	ldi	r24, 0x01	; 1
    4716:	80 93 b1 06 	sts	0x06B1, r24
    471a:	01 c0       	rjmp	.+2      	; 0x471e <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    471c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    471e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4720:	0f 90       	pop	r0
    4722:	0f 90       	pop	r0
    4724:	0f 90       	pop	r0
    4726:	0f 90       	pop	r0
    4728:	0f 90       	pop	r0
    472a:	cf 91       	pop	r28
    472c:	df 91       	pop	r29
    472e:	08 95       	ret

00004730 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4730:	df 93       	push	r29
    4732:	cf 93       	push	r28
    4734:	00 d0       	rcall	.+0      	; 0x4736 <vTaskRemoveFromUnorderedEventList+0x6>
    4736:	00 d0       	rcall	.+0      	; 0x4738 <vTaskRemoveFromUnorderedEventList+0x8>
    4738:	00 d0       	rcall	.+0      	; 0x473a <vTaskRemoveFromUnorderedEventList+0xa>
    473a:	cd b7       	in	r28, 0x3d	; 61
    473c:	de b7       	in	r29, 0x3e	; 62
    473e:	9c 83       	std	Y+4, r25	; 0x04
    4740:	8b 83       	std	Y+3, r24	; 0x03
    4742:	7e 83       	std	Y+6, r23	; 0x06
    4744:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4746:	8d 81       	ldd	r24, Y+5	; 0x05
    4748:	9e 81       	ldd	r25, Y+6	; 0x06
    474a:	90 68       	ori	r25, 0x80	; 128
    474c:	eb 81       	ldd	r30, Y+3	; 0x03
    474e:	fc 81       	ldd	r31, Y+4	; 0x04
    4750:	91 83       	std	Z+1, r25	; 0x01
    4752:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4754:	eb 81       	ldd	r30, Y+3	; 0x03
    4756:	fc 81       	ldd	r31, Y+4	; 0x04
    4758:	86 81       	ldd	r24, Z+6	; 0x06
    475a:	97 81       	ldd	r25, Z+7	; 0x07
    475c:	9a 83       	std	Y+2, r25	; 0x02
    475e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4760:	8b 81       	ldd	r24, Y+3	; 0x03
    4762:	9c 81       	ldd	r25, Y+4	; 0x04
    4764:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4768:	89 81       	ldd	r24, Y+1	; 0x01
    476a:	9a 81       	ldd	r25, Y+2	; 0x02
    476c:	02 96       	adiw	r24, 0x02	; 2
    476e:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4772:	e9 81       	ldd	r30, Y+1	; 0x01
    4774:	fa 81       	ldd	r31, Y+2	; 0x02
    4776:	96 89       	ldd	r25, Z+22	; 0x16
    4778:	80 91 ae 06 	lds	r24, 0x06AE
    477c:	89 17       	cp	r24, r25
    477e:	28 f4       	brcc	.+10     	; 0x478a <vTaskRemoveFromUnorderedEventList+0x5a>
    4780:	e9 81       	ldd	r30, Y+1	; 0x01
    4782:	fa 81       	ldd	r31, Y+2	; 0x02
    4784:	86 89       	ldd	r24, Z+22	; 0x16
    4786:	80 93 ae 06 	sts	0x06AE, r24
    478a:	e9 81       	ldd	r30, Y+1	; 0x01
    478c:	fa 81       	ldd	r31, Y+2	; 0x02
    478e:	86 89       	ldd	r24, Z+22	; 0x16
    4790:	28 2f       	mov	r18, r24
    4792:	30 e0       	ldi	r19, 0x00	; 0
    4794:	c9 01       	movw	r24, r18
    4796:	88 0f       	add	r24, r24
    4798:	99 1f       	adc	r25, r25
    479a:	88 0f       	add	r24, r24
    479c:	99 1f       	adc	r25, r25
    479e:	88 0f       	add	r24, r24
    47a0:	99 1f       	adc	r25, r25
    47a2:	82 0f       	add	r24, r18
    47a4:	93 1f       	adc	r25, r19
    47a6:	ac 01       	movw	r20, r24
    47a8:	47 54       	subi	r20, 0x47	; 71
    47aa:	59 4f       	sbci	r21, 0xF9	; 249
    47ac:	89 81       	ldd	r24, Y+1	; 0x01
    47ae:	9a 81       	ldd	r25, Y+2	; 0x02
    47b0:	9c 01       	movw	r18, r24
    47b2:	2e 5f       	subi	r18, 0xFE	; 254
    47b4:	3f 4f       	sbci	r19, 0xFF	; 255
    47b6:	ca 01       	movw	r24, r20
    47b8:	b9 01       	movw	r22, r18
    47ba:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    47be:	e9 81       	ldd	r30, Y+1	; 0x01
    47c0:	fa 81       	ldd	r31, Y+2	; 0x02
    47c2:	96 89       	ldd	r25, Z+22	; 0x16
    47c4:	e0 91 a8 06 	lds	r30, 0x06A8
    47c8:	f0 91 a9 06 	lds	r31, 0x06A9
    47cc:	86 89       	ldd	r24, Z+22	; 0x16
    47ce:	89 17       	cp	r24, r25
    47d0:	18 f4       	brcc	.+6      	; 0x47d8 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    47d2:	81 e0       	ldi	r24, 0x01	; 1
    47d4:	80 93 b1 06 	sts	0x06B1, r24
	}
}
    47d8:	26 96       	adiw	r28, 0x06	; 6
    47da:	0f b6       	in	r0, 0x3f	; 63
    47dc:	f8 94       	cli
    47de:	de bf       	out	0x3e, r29	; 62
    47e0:	0f be       	out	0x3f, r0	; 63
    47e2:	cd bf       	out	0x3d, r28	; 61
    47e4:	cf 91       	pop	r28
    47e6:	df 91       	pop	r29
    47e8:	08 95       	ret

000047ea <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    47ea:	df 93       	push	r29
    47ec:	cf 93       	push	r28
    47ee:	00 d0       	rcall	.+0      	; 0x47f0 <vTaskSetTimeOutState+0x6>
    47f0:	cd b7       	in	r28, 0x3d	; 61
    47f2:	de b7       	in	r29, 0x3e	; 62
    47f4:	9a 83       	std	Y+2, r25	; 0x02
    47f6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    47f8:	0f b6       	in	r0, 0x3f	; 63
    47fa:	f8 94       	cli
    47fc:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    47fe:	80 91 b2 06 	lds	r24, 0x06B2
    4802:	e9 81       	ldd	r30, Y+1	; 0x01
    4804:	fa 81       	ldd	r31, Y+2	; 0x02
    4806:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4808:	80 91 ac 06 	lds	r24, 0x06AC
    480c:	90 91 ad 06 	lds	r25, 0x06AD
    4810:	e9 81       	ldd	r30, Y+1	; 0x01
    4812:	fa 81       	ldd	r31, Y+2	; 0x02
    4814:	92 83       	std	Z+2, r25	; 0x02
    4816:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4818:	0f 90       	pop	r0
    481a:	0f be       	out	0x3f, r0	; 63
}
    481c:	0f 90       	pop	r0
    481e:	0f 90       	pop	r0
    4820:	cf 91       	pop	r28
    4822:	df 91       	pop	r29
    4824:	08 95       	ret

00004826 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4826:	df 93       	push	r29
    4828:	cf 93       	push	r28
    482a:	00 d0       	rcall	.+0      	; 0x482c <vTaskInternalSetTimeOutState+0x6>
    482c:	cd b7       	in	r28, 0x3d	; 61
    482e:	de b7       	in	r29, 0x3e	; 62
    4830:	9a 83       	std	Y+2, r25	; 0x02
    4832:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4834:	80 91 b2 06 	lds	r24, 0x06B2
    4838:	e9 81       	ldd	r30, Y+1	; 0x01
    483a:	fa 81       	ldd	r31, Y+2	; 0x02
    483c:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    483e:	80 91 ac 06 	lds	r24, 0x06AC
    4842:	90 91 ad 06 	lds	r25, 0x06AD
    4846:	e9 81       	ldd	r30, Y+1	; 0x01
    4848:	fa 81       	ldd	r31, Y+2	; 0x02
    484a:	92 83       	std	Z+2, r25	; 0x02
    484c:	81 83       	std	Z+1, r24	; 0x01
}
    484e:	0f 90       	pop	r0
    4850:	0f 90       	pop	r0
    4852:	cf 91       	pop	r28
    4854:	df 91       	pop	r29
    4856:	08 95       	ret

00004858 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4858:	df 93       	push	r29
    485a:	cf 93       	push	r28
    485c:	cd b7       	in	r28, 0x3d	; 61
    485e:	de b7       	in	r29, 0x3e	; 62
    4860:	29 97       	sbiw	r28, 0x09	; 9
    4862:	0f b6       	in	r0, 0x3f	; 63
    4864:	f8 94       	cli
    4866:	de bf       	out	0x3e, r29	; 62
    4868:	0f be       	out	0x3f, r0	; 63
    486a:	cd bf       	out	0x3d, r28	; 61
    486c:	9f 83       	std	Y+7, r25	; 0x07
    486e:	8e 83       	std	Y+6, r24	; 0x06
    4870:	79 87       	std	Y+9, r23	; 0x09
    4872:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4874:	0f b6       	in	r0, 0x3f	; 63
    4876:	f8 94       	cli
    4878:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    487a:	80 91 ac 06 	lds	r24, 0x06AC
    487e:	90 91 ad 06 	lds	r25, 0x06AD
    4882:	9c 83       	std	Y+4, r25	; 0x04
    4884:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4886:	ee 81       	ldd	r30, Y+6	; 0x06
    4888:	ff 81       	ldd	r31, Y+7	; 0x07
    488a:	21 81       	ldd	r18, Z+1	; 0x01
    488c:	32 81       	ldd	r19, Z+2	; 0x02
    488e:	8b 81       	ldd	r24, Y+3	; 0x03
    4890:	9c 81       	ldd	r25, Y+4	; 0x04
    4892:	82 1b       	sub	r24, r18
    4894:	93 0b       	sbc	r25, r19
    4896:	9a 83       	std	Y+2, r25	; 0x02
    4898:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    489a:	e8 85       	ldd	r30, Y+8	; 0x08
    489c:	f9 85       	ldd	r31, Y+9	; 0x09
    489e:	80 81       	ld	r24, Z
    48a0:	91 81       	ldd	r25, Z+1	; 0x01
    48a2:	2f ef       	ldi	r18, 0xFF	; 255
    48a4:	8f 3f       	cpi	r24, 0xFF	; 255
    48a6:	92 07       	cpc	r25, r18
    48a8:	11 f4       	brne	.+4      	; 0x48ae <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    48aa:	1d 82       	std	Y+5, r1	; 0x05
    48ac:	36 c0       	rjmp	.+108    	; 0x491a <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    48ae:	ee 81       	ldd	r30, Y+6	; 0x06
    48b0:	ff 81       	ldd	r31, Y+7	; 0x07
    48b2:	90 81       	ld	r25, Z
    48b4:	80 91 b2 06 	lds	r24, 0x06B2
    48b8:	98 17       	cp	r25, r24
    48ba:	61 f0       	breq	.+24     	; 0x48d4 <xTaskCheckForTimeOut+0x7c>
    48bc:	ee 81       	ldd	r30, Y+6	; 0x06
    48be:	ff 81       	ldd	r31, Y+7	; 0x07
    48c0:	21 81       	ldd	r18, Z+1	; 0x01
    48c2:	32 81       	ldd	r19, Z+2	; 0x02
    48c4:	8b 81       	ldd	r24, Y+3	; 0x03
    48c6:	9c 81       	ldd	r25, Y+4	; 0x04
    48c8:	82 17       	cp	r24, r18
    48ca:	93 07       	cpc	r25, r19
    48cc:	18 f0       	brcs	.+6      	; 0x48d4 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    48ce:	81 e0       	ldi	r24, 0x01	; 1
    48d0:	8d 83       	std	Y+5, r24	; 0x05
    48d2:	23 c0       	rjmp	.+70     	; 0x491a <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    48d4:	e8 85       	ldd	r30, Y+8	; 0x08
    48d6:	f9 85       	ldd	r31, Y+9	; 0x09
    48d8:	20 81       	ld	r18, Z
    48da:	31 81       	ldd	r19, Z+1	; 0x01
    48dc:	89 81       	ldd	r24, Y+1	; 0x01
    48de:	9a 81       	ldd	r25, Y+2	; 0x02
    48e0:	82 17       	cp	r24, r18
    48e2:	93 07       	cpc	r25, r19
    48e4:	a0 f4       	brcc	.+40     	; 0x490e <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    48e6:	e8 85       	ldd	r30, Y+8	; 0x08
    48e8:	f9 85       	ldd	r31, Y+9	; 0x09
    48ea:	20 81       	ld	r18, Z
    48ec:	31 81       	ldd	r19, Z+1	; 0x01
    48ee:	89 81       	ldd	r24, Y+1	; 0x01
    48f0:	9a 81       	ldd	r25, Y+2	; 0x02
    48f2:	a9 01       	movw	r20, r18
    48f4:	48 1b       	sub	r20, r24
    48f6:	59 0b       	sbc	r21, r25
    48f8:	ca 01       	movw	r24, r20
    48fa:	e8 85       	ldd	r30, Y+8	; 0x08
    48fc:	f9 85       	ldd	r31, Y+9	; 0x09
    48fe:	91 83       	std	Z+1, r25	; 0x01
    4900:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    4902:	8e 81       	ldd	r24, Y+6	; 0x06
    4904:	9f 81       	ldd	r25, Y+7	; 0x07
    4906:	0e 94 13 24 	call	0x4826	; 0x4826 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    490a:	1d 82       	std	Y+5, r1	; 0x05
    490c:	06 c0       	rjmp	.+12     	; 0x491a <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    490e:	e8 85       	ldd	r30, Y+8	; 0x08
    4910:	f9 85       	ldd	r31, Y+9	; 0x09
    4912:	11 82       	std	Z+1, r1	; 0x01
    4914:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    4916:	81 e0       	ldi	r24, 0x01	; 1
    4918:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    491a:	0f 90       	pop	r0
    491c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    491e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4920:	29 96       	adiw	r28, 0x09	; 9
    4922:	0f b6       	in	r0, 0x3f	; 63
    4924:	f8 94       	cli
    4926:	de bf       	out	0x3e, r29	; 62
    4928:	0f be       	out	0x3f, r0	; 63
    492a:	cd bf       	out	0x3d, r28	; 61
    492c:	cf 91       	pop	r28
    492e:	df 91       	pop	r29
    4930:	08 95       	ret

00004932 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4932:	df 93       	push	r29
    4934:	cf 93       	push	r28
    4936:	cd b7       	in	r28, 0x3d	; 61
    4938:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    493a:	81 e0       	ldi	r24, 0x01	; 1
    493c:	80 93 b1 06 	sts	0x06B1, r24
}
    4940:	cf 91       	pop	r28
    4942:	df 91       	pop	r29
    4944:	08 95       	ret

00004946 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4946:	df 93       	push	r29
    4948:	cf 93       	push	r28
    494a:	00 d0       	rcall	.+0      	; 0x494c <prvIdleTask+0x6>
    494c:	cd b7       	in	r28, 0x3d	; 61
    494e:	de b7       	in	r29, 0x3e	; 62
    4950:	9a 83       	std	Y+2, r25	; 0x02
    4952:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4954:	0e 94 ee 24 	call	0x49dc	; 0x49dc <prvCheckTasksWaitingTermination>
    4958:	fd cf       	rjmp	.-6      	; 0x4954 <prvIdleTask+0xe>

0000495a <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    495a:	df 93       	push	r29
    495c:	cf 93       	push	r28
    495e:	0f 92       	push	r0
    4960:	cd b7       	in	r28, 0x3d	; 61
    4962:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4964:	19 82       	std	Y+1, r1	; 0x01
    4966:	13 c0       	rjmp	.+38     	; 0x498e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4968:	89 81       	ldd	r24, Y+1	; 0x01
    496a:	28 2f       	mov	r18, r24
    496c:	30 e0       	ldi	r19, 0x00	; 0
    496e:	c9 01       	movw	r24, r18
    4970:	88 0f       	add	r24, r24
    4972:	99 1f       	adc	r25, r25
    4974:	88 0f       	add	r24, r24
    4976:	99 1f       	adc	r25, r25
    4978:	88 0f       	add	r24, r24
    497a:	99 1f       	adc	r25, r25
    497c:	82 0f       	add	r24, r18
    497e:	93 1f       	adc	r25, r19
    4980:	87 54       	subi	r24, 0x47	; 71
    4982:	99 4f       	sbci	r25, 0xF9	; 249
    4984:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4988:	89 81       	ldd	r24, Y+1	; 0x01
    498a:	8f 5f       	subi	r24, 0xFF	; 255
    498c:	89 83       	std	Y+1, r24	; 0x01
    498e:	89 81       	ldd	r24, Y+1	; 0x01
    4990:	85 30       	cpi	r24, 0x05	; 5
    4992:	50 f3       	brcs	.-44     	; 0x4968 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4994:	86 ee       	ldi	r24, 0xE6	; 230
    4996:	96 e0       	ldi	r25, 0x06	; 6
    4998:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    499c:	8f ee       	ldi	r24, 0xEF	; 239
    499e:	96 e0       	ldi	r25, 0x06	; 6
    49a0:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    49a4:	8c ef       	ldi	r24, 0xFC	; 252
    49a6:	96 e0       	ldi	r25, 0x06	; 6
    49a8:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    49ac:	85 e0       	ldi	r24, 0x05	; 5
    49ae:	97 e0       	ldi	r25, 0x07	; 7
    49b0:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    49b4:	8e e0       	ldi	r24, 0x0E	; 14
    49b6:	97 e0       	ldi	r25, 0x07	; 7
    49b8:	0e 94 c9 09 	call	0x1392	; 0x1392 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    49bc:	86 ee       	ldi	r24, 0xE6	; 230
    49be:	96 e0       	ldi	r25, 0x06	; 6
    49c0:	90 93 f9 06 	sts	0x06F9, r25
    49c4:	80 93 f8 06 	sts	0x06F8, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    49c8:	8f ee       	ldi	r24, 0xEF	; 239
    49ca:	96 e0       	ldi	r25, 0x06	; 6
    49cc:	90 93 fb 06 	sts	0x06FB, r25
    49d0:	80 93 fa 06 	sts	0x06FA, r24
}
    49d4:	0f 90       	pop	r0
    49d6:	cf 91       	pop	r28
    49d8:	df 91       	pop	r29
    49da:	08 95       	ret

000049dc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    49dc:	df 93       	push	r29
    49de:	cf 93       	push	r28
    49e0:	00 d0       	rcall	.+0      	; 0x49e2 <prvCheckTasksWaitingTermination+0x6>
    49e2:	cd b7       	in	r28, 0x3d	; 61
    49e4:	de b7       	in	r29, 0x3e	; 62
    49e6:	20 c0       	rjmp	.+64     	; 0x4a28 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    49e8:	0f b6       	in	r0, 0x3f	; 63
    49ea:	f8 94       	cli
    49ec:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    49ee:	e0 91 0a 07 	lds	r30, 0x070A
    49f2:	f0 91 0b 07 	lds	r31, 0x070B
    49f6:	86 81       	ldd	r24, Z+6	; 0x06
    49f8:	97 81       	ldd	r25, Z+7	; 0x07
    49fa:	9a 83       	std	Y+2, r25	; 0x02
    49fc:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    49fe:	89 81       	ldd	r24, Y+1	; 0x01
    4a00:	9a 81       	ldd	r25, Y+2	; 0x02
    4a02:	02 96       	adiw	r24, 0x02	; 2
    4a04:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
				--uxCurrentNumberOfTasks;
    4a08:	80 91 ab 06 	lds	r24, 0x06AB
    4a0c:	81 50       	subi	r24, 0x01	; 1
    4a0e:	80 93 ab 06 	sts	0x06AB, r24
				--uxDeletedTasksWaitingCleanUp;
    4a12:	80 91 aa 06 	lds	r24, 0x06AA
    4a16:	81 50       	subi	r24, 0x01	; 1
    4a18:	80 93 aa 06 	sts	0x06AA, r24
			}
			taskEXIT_CRITICAL();
    4a1c:	0f 90       	pop	r0
    4a1e:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4a20:	89 81       	ldd	r24, Y+1	; 0x01
    4a22:	9a 81       	ldd	r25, Y+2	; 0x02
    4a24:	0e 94 1d 25 	call	0x4a3a	; 0x4a3a <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4a28:	80 91 aa 06 	lds	r24, 0x06AA
    4a2c:	88 23       	and	r24, r24
    4a2e:	e1 f6       	brne	.-72     	; 0x49e8 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4a30:	0f 90       	pop	r0
    4a32:	0f 90       	pop	r0
    4a34:	cf 91       	pop	r28
    4a36:	df 91       	pop	r29
    4a38:	08 95       	ret

00004a3a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4a3a:	df 93       	push	r29
    4a3c:	cf 93       	push	r28
    4a3e:	00 d0       	rcall	.+0      	; 0x4a40 <prvDeleteTCB+0x6>
    4a40:	cd b7       	in	r28, 0x3d	; 61
    4a42:	de b7       	in	r29, 0x3e	; 62
    4a44:	9a 83       	std	Y+2, r25	; 0x02
    4a46:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4a48:	e9 81       	ldd	r30, Y+1	; 0x01
    4a4a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a4c:	87 89       	ldd	r24, Z+23	; 0x17
    4a4e:	90 8d       	ldd	r25, Z+24	; 0x18
    4a50:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
			vPortFree( pxTCB );
    4a54:	89 81       	ldd	r24, Y+1	; 0x01
    4a56:	9a 81       	ldd	r25, Y+2	; 0x02
    4a58:	0e 94 1a 08 	call	0x1034	; 0x1034 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4a5c:	0f 90       	pop	r0
    4a5e:	0f 90       	pop	r0
    4a60:	cf 91       	pop	r28
    4a62:	df 91       	pop	r29
    4a64:	08 95       	ret

00004a66 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4a66:	df 93       	push	r29
    4a68:	cf 93       	push	r28
    4a6a:	00 d0       	rcall	.+0      	; 0x4a6c <prvResetNextTaskUnblockTime+0x6>
    4a6c:	cd b7       	in	r28, 0x3d	; 61
    4a6e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4a70:	e0 91 f8 06 	lds	r30, 0x06F8
    4a74:	f0 91 f9 06 	lds	r31, 0x06F9
    4a78:	80 81       	ld	r24, Z
    4a7a:	88 23       	and	r24, r24
    4a7c:	39 f4       	brne	.+14     	; 0x4a8c <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4a7e:	8f ef       	ldi	r24, 0xFF	; 255
    4a80:	9f ef       	ldi	r25, 0xFF	; 255
    4a82:	90 93 b5 06 	sts	0x06B5, r25
    4a86:	80 93 b4 06 	sts	0x06B4, r24
    4a8a:	13 c0       	rjmp	.+38     	; 0x4ab2 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a8c:	e0 91 f8 06 	lds	r30, 0x06F8
    4a90:	f0 91 f9 06 	lds	r31, 0x06F9
    4a94:	05 80       	ldd	r0, Z+5	; 0x05
    4a96:	f6 81       	ldd	r31, Z+6	; 0x06
    4a98:	e0 2d       	mov	r30, r0
    4a9a:	86 81       	ldd	r24, Z+6	; 0x06
    4a9c:	97 81       	ldd	r25, Z+7	; 0x07
    4a9e:	9a 83       	std	Y+2, r25	; 0x02
    4aa0:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4aa2:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa4:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa6:	82 81       	ldd	r24, Z+2	; 0x02
    4aa8:	93 81       	ldd	r25, Z+3	; 0x03
    4aaa:	90 93 b5 06 	sts	0x06B5, r25
    4aae:	80 93 b4 06 	sts	0x06B4, r24
	}
}
    4ab2:	0f 90       	pop	r0
    4ab4:	0f 90       	pop	r0
    4ab6:	cf 91       	pop	r28
    4ab8:	df 91       	pop	r29
    4aba:	08 95       	ret

00004abc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4abc:	df 93       	push	r29
    4abe:	cf 93       	push	r28
    4ac0:	00 d0       	rcall	.+0      	; 0x4ac2 <xTaskGetCurrentTaskHandle+0x6>
    4ac2:	cd b7       	in	r28, 0x3d	; 61
    4ac4:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4ac6:	80 91 a8 06 	lds	r24, 0x06A8
    4aca:	90 91 a9 06 	lds	r25, 0x06A9
    4ace:	9a 83       	std	Y+2, r25	; 0x02
    4ad0:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4ad2:	89 81       	ldd	r24, Y+1	; 0x01
    4ad4:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4ad6:	0f 90       	pop	r0
    4ad8:	0f 90       	pop	r0
    4ada:	cf 91       	pop	r28
    4adc:	df 91       	pop	r29
    4ade:	08 95       	ret

00004ae0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4ae0:	df 93       	push	r29
    4ae2:	cf 93       	push	r28
    4ae4:	00 d0       	rcall	.+0      	; 0x4ae6 <uxTaskResetEventItemValue+0x6>
    4ae6:	cd b7       	in	r28, 0x3d	; 61
    4ae8:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4aea:	e0 91 a8 06 	lds	r30, 0x06A8
    4aee:	f0 91 a9 06 	lds	r31, 0x06A9
    4af2:	84 85       	ldd	r24, Z+12	; 0x0c
    4af4:	95 85       	ldd	r25, Z+13	; 0x0d
    4af6:	9a 83       	std	Y+2, r25	; 0x02
    4af8:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4afa:	a0 91 a8 06 	lds	r26, 0x06A8
    4afe:	b0 91 a9 06 	lds	r27, 0x06A9
    4b02:	e0 91 a8 06 	lds	r30, 0x06A8
    4b06:	f0 91 a9 06 	lds	r31, 0x06A9
    4b0a:	86 89       	ldd	r24, Z+22	; 0x16
    4b0c:	28 2f       	mov	r18, r24
    4b0e:	30 e0       	ldi	r19, 0x00	; 0
    4b10:	85 e0       	ldi	r24, 0x05	; 5
    4b12:	90 e0       	ldi	r25, 0x00	; 0
    4b14:	82 1b       	sub	r24, r18
    4b16:	93 0b       	sbc	r25, r19
    4b18:	1d 96       	adiw	r26, 0x0d	; 13
    4b1a:	9c 93       	st	X, r25
    4b1c:	8e 93       	st	-X, r24
    4b1e:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4b20:	89 81       	ldd	r24, Y+1	; 0x01
    4b22:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4b24:	0f 90       	pop	r0
    4b26:	0f 90       	pop	r0
    4b28:	cf 91       	pop	r28
    4b2a:	df 91       	pop	r29
    4b2c:	08 95       	ret

00004b2e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4b2e:	df 93       	push	r29
    4b30:	cf 93       	push	r28
    4b32:	cd b7       	in	r28, 0x3d	; 61
    4b34:	de b7       	in	r29, 0x3e	; 62
    4b36:	27 97       	sbiw	r28, 0x07	; 7
    4b38:	0f b6       	in	r0, 0x3f	; 63
    4b3a:	f8 94       	cli
    4b3c:	de bf       	out	0x3e, r29	; 62
    4b3e:	0f be       	out	0x3f, r0	; 63
    4b40:	cd bf       	out	0x3d, r28	; 61
    4b42:	8d 83       	std	Y+5, r24	; 0x05
    4b44:	7f 83       	std	Y+7, r23	; 0x07
    4b46:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4b48:	0f b6       	in	r0, 0x3f	; 63
    4b4a:	f8 94       	cli
    4b4c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4b4e:	e0 91 a8 06 	lds	r30, 0x06A8
    4b52:	f0 91 a9 06 	lds	r31, 0x06A9
    4b56:	81 a1       	ldd	r24, Z+33	; 0x21
    4b58:	92 a1       	ldd	r25, Z+34	; 0x22
    4b5a:	a3 a1       	ldd	r26, Z+35	; 0x23
    4b5c:	b4 a1       	ldd	r27, Z+36	; 0x24
    4b5e:	00 97       	sbiw	r24, 0x00	; 0
    4b60:	a1 05       	cpc	r26, r1
    4b62:	b1 05       	cpc	r27, r1
    4b64:	89 f4       	brne	.+34     	; 0x4b88 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4b66:	e0 91 a8 06 	lds	r30, 0x06A8
    4b6a:	f0 91 a9 06 	lds	r31, 0x06A9
    4b6e:	81 e0       	ldi	r24, 0x01	; 1
    4b70:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4b72:	8e 81       	ldd	r24, Y+6	; 0x06
    4b74:	9f 81       	ldd	r25, Y+7	; 0x07
    4b76:	00 97       	sbiw	r24, 0x00	; 0
    4b78:	39 f0       	breq	.+14     	; 0x4b88 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4b7a:	8e 81       	ldd	r24, Y+6	; 0x06
    4b7c:	9f 81       	ldd	r25, Y+7	; 0x07
    4b7e:	61 e0       	ldi	r22, 0x01	; 1
    4b80:	0e 94 3f 29 	call	0x527e	; 0x527e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4b84:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4b88:	0f 90       	pop	r0
    4b8a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4b8c:	0f b6       	in	r0, 0x3f	; 63
    4b8e:	f8 94       	cli
    4b90:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4b92:	e0 91 a8 06 	lds	r30, 0x06A8
    4b96:	f0 91 a9 06 	lds	r31, 0x06A9
    4b9a:	81 a1       	ldd	r24, Z+33	; 0x21
    4b9c:	92 a1       	ldd	r25, Z+34	; 0x22
    4b9e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4ba0:	b4 a1       	ldd	r27, Z+36	; 0x24
    4ba2:	89 83       	std	Y+1, r24	; 0x01
    4ba4:	9a 83       	std	Y+2, r25	; 0x02
    4ba6:	ab 83       	std	Y+3, r26	; 0x03
    4ba8:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4baa:	89 81       	ldd	r24, Y+1	; 0x01
    4bac:	9a 81       	ldd	r25, Y+2	; 0x02
    4bae:	ab 81       	ldd	r26, Y+3	; 0x03
    4bb0:	bc 81       	ldd	r27, Y+4	; 0x04
    4bb2:	00 97       	sbiw	r24, 0x00	; 0
    4bb4:	a1 05       	cpc	r26, r1
    4bb6:	b1 05       	cpc	r27, r1
    4bb8:	d9 f0       	breq	.+54     	; 0x4bf0 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4bba:	8d 81       	ldd	r24, Y+5	; 0x05
    4bbc:	88 23       	and	r24, r24
    4bbe:	49 f0       	breq	.+18     	; 0x4bd2 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4bc0:	e0 91 a8 06 	lds	r30, 0x06A8
    4bc4:	f0 91 a9 06 	lds	r31, 0x06A9
    4bc8:	11 a2       	std	Z+33, r1	; 0x21
    4bca:	12 a2       	std	Z+34, r1	; 0x22
    4bcc:	13 a2       	std	Z+35, r1	; 0x23
    4bce:	14 a2       	std	Z+36, r1	; 0x24
    4bd0:	0f c0       	rjmp	.+30     	; 0x4bf0 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4bd2:	e0 91 a8 06 	lds	r30, 0x06A8
    4bd6:	f0 91 a9 06 	lds	r31, 0x06A9
    4bda:	89 81       	ldd	r24, Y+1	; 0x01
    4bdc:	9a 81       	ldd	r25, Y+2	; 0x02
    4bde:	ab 81       	ldd	r26, Y+3	; 0x03
    4be0:	bc 81       	ldd	r27, Y+4	; 0x04
    4be2:	01 97       	sbiw	r24, 0x01	; 1
    4be4:	a1 09       	sbc	r26, r1
    4be6:	b1 09       	sbc	r27, r1
    4be8:	81 a3       	std	Z+33, r24	; 0x21
    4bea:	92 a3       	std	Z+34, r25	; 0x22
    4bec:	a3 a3       	std	Z+35, r26	; 0x23
    4bee:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4bf0:	e0 91 a8 06 	lds	r30, 0x06A8
    4bf4:	f0 91 a9 06 	lds	r31, 0x06A9
    4bf8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4bfa:	0f 90       	pop	r0
    4bfc:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4bfe:	89 81       	ldd	r24, Y+1	; 0x01
    4c00:	9a 81       	ldd	r25, Y+2	; 0x02
    4c02:	ab 81       	ldd	r26, Y+3	; 0x03
    4c04:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4c06:	bc 01       	movw	r22, r24
    4c08:	cd 01       	movw	r24, r26
    4c0a:	27 96       	adiw	r28, 0x07	; 7
    4c0c:	0f b6       	in	r0, 0x3f	; 63
    4c0e:	f8 94       	cli
    4c10:	de bf       	out	0x3e, r29	; 62
    4c12:	0f be       	out	0x3f, r0	; 63
    4c14:	cd bf       	out	0x3d, r28	; 61
    4c16:	cf 91       	pop	r28
    4c18:	df 91       	pop	r29
    4c1a:	08 95       	ret

00004c1c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4c1c:	ef 92       	push	r14
    4c1e:	ff 92       	push	r15
    4c20:	0f 93       	push	r16
    4c22:	1f 93       	push	r17
    4c24:	df 93       	push	r29
    4c26:	cf 93       	push	r28
    4c28:	cd b7       	in	r28, 0x3d	; 61
    4c2a:	de b7       	in	r29, 0x3e	; 62
    4c2c:	2d 97       	sbiw	r28, 0x0d	; 13
    4c2e:	0f b6       	in	r0, 0x3f	; 63
    4c30:	f8 94       	cli
    4c32:	de bf       	out	0x3e, r29	; 62
    4c34:	0f be       	out	0x3f, r0	; 63
    4c36:	cd bf       	out	0x3d, r28	; 61
    4c38:	6a 83       	std	Y+2, r22	; 0x02
    4c3a:	7b 83       	std	Y+3, r23	; 0x03
    4c3c:	8c 83       	std	Y+4, r24	; 0x04
    4c3e:	9d 83       	std	Y+5, r25	; 0x05
    4c40:	2e 83       	std	Y+6, r18	; 0x06
    4c42:	3f 83       	std	Y+7, r19	; 0x07
    4c44:	48 87       	std	Y+8, r20	; 0x08
    4c46:	59 87       	std	Y+9, r21	; 0x09
    4c48:	1b 87       	std	Y+11, r17	; 0x0b
    4c4a:	0a 87       	std	Y+10, r16	; 0x0a
    4c4c:	fd 86       	std	Y+13, r15	; 0x0d
    4c4e:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4c50:	0f b6       	in	r0, 0x3f	; 63
    4c52:	f8 94       	cli
    4c54:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4c56:	e0 91 a8 06 	lds	r30, 0x06A8
    4c5a:	f0 91 a9 06 	lds	r31, 0x06A9
    4c5e:	85 a1       	ldd	r24, Z+37	; 0x25
    4c60:	82 30       	cpi	r24, 0x02	; 2
    4c62:	49 f1       	breq	.+82     	; 0x4cb6 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4c64:	e0 91 a8 06 	lds	r30, 0x06A8
    4c68:	f0 91 a9 06 	lds	r31, 0x06A9
    4c6c:	21 a1       	ldd	r18, Z+33	; 0x21
    4c6e:	32 a1       	ldd	r19, Z+34	; 0x22
    4c70:	43 a1       	ldd	r20, Z+35	; 0x23
    4c72:	54 a1       	ldd	r21, Z+36	; 0x24
    4c74:	8a 81       	ldd	r24, Y+2	; 0x02
    4c76:	9b 81       	ldd	r25, Y+3	; 0x03
    4c78:	ac 81       	ldd	r26, Y+4	; 0x04
    4c7a:	bd 81       	ldd	r27, Y+5	; 0x05
    4c7c:	80 95       	com	r24
    4c7e:	90 95       	com	r25
    4c80:	a0 95       	com	r26
    4c82:	b0 95       	com	r27
    4c84:	82 23       	and	r24, r18
    4c86:	93 23       	and	r25, r19
    4c88:	a4 23       	and	r26, r20
    4c8a:	b5 23       	and	r27, r21
    4c8c:	81 a3       	std	Z+33, r24	; 0x21
    4c8e:	92 a3       	std	Z+34, r25	; 0x22
    4c90:	a3 a3       	std	Z+35, r26	; 0x23
    4c92:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4c94:	e0 91 a8 06 	lds	r30, 0x06A8
    4c98:	f0 91 a9 06 	lds	r31, 0x06A9
    4c9c:	81 e0       	ldi	r24, 0x01	; 1
    4c9e:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    4ca0:	8c 85       	ldd	r24, Y+12	; 0x0c
    4ca2:	9d 85       	ldd	r25, Y+13	; 0x0d
    4ca4:	00 97       	sbiw	r24, 0x00	; 0
    4ca6:	39 f0       	breq	.+14     	; 0x4cb6 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4ca8:	8c 85       	ldd	r24, Y+12	; 0x0c
    4caa:	9d 85       	ldd	r25, Y+13	; 0x0d
    4cac:	61 e0       	ldi	r22, 0x01	; 1
    4cae:	0e 94 3f 29 	call	0x527e	; 0x527e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4cb2:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4cb6:	0f 90       	pop	r0
    4cb8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4cba:	0f b6       	in	r0, 0x3f	; 63
    4cbc:	f8 94       	cli
    4cbe:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4cc0:	8a 85       	ldd	r24, Y+10	; 0x0a
    4cc2:	9b 85       	ldd	r25, Y+11	; 0x0b
    4cc4:	00 97       	sbiw	r24, 0x00	; 0
    4cc6:	71 f0       	breq	.+28     	; 0x4ce4 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4cc8:	e0 91 a8 06 	lds	r30, 0x06A8
    4ccc:	f0 91 a9 06 	lds	r31, 0x06A9
    4cd0:	81 a1       	ldd	r24, Z+33	; 0x21
    4cd2:	92 a1       	ldd	r25, Z+34	; 0x22
    4cd4:	a3 a1       	ldd	r26, Z+35	; 0x23
    4cd6:	b4 a1       	ldd	r27, Z+36	; 0x24
    4cd8:	ea 85       	ldd	r30, Y+10	; 0x0a
    4cda:	fb 85       	ldd	r31, Y+11	; 0x0b
    4cdc:	80 83       	st	Z, r24
    4cde:	91 83       	std	Z+1, r25	; 0x01
    4ce0:	a2 83       	std	Z+2, r26	; 0x02
    4ce2:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4ce4:	e0 91 a8 06 	lds	r30, 0x06A8
    4ce8:	f0 91 a9 06 	lds	r31, 0x06A9
    4cec:	85 a1       	ldd	r24, Z+37	; 0x25
    4cee:	82 30       	cpi	r24, 0x02	; 2
    4cf0:	11 f0       	breq	.+4      	; 0x4cf6 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4cf2:	19 82       	std	Y+1, r1	; 0x01
    4cf4:	1a c0       	rjmp	.+52     	; 0x4d2a <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4cf6:	e0 91 a8 06 	lds	r30, 0x06A8
    4cfa:	f0 91 a9 06 	lds	r31, 0x06A9
    4cfe:	21 a1       	ldd	r18, Z+33	; 0x21
    4d00:	32 a1       	ldd	r19, Z+34	; 0x22
    4d02:	43 a1       	ldd	r20, Z+35	; 0x23
    4d04:	54 a1       	ldd	r21, Z+36	; 0x24
    4d06:	8e 81       	ldd	r24, Y+6	; 0x06
    4d08:	9f 81       	ldd	r25, Y+7	; 0x07
    4d0a:	a8 85       	ldd	r26, Y+8	; 0x08
    4d0c:	b9 85       	ldd	r27, Y+9	; 0x09
    4d0e:	80 95       	com	r24
    4d10:	90 95       	com	r25
    4d12:	a0 95       	com	r26
    4d14:	b0 95       	com	r27
    4d16:	82 23       	and	r24, r18
    4d18:	93 23       	and	r25, r19
    4d1a:	a4 23       	and	r26, r20
    4d1c:	b5 23       	and	r27, r21
    4d1e:	81 a3       	std	Z+33, r24	; 0x21
    4d20:	92 a3       	std	Z+34, r25	; 0x22
    4d22:	a3 a3       	std	Z+35, r26	; 0x23
    4d24:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    4d26:	81 e0       	ldi	r24, 0x01	; 1
    4d28:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4d2a:	e0 91 a8 06 	lds	r30, 0x06A8
    4d2e:	f0 91 a9 06 	lds	r31, 0x06A9
    4d32:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4d34:	0f 90       	pop	r0
    4d36:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4d38:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4d3a:	2d 96       	adiw	r28, 0x0d	; 13
    4d3c:	0f b6       	in	r0, 0x3f	; 63
    4d3e:	f8 94       	cli
    4d40:	de bf       	out	0x3e, r29	; 62
    4d42:	0f be       	out	0x3f, r0	; 63
    4d44:	cd bf       	out	0x3d, r28	; 61
    4d46:	cf 91       	pop	r28
    4d48:	df 91       	pop	r29
    4d4a:	1f 91       	pop	r17
    4d4c:	0f 91       	pop	r16
    4d4e:	ff 90       	pop	r15
    4d50:	ef 90       	pop	r14
    4d52:	08 95       	ret

00004d54 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4d54:	0f 93       	push	r16
    4d56:	1f 93       	push	r17
    4d58:	df 93       	push	r29
    4d5a:	cf 93       	push	r28
    4d5c:	cd b7       	in	r28, 0x3d	; 61
    4d5e:	de b7       	in	r29, 0x3e	; 62
    4d60:	2f 97       	sbiw	r28, 0x0f	; 15
    4d62:	0f b6       	in	r0, 0x3f	; 63
    4d64:	f8 94       	cli
    4d66:	de bf       	out	0x3e, r29	; 62
    4d68:	0f be       	out	0x3f, r0	; 63
    4d6a:	cd bf       	out	0x3d, r28	; 61
    4d6c:	9e 83       	std	Y+6, r25	; 0x06
    4d6e:	8d 83       	std	Y+5, r24	; 0x05
    4d70:	4f 83       	std	Y+7, r20	; 0x07
    4d72:	58 87       	std	Y+8, r21	; 0x08
    4d74:	69 87       	std	Y+9, r22	; 0x09
    4d76:	7a 87       	std	Y+10, r23	; 0x0a
    4d78:	2b 87       	std	Y+11, r18	; 0x0b
    4d7a:	1d 87       	std	Y+13, r17	; 0x0d
    4d7c:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    4d7e:	81 e0       	ldi	r24, 0x01	; 1
    4d80:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    4d82:	8d 81       	ldd	r24, Y+5	; 0x05
    4d84:	9e 81       	ldd	r25, Y+6	; 0x06
    4d86:	9c 83       	std	Y+4, r25	; 0x04
    4d88:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4d8a:	0f b6       	in	r0, 0x3f	; 63
    4d8c:	f8 94       	cli
    4d8e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4d90:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d92:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d94:	00 97       	sbiw	r24, 0x00	; 0
    4d96:	61 f0       	breq	.+24     	; 0x4db0 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4d98:	eb 81       	ldd	r30, Y+3	; 0x03
    4d9a:	fc 81       	ldd	r31, Y+4	; 0x04
    4d9c:	81 a1       	ldd	r24, Z+33	; 0x21
    4d9e:	92 a1       	ldd	r25, Z+34	; 0x22
    4da0:	a3 a1       	ldd	r26, Z+35	; 0x23
    4da2:	b4 a1       	ldd	r27, Z+36	; 0x24
    4da4:	ec 85       	ldd	r30, Y+12	; 0x0c
    4da6:	fd 85       	ldd	r31, Y+13	; 0x0d
    4da8:	80 83       	st	Z, r24
    4daa:	91 83       	std	Z+1, r25	; 0x01
    4dac:	a2 83       	std	Z+2, r26	; 0x02
    4dae:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4db0:	eb 81       	ldd	r30, Y+3	; 0x03
    4db2:	fc 81       	ldd	r31, Y+4	; 0x04
    4db4:	85 a1       	ldd	r24, Z+37	; 0x25
    4db6:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4db8:	eb 81       	ldd	r30, Y+3	; 0x03
    4dba:	fc 81       	ldd	r31, Y+4	; 0x04
    4dbc:	82 e0       	ldi	r24, 0x02	; 2
    4dbe:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4dc0:	8b 85       	ldd	r24, Y+11	; 0x0b
    4dc2:	28 2f       	mov	r18, r24
    4dc4:	30 e0       	ldi	r19, 0x00	; 0
    4dc6:	3f 87       	std	Y+15, r19	; 0x0f
    4dc8:	2e 87       	std	Y+14, r18	; 0x0e
    4dca:	8e 85       	ldd	r24, Y+14	; 0x0e
    4dcc:	9f 85       	ldd	r25, Y+15	; 0x0f
    4dce:	82 30       	cpi	r24, 0x02	; 2
    4dd0:	91 05       	cpc	r25, r1
    4dd2:	59 f1       	breq	.+86     	; 0x4e2a <xTaskGenericNotify+0xd6>
    4dd4:	2e 85       	ldd	r18, Y+14	; 0x0e
    4dd6:	3f 85       	ldd	r19, Y+15	; 0x0f
    4dd8:	23 30       	cpi	r18, 0x03	; 3
    4dda:	31 05       	cpc	r19, r1
    4ddc:	34 f4       	brge	.+12     	; 0x4dea <xTaskGenericNotify+0x96>
    4dde:	8e 85       	ldd	r24, Y+14	; 0x0e
    4de0:	9f 85       	ldd	r25, Y+15	; 0x0f
    4de2:	81 30       	cpi	r24, 0x01	; 1
    4de4:	91 05       	cpc	r25, r1
    4de6:	61 f0       	breq	.+24     	; 0x4e00 <xTaskGenericNotify+0xac>
    4de8:	4a c0       	rjmp	.+148    	; 0x4e7e <xTaskGenericNotify+0x12a>
    4dea:	2e 85       	ldd	r18, Y+14	; 0x0e
    4dec:	3f 85       	ldd	r19, Y+15	; 0x0f
    4dee:	23 30       	cpi	r18, 0x03	; 3
    4df0:	31 05       	cpc	r19, r1
    4df2:	59 f1       	breq	.+86     	; 0x4e4a <xTaskGenericNotify+0xf6>
    4df4:	8e 85       	ldd	r24, Y+14	; 0x0e
    4df6:	9f 85       	ldd	r25, Y+15	; 0x0f
    4df8:	84 30       	cpi	r24, 0x04	; 4
    4dfa:	91 05       	cpc	r25, r1
    4dfc:	89 f1       	breq	.+98     	; 0x4e60 <xTaskGenericNotify+0x10c>
    4dfe:	3f c0       	rjmp	.+126    	; 0x4e7e <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4e00:	eb 81       	ldd	r30, Y+3	; 0x03
    4e02:	fc 81       	ldd	r31, Y+4	; 0x04
    4e04:	21 a1       	ldd	r18, Z+33	; 0x21
    4e06:	32 a1       	ldd	r19, Z+34	; 0x22
    4e08:	43 a1       	ldd	r20, Z+35	; 0x23
    4e0a:	54 a1       	ldd	r21, Z+36	; 0x24
    4e0c:	8f 81       	ldd	r24, Y+7	; 0x07
    4e0e:	98 85       	ldd	r25, Y+8	; 0x08
    4e10:	a9 85       	ldd	r26, Y+9	; 0x09
    4e12:	ba 85       	ldd	r27, Y+10	; 0x0a
    4e14:	82 2b       	or	r24, r18
    4e16:	93 2b       	or	r25, r19
    4e18:	a4 2b       	or	r26, r20
    4e1a:	b5 2b       	or	r27, r21
    4e1c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e1e:	fc 81       	ldd	r31, Y+4	; 0x04
    4e20:	81 a3       	std	Z+33, r24	; 0x21
    4e22:	92 a3       	std	Z+34, r25	; 0x22
    4e24:	a3 a3       	std	Z+35, r26	; 0x23
    4e26:	b4 a3       	std	Z+36, r27	; 0x24
    4e28:	2a c0       	rjmp	.+84     	; 0x4e7e <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4e2a:	eb 81       	ldd	r30, Y+3	; 0x03
    4e2c:	fc 81       	ldd	r31, Y+4	; 0x04
    4e2e:	81 a1       	ldd	r24, Z+33	; 0x21
    4e30:	92 a1       	ldd	r25, Z+34	; 0x22
    4e32:	a3 a1       	ldd	r26, Z+35	; 0x23
    4e34:	b4 a1       	ldd	r27, Z+36	; 0x24
    4e36:	01 96       	adiw	r24, 0x01	; 1
    4e38:	a1 1d       	adc	r26, r1
    4e3a:	b1 1d       	adc	r27, r1
    4e3c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e3e:	fc 81       	ldd	r31, Y+4	; 0x04
    4e40:	81 a3       	std	Z+33, r24	; 0x21
    4e42:	92 a3       	std	Z+34, r25	; 0x22
    4e44:	a3 a3       	std	Z+35, r26	; 0x23
    4e46:	b4 a3       	std	Z+36, r27	; 0x24
    4e48:	1a c0       	rjmp	.+52     	; 0x4e7e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    4e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    4e4e:	8f 81       	ldd	r24, Y+7	; 0x07
    4e50:	98 85       	ldd	r25, Y+8	; 0x08
    4e52:	a9 85       	ldd	r26, Y+9	; 0x09
    4e54:	ba 85       	ldd	r27, Y+10	; 0x0a
    4e56:	81 a3       	std	Z+33, r24	; 0x21
    4e58:	92 a3       	std	Z+34, r25	; 0x22
    4e5a:	a3 a3       	std	Z+35, r26	; 0x23
    4e5c:	b4 a3       	std	Z+36, r27	; 0x24
    4e5e:	0f c0       	rjmp	.+30     	; 0x4e7e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4e60:	89 81       	ldd	r24, Y+1	; 0x01
    4e62:	82 30       	cpi	r24, 0x02	; 2
    4e64:	59 f0       	breq	.+22     	; 0x4e7c <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4e66:	eb 81       	ldd	r30, Y+3	; 0x03
    4e68:	fc 81       	ldd	r31, Y+4	; 0x04
    4e6a:	8f 81       	ldd	r24, Y+7	; 0x07
    4e6c:	98 85       	ldd	r25, Y+8	; 0x08
    4e6e:	a9 85       	ldd	r26, Y+9	; 0x09
    4e70:	ba 85       	ldd	r27, Y+10	; 0x0a
    4e72:	81 a3       	std	Z+33, r24	; 0x21
    4e74:	92 a3       	std	Z+34, r25	; 0x22
    4e76:	a3 a3       	std	Z+35, r26	; 0x23
    4e78:	b4 a3       	std	Z+36, r27	; 0x24
    4e7a:	01 c0       	rjmp	.+2      	; 0x4e7e <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4e7c:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4e7e:	89 81       	ldd	r24, Y+1	; 0x01
    4e80:	81 30       	cpi	r24, 0x01	; 1
    4e82:	b9 f5       	brne	.+110    	; 0x4ef2 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4e84:	8b 81       	ldd	r24, Y+3	; 0x03
    4e86:	9c 81       	ldd	r25, Y+4	; 0x04
    4e88:	02 96       	adiw	r24, 0x02	; 2
    4e8a:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4e8e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e90:	fc 81       	ldd	r31, Y+4	; 0x04
    4e92:	96 89       	ldd	r25, Z+22	; 0x16
    4e94:	80 91 ae 06 	lds	r24, 0x06AE
    4e98:	89 17       	cp	r24, r25
    4e9a:	28 f4       	brcc	.+10     	; 0x4ea6 <xTaskGenericNotify+0x152>
    4e9c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e9e:	fc 81       	ldd	r31, Y+4	; 0x04
    4ea0:	86 89       	ldd	r24, Z+22	; 0x16
    4ea2:	80 93 ae 06 	sts	0x06AE, r24
    4ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    4eaa:	86 89       	ldd	r24, Z+22	; 0x16
    4eac:	28 2f       	mov	r18, r24
    4eae:	30 e0       	ldi	r19, 0x00	; 0
    4eb0:	c9 01       	movw	r24, r18
    4eb2:	88 0f       	add	r24, r24
    4eb4:	99 1f       	adc	r25, r25
    4eb6:	88 0f       	add	r24, r24
    4eb8:	99 1f       	adc	r25, r25
    4eba:	88 0f       	add	r24, r24
    4ebc:	99 1f       	adc	r25, r25
    4ebe:	82 0f       	add	r24, r18
    4ec0:	93 1f       	adc	r25, r19
    4ec2:	ac 01       	movw	r20, r24
    4ec4:	47 54       	subi	r20, 0x47	; 71
    4ec6:	59 4f       	sbci	r21, 0xF9	; 249
    4ec8:	8b 81       	ldd	r24, Y+3	; 0x03
    4eca:	9c 81       	ldd	r25, Y+4	; 0x04
    4ecc:	9c 01       	movw	r18, r24
    4ece:	2e 5f       	subi	r18, 0xFE	; 254
    4ed0:	3f 4f       	sbci	r19, 0xFF	; 255
    4ed2:	ca 01       	movw	r24, r20
    4ed4:	b9 01       	movw	r22, r18
    4ed6:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4eda:	eb 81       	ldd	r30, Y+3	; 0x03
    4edc:	fc 81       	ldd	r31, Y+4	; 0x04
    4ede:	96 89       	ldd	r25, Z+22	; 0x16
    4ee0:	e0 91 a8 06 	lds	r30, 0x06A8
    4ee4:	f0 91 a9 06 	lds	r31, 0x06A9
    4ee8:	86 89       	ldd	r24, Z+22	; 0x16
    4eea:	89 17       	cp	r24, r25
    4eec:	10 f4       	brcc	.+4      	; 0x4ef2 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4eee:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4ef2:	0f 90       	pop	r0
    4ef4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4ef6:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4ef8:	2f 96       	adiw	r28, 0x0f	; 15
    4efa:	0f b6       	in	r0, 0x3f	; 63
    4efc:	f8 94       	cli
    4efe:	de bf       	out	0x3e, r29	; 62
    4f00:	0f be       	out	0x3f, r0	; 63
    4f02:	cd bf       	out	0x3d, r28	; 61
    4f04:	cf 91       	pop	r28
    4f06:	df 91       	pop	r29
    4f08:	1f 91       	pop	r17
    4f0a:	0f 91       	pop	r16
    4f0c:	08 95       	ret

00004f0e <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4f0e:	ef 92       	push	r14
    4f10:	ff 92       	push	r15
    4f12:	0f 93       	push	r16
    4f14:	1f 93       	push	r17
    4f16:	df 93       	push	r29
    4f18:	cf 93       	push	r28
    4f1a:	cd b7       	in	r28, 0x3d	; 61
    4f1c:	de b7       	in	r29, 0x3e	; 62
    4f1e:	62 97       	sbiw	r28, 0x12	; 18
    4f20:	0f b6       	in	r0, 0x3f	; 63
    4f22:	f8 94       	cli
    4f24:	de bf       	out	0x3e, r29	; 62
    4f26:	0f be       	out	0x3f, r0	; 63
    4f28:	cd bf       	out	0x3d, r28	; 61
    4f2a:	9f 83       	std	Y+7, r25	; 0x07
    4f2c:	8e 83       	std	Y+6, r24	; 0x06
    4f2e:	48 87       	std	Y+8, r20	; 0x08
    4f30:	59 87       	std	Y+9, r21	; 0x09
    4f32:	6a 87       	std	Y+10, r22	; 0x0a
    4f34:	7b 87       	std	Y+11, r23	; 0x0b
    4f36:	2c 87       	std	Y+12, r18	; 0x0c
    4f38:	1e 87       	std	Y+14, r17	; 0x0e
    4f3a:	0d 87       	std	Y+13, r16	; 0x0d
    4f3c:	f8 8a       	std	Y+16, r15	; 0x10
    4f3e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4f40:	81 e0       	ldi	r24, 0x01	; 1
    4f42:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4f44:	8e 81       	ldd	r24, Y+6	; 0x06
    4f46:	9f 81       	ldd	r25, Y+7	; 0x07
    4f48:	9d 83       	std	Y+5, r25	; 0x05
    4f4a:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f4c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    4f4e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f50:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f52:	00 97       	sbiw	r24, 0x00	; 0
    4f54:	61 f0       	breq	.+24     	; 0x4f6e <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4f56:	ec 81       	ldd	r30, Y+4	; 0x04
    4f58:	fd 81       	ldd	r31, Y+5	; 0x05
    4f5a:	81 a1       	ldd	r24, Z+33	; 0x21
    4f5c:	92 a1       	ldd	r25, Z+34	; 0x22
    4f5e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4f60:	b4 a1       	ldd	r27, Z+36	; 0x24
    4f62:	ed 85       	ldd	r30, Y+13	; 0x0d
    4f64:	fe 85       	ldd	r31, Y+14	; 0x0e
    4f66:	80 83       	st	Z, r24
    4f68:	91 83       	std	Z+1, r25	; 0x01
    4f6a:	a2 83       	std	Z+2, r26	; 0x02
    4f6c:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4f6e:	ec 81       	ldd	r30, Y+4	; 0x04
    4f70:	fd 81       	ldd	r31, Y+5	; 0x05
    4f72:	85 a1       	ldd	r24, Z+37	; 0x25
    4f74:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4f76:	ec 81       	ldd	r30, Y+4	; 0x04
    4f78:	fd 81       	ldd	r31, Y+5	; 0x05
    4f7a:	82 e0       	ldi	r24, 0x02	; 2
    4f7c:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4f7e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4f80:	28 2f       	mov	r18, r24
    4f82:	30 e0       	ldi	r19, 0x00	; 0
    4f84:	3a 8b       	std	Y+18, r19	; 0x12
    4f86:	29 8b       	std	Y+17, r18	; 0x11
    4f88:	89 89       	ldd	r24, Y+17	; 0x11
    4f8a:	9a 89       	ldd	r25, Y+18	; 0x12
    4f8c:	82 30       	cpi	r24, 0x02	; 2
    4f8e:	91 05       	cpc	r25, r1
    4f90:	59 f1       	breq	.+86     	; 0x4fe8 <xTaskGenericNotifyFromISR+0xda>
    4f92:	29 89       	ldd	r18, Y+17	; 0x11
    4f94:	3a 89       	ldd	r19, Y+18	; 0x12
    4f96:	23 30       	cpi	r18, 0x03	; 3
    4f98:	31 05       	cpc	r19, r1
    4f9a:	34 f4       	brge	.+12     	; 0x4fa8 <xTaskGenericNotifyFromISR+0x9a>
    4f9c:	89 89       	ldd	r24, Y+17	; 0x11
    4f9e:	9a 89       	ldd	r25, Y+18	; 0x12
    4fa0:	81 30       	cpi	r24, 0x01	; 1
    4fa2:	91 05       	cpc	r25, r1
    4fa4:	61 f0       	breq	.+24     	; 0x4fbe <xTaskGenericNotifyFromISR+0xb0>
    4fa6:	4a c0       	rjmp	.+148    	; 0x503c <xTaskGenericNotifyFromISR+0x12e>
    4fa8:	29 89       	ldd	r18, Y+17	; 0x11
    4faa:	3a 89       	ldd	r19, Y+18	; 0x12
    4fac:	23 30       	cpi	r18, 0x03	; 3
    4fae:	31 05       	cpc	r19, r1
    4fb0:	59 f1       	breq	.+86     	; 0x5008 <xTaskGenericNotifyFromISR+0xfa>
    4fb2:	89 89       	ldd	r24, Y+17	; 0x11
    4fb4:	9a 89       	ldd	r25, Y+18	; 0x12
    4fb6:	84 30       	cpi	r24, 0x04	; 4
    4fb8:	91 05       	cpc	r25, r1
    4fba:	89 f1       	breq	.+98     	; 0x501e <xTaskGenericNotifyFromISR+0x110>
    4fbc:	3f c0       	rjmp	.+126    	; 0x503c <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4fbe:	ec 81       	ldd	r30, Y+4	; 0x04
    4fc0:	fd 81       	ldd	r31, Y+5	; 0x05
    4fc2:	21 a1       	ldd	r18, Z+33	; 0x21
    4fc4:	32 a1       	ldd	r19, Z+34	; 0x22
    4fc6:	43 a1       	ldd	r20, Z+35	; 0x23
    4fc8:	54 a1       	ldd	r21, Z+36	; 0x24
    4fca:	88 85       	ldd	r24, Y+8	; 0x08
    4fcc:	99 85       	ldd	r25, Y+9	; 0x09
    4fce:	aa 85       	ldd	r26, Y+10	; 0x0a
    4fd0:	bb 85       	ldd	r27, Y+11	; 0x0b
    4fd2:	82 2b       	or	r24, r18
    4fd4:	93 2b       	or	r25, r19
    4fd6:	a4 2b       	or	r26, r20
    4fd8:	b5 2b       	or	r27, r21
    4fda:	ec 81       	ldd	r30, Y+4	; 0x04
    4fdc:	fd 81       	ldd	r31, Y+5	; 0x05
    4fde:	81 a3       	std	Z+33, r24	; 0x21
    4fe0:	92 a3       	std	Z+34, r25	; 0x22
    4fe2:	a3 a3       	std	Z+35, r26	; 0x23
    4fe4:	b4 a3       	std	Z+36, r27	; 0x24
    4fe6:	2a c0       	rjmp	.+84     	; 0x503c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4fe8:	ec 81       	ldd	r30, Y+4	; 0x04
    4fea:	fd 81       	ldd	r31, Y+5	; 0x05
    4fec:	81 a1       	ldd	r24, Z+33	; 0x21
    4fee:	92 a1       	ldd	r25, Z+34	; 0x22
    4ff0:	a3 a1       	ldd	r26, Z+35	; 0x23
    4ff2:	b4 a1       	ldd	r27, Z+36	; 0x24
    4ff4:	01 96       	adiw	r24, 0x01	; 1
    4ff6:	a1 1d       	adc	r26, r1
    4ff8:	b1 1d       	adc	r27, r1
    4ffa:	ec 81       	ldd	r30, Y+4	; 0x04
    4ffc:	fd 81       	ldd	r31, Y+5	; 0x05
    4ffe:	81 a3       	std	Z+33, r24	; 0x21
    5000:	92 a3       	std	Z+34, r25	; 0x22
    5002:	a3 a3       	std	Z+35, r26	; 0x23
    5004:	b4 a3       	std	Z+36, r27	; 0x24
    5006:	1a c0       	rjmp	.+52     	; 0x503c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    5008:	ec 81       	ldd	r30, Y+4	; 0x04
    500a:	fd 81       	ldd	r31, Y+5	; 0x05
    500c:	88 85       	ldd	r24, Y+8	; 0x08
    500e:	99 85       	ldd	r25, Y+9	; 0x09
    5010:	aa 85       	ldd	r26, Y+10	; 0x0a
    5012:	bb 85       	ldd	r27, Y+11	; 0x0b
    5014:	81 a3       	std	Z+33, r24	; 0x21
    5016:	92 a3       	std	Z+34, r25	; 0x22
    5018:	a3 a3       	std	Z+35, r26	; 0x23
    501a:	b4 a3       	std	Z+36, r27	; 0x24
    501c:	0f c0       	rjmp	.+30     	; 0x503c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    501e:	8b 81       	ldd	r24, Y+3	; 0x03
    5020:	82 30       	cpi	r24, 0x02	; 2
    5022:	59 f0       	breq	.+22     	; 0x503a <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5024:	ec 81       	ldd	r30, Y+4	; 0x04
    5026:	fd 81       	ldd	r31, Y+5	; 0x05
    5028:	88 85       	ldd	r24, Y+8	; 0x08
    502a:	99 85       	ldd	r25, Y+9	; 0x09
    502c:	aa 85       	ldd	r26, Y+10	; 0x0a
    502e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5030:	81 a3       	std	Z+33, r24	; 0x21
    5032:	92 a3       	std	Z+34, r25	; 0x22
    5034:	a3 a3       	std	Z+35, r26	; 0x23
    5036:	b4 a3       	std	Z+36, r27	; 0x24
    5038:	01 c0       	rjmp	.+2      	; 0x503c <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    503a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    503c:	8b 81       	ldd	r24, Y+3	; 0x03
    503e:	81 30       	cpi	r24, 0x01	; 1
    5040:	09 f0       	breq	.+2      	; 0x5044 <xTaskGenericNotifyFromISR+0x136>
    5042:	4f c0       	rjmp	.+158    	; 0x50e2 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5044:	80 91 b8 06 	lds	r24, 0x06B8
    5048:	88 23       	and	r24, r24
    504a:	61 f5       	brne	.+88     	; 0x50a4 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    504c:	8c 81       	ldd	r24, Y+4	; 0x04
    504e:	9d 81       	ldd	r25, Y+5	; 0x05
    5050:	02 96       	adiw	r24, 0x02	; 2
    5052:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5056:	ec 81       	ldd	r30, Y+4	; 0x04
    5058:	fd 81       	ldd	r31, Y+5	; 0x05
    505a:	96 89       	ldd	r25, Z+22	; 0x16
    505c:	80 91 ae 06 	lds	r24, 0x06AE
    5060:	89 17       	cp	r24, r25
    5062:	28 f4       	brcc	.+10     	; 0x506e <xTaskGenericNotifyFromISR+0x160>
    5064:	ec 81       	ldd	r30, Y+4	; 0x04
    5066:	fd 81       	ldd	r31, Y+5	; 0x05
    5068:	86 89       	ldd	r24, Z+22	; 0x16
    506a:	80 93 ae 06 	sts	0x06AE, r24
    506e:	ec 81       	ldd	r30, Y+4	; 0x04
    5070:	fd 81       	ldd	r31, Y+5	; 0x05
    5072:	86 89       	ldd	r24, Z+22	; 0x16
    5074:	28 2f       	mov	r18, r24
    5076:	30 e0       	ldi	r19, 0x00	; 0
    5078:	c9 01       	movw	r24, r18
    507a:	88 0f       	add	r24, r24
    507c:	99 1f       	adc	r25, r25
    507e:	88 0f       	add	r24, r24
    5080:	99 1f       	adc	r25, r25
    5082:	88 0f       	add	r24, r24
    5084:	99 1f       	adc	r25, r25
    5086:	82 0f       	add	r24, r18
    5088:	93 1f       	adc	r25, r19
    508a:	ac 01       	movw	r20, r24
    508c:	47 54       	subi	r20, 0x47	; 71
    508e:	59 4f       	sbci	r21, 0xF9	; 249
    5090:	8c 81       	ldd	r24, Y+4	; 0x04
    5092:	9d 81       	ldd	r25, Y+5	; 0x05
    5094:	9c 01       	movw	r18, r24
    5096:	2e 5f       	subi	r18, 0xFE	; 254
    5098:	3f 4f       	sbci	r19, 0xFF	; 255
    509a:	ca 01       	movw	r24, r20
    509c:	b9 01       	movw	r22, r18
    509e:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    50a2:	0a c0       	rjmp	.+20     	; 0x50b8 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    50a4:	8c 81       	ldd	r24, Y+4	; 0x04
    50a6:	9d 81       	ldd	r25, Y+5	; 0x05
    50a8:	9c 01       	movw	r18, r24
    50aa:	24 5f       	subi	r18, 0xF4	; 244
    50ac:	3f 4f       	sbci	r19, 0xFF	; 255
    50ae:	8c ef       	ldi	r24, 0xFC	; 252
    50b0:	96 e0       	ldi	r25, 0x06	; 6
    50b2:	b9 01       	movw	r22, r18
    50b4:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    50b8:	ec 81       	ldd	r30, Y+4	; 0x04
    50ba:	fd 81       	ldd	r31, Y+5	; 0x05
    50bc:	96 89       	ldd	r25, Z+22	; 0x16
    50be:	e0 91 a8 06 	lds	r30, 0x06A8
    50c2:	f0 91 a9 06 	lds	r31, 0x06A9
    50c6:	86 89       	ldd	r24, Z+22	; 0x16
    50c8:	89 17       	cp	r24, r25
    50ca:	58 f4       	brcc	.+22     	; 0x50e2 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    50cc:	8f 85       	ldd	r24, Y+15	; 0x0f
    50ce:	98 89       	ldd	r25, Y+16	; 0x10
    50d0:	00 97       	sbiw	r24, 0x00	; 0
    50d2:	21 f0       	breq	.+8      	; 0x50dc <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    50d4:	ef 85       	ldd	r30, Y+15	; 0x0f
    50d6:	f8 89       	ldd	r31, Y+16	; 0x10
    50d8:	81 e0       	ldi	r24, 0x01	; 1
    50da:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    50dc:	81 e0       	ldi	r24, 0x01	; 1
    50de:	80 93 b1 06 	sts	0x06B1, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    50e2:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    50e4:	62 96       	adiw	r28, 0x12	; 18
    50e6:	0f b6       	in	r0, 0x3f	; 63
    50e8:	f8 94       	cli
    50ea:	de bf       	out	0x3e, r29	; 62
    50ec:	0f be       	out	0x3f, r0	; 63
    50ee:	cd bf       	out	0x3d, r28	; 61
    50f0:	cf 91       	pop	r28
    50f2:	df 91       	pop	r29
    50f4:	1f 91       	pop	r17
    50f6:	0f 91       	pop	r16
    50f8:	ff 90       	pop	r15
    50fa:	ef 90       	pop	r14
    50fc:	08 95       	ret

000050fe <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    50fe:	df 93       	push	r29
    5100:	cf 93       	push	r28
    5102:	cd b7       	in	r28, 0x3d	; 61
    5104:	de b7       	in	r29, 0x3e	; 62
    5106:	28 97       	sbiw	r28, 0x08	; 8
    5108:	0f b6       	in	r0, 0x3f	; 63
    510a:	f8 94       	cli
    510c:	de bf       	out	0x3e, r29	; 62
    510e:	0f be       	out	0x3f, r0	; 63
    5110:	cd bf       	out	0x3d, r28	; 61
    5112:	9e 83       	std	Y+6, r25	; 0x06
    5114:	8d 83       	std	Y+5, r24	; 0x05
    5116:	78 87       	std	Y+8, r23	; 0x08
    5118:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    511a:	8d 81       	ldd	r24, Y+5	; 0x05
    511c:	9e 81       	ldd	r25, Y+6	; 0x06
    511e:	9c 83       	std	Y+4, r25	; 0x04
    5120:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5122:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5124:	eb 81       	ldd	r30, Y+3	; 0x03
    5126:	fc 81       	ldd	r31, Y+4	; 0x04
    5128:	85 a1       	ldd	r24, Z+37	; 0x25
    512a:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    512c:	eb 81       	ldd	r30, Y+3	; 0x03
    512e:	fc 81       	ldd	r31, Y+4	; 0x04
    5130:	82 e0       	ldi	r24, 0x02	; 2
    5132:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    5134:	eb 81       	ldd	r30, Y+3	; 0x03
    5136:	fc 81       	ldd	r31, Y+4	; 0x04
    5138:	81 a1       	ldd	r24, Z+33	; 0x21
    513a:	92 a1       	ldd	r25, Z+34	; 0x22
    513c:	a3 a1       	ldd	r26, Z+35	; 0x23
    513e:	b4 a1       	ldd	r27, Z+36	; 0x24
    5140:	01 96       	adiw	r24, 0x01	; 1
    5142:	a1 1d       	adc	r26, r1
    5144:	b1 1d       	adc	r27, r1
    5146:	eb 81       	ldd	r30, Y+3	; 0x03
    5148:	fc 81       	ldd	r31, Y+4	; 0x04
    514a:	81 a3       	std	Z+33, r24	; 0x21
    514c:	92 a3       	std	Z+34, r25	; 0x22
    514e:	a3 a3       	std	Z+35, r26	; 0x23
    5150:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5152:	8a 81       	ldd	r24, Y+2	; 0x02
    5154:	81 30       	cpi	r24, 0x01	; 1
    5156:	09 f0       	breq	.+2      	; 0x515a <vTaskNotifyGiveFromISR+0x5c>
    5158:	4f c0       	rjmp	.+158    	; 0x51f8 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    515a:	80 91 b8 06 	lds	r24, 0x06B8
    515e:	88 23       	and	r24, r24
    5160:	61 f5       	brne	.+88     	; 0x51ba <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5162:	8b 81       	ldd	r24, Y+3	; 0x03
    5164:	9c 81       	ldd	r25, Y+4	; 0x04
    5166:	02 96       	adiw	r24, 0x02	; 2
    5168:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    516c:	eb 81       	ldd	r30, Y+3	; 0x03
    516e:	fc 81       	ldd	r31, Y+4	; 0x04
    5170:	96 89       	ldd	r25, Z+22	; 0x16
    5172:	80 91 ae 06 	lds	r24, 0x06AE
    5176:	89 17       	cp	r24, r25
    5178:	28 f4       	brcc	.+10     	; 0x5184 <vTaskNotifyGiveFromISR+0x86>
    517a:	eb 81       	ldd	r30, Y+3	; 0x03
    517c:	fc 81       	ldd	r31, Y+4	; 0x04
    517e:	86 89       	ldd	r24, Z+22	; 0x16
    5180:	80 93 ae 06 	sts	0x06AE, r24
    5184:	eb 81       	ldd	r30, Y+3	; 0x03
    5186:	fc 81       	ldd	r31, Y+4	; 0x04
    5188:	86 89       	ldd	r24, Z+22	; 0x16
    518a:	28 2f       	mov	r18, r24
    518c:	30 e0       	ldi	r19, 0x00	; 0
    518e:	c9 01       	movw	r24, r18
    5190:	88 0f       	add	r24, r24
    5192:	99 1f       	adc	r25, r25
    5194:	88 0f       	add	r24, r24
    5196:	99 1f       	adc	r25, r25
    5198:	88 0f       	add	r24, r24
    519a:	99 1f       	adc	r25, r25
    519c:	82 0f       	add	r24, r18
    519e:	93 1f       	adc	r25, r19
    51a0:	ac 01       	movw	r20, r24
    51a2:	47 54       	subi	r20, 0x47	; 71
    51a4:	59 4f       	sbci	r21, 0xF9	; 249
    51a6:	8b 81       	ldd	r24, Y+3	; 0x03
    51a8:	9c 81       	ldd	r25, Y+4	; 0x04
    51aa:	9c 01       	movw	r18, r24
    51ac:	2e 5f       	subi	r18, 0xFE	; 254
    51ae:	3f 4f       	sbci	r19, 0xFF	; 255
    51b0:	ca 01       	movw	r24, r20
    51b2:	b9 01       	movw	r22, r18
    51b4:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    51b8:	0a c0       	rjmp	.+20     	; 0x51ce <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    51ba:	8b 81       	ldd	r24, Y+3	; 0x03
    51bc:	9c 81       	ldd	r25, Y+4	; 0x04
    51be:	9c 01       	movw	r18, r24
    51c0:	24 5f       	subi	r18, 0xF4	; 244
    51c2:	3f 4f       	sbci	r19, 0xFF	; 255
    51c4:	8c ef       	ldi	r24, 0xFC	; 252
    51c6:	96 e0       	ldi	r25, 0x06	; 6
    51c8:	b9 01       	movw	r22, r18
    51ca:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    51ce:	eb 81       	ldd	r30, Y+3	; 0x03
    51d0:	fc 81       	ldd	r31, Y+4	; 0x04
    51d2:	96 89       	ldd	r25, Z+22	; 0x16
    51d4:	e0 91 a8 06 	lds	r30, 0x06A8
    51d8:	f0 91 a9 06 	lds	r31, 0x06A9
    51dc:	86 89       	ldd	r24, Z+22	; 0x16
    51de:	89 17       	cp	r24, r25
    51e0:	58 f4       	brcc	.+22     	; 0x51f8 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    51e2:	8f 81       	ldd	r24, Y+7	; 0x07
    51e4:	98 85       	ldd	r25, Y+8	; 0x08
    51e6:	00 97       	sbiw	r24, 0x00	; 0
    51e8:	21 f0       	breq	.+8      	; 0x51f2 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    51ea:	ef 81       	ldd	r30, Y+7	; 0x07
    51ec:	f8 85       	ldd	r31, Y+8	; 0x08
    51ee:	81 e0       	ldi	r24, 0x01	; 1
    51f0:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    51f2:	81 e0       	ldi	r24, 0x01	; 1
    51f4:	80 93 b1 06 	sts	0x06B1, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    51f8:	28 96       	adiw	r28, 0x08	; 8
    51fa:	0f b6       	in	r0, 0x3f	; 63
    51fc:	f8 94       	cli
    51fe:	de bf       	out	0x3e, r29	; 62
    5200:	0f be       	out	0x3f, r0	; 63
    5202:	cd bf       	out	0x3d, r28	; 61
    5204:	cf 91       	pop	r28
    5206:	df 91       	pop	r29
    5208:	08 95       	ret

0000520a <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    520a:	df 93       	push	r29
    520c:	cf 93       	push	r28
    520e:	cd b7       	in	r28, 0x3d	; 61
    5210:	de b7       	in	r29, 0x3e	; 62
    5212:	27 97       	sbiw	r28, 0x07	; 7
    5214:	0f b6       	in	r0, 0x3f	; 63
    5216:	f8 94       	cli
    5218:	de bf       	out	0x3e, r29	; 62
    521a:	0f be       	out	0x3f, r0	; 63
    521c:	cd bf       	out	0x3d, r28	; 61
    521e:	9d 83       	std	Y+5, r25	; 0x05
    5220:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5222:	8c 81       	ldd	r24, Y+4	; 0x04
    5224:	9d 81       	ldd	r25, Y+5	; 0x05
    5226:	00 97       	sbiw	r24, 0x00	; 0
    5228:	39 f4       	brne	.+14     	; 0x5238 <xTaskNotifyStateClear+0x2e>
    522a:	80 91 a8 06 	lds	r24, 0x06A8
    522e:	90 91 a9 06 	lds	r25, 0x06A9
    5232:	9f 83       	std	Y+7, r25	; 0x07
    5234:	8e 83       	std	Y+6, r24	; 0x06
    5236:	04 c0       	rjmp	.+8      	; 0x5240 <xTaskNotifyStateClear+0x36>
    5238:	8c 81       	ldd	r24, Y+4	; 0x04
    523a:	9d 81       	ldd	r25, Y+5	; 0x05
    523c:	9f 83       	std	Y+7, r25	; 0x07
    523e:	8e 83       	std	Y+6, r24	; 0x06
    5240:	8e 81       	ldd	r24, Y+6	; 0x06
    5242:	9f 81       	ldd	r25, Y+7	; 0x07
    5244:	9b 83       	std	Y+3, r25	; 0x03
    5246:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5248:	0f b6       	in	r0, 0x3f	; 63
    524a:	f8 94       	cli
    524c:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    524e:	ea 81       	ldd	r30, Y+2	; 0x02
    5250:	fb 81       	ldd	r31, Y+3	; 0x03
    5252:	85 a1       	ldd	r24, Z+37	; 0x25
    5254:	82 30       	cpi	r24, 0x02	; 2
    5256:	31 f4       	brne	.+12     	; 0x5264 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5258:	ea 81       	ldd	r30, Y+2	; 0x02
    525a:	fb 81       	ldd	r31, Y+3	; 0x03
    525c:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    525e:	81 e0       	ldi	r24, 0x01	; 1
    5260:	89 83       	std	Y+1, r24	; 0x01
    5262:	01 c0       	rjmp	.+2      	; 0x5266 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    5264:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5266:	0f 90       	pop	r0
    5268:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    526a:	89 81       	ldd	r24, Y+1	; 0x01
	}
    526c:	27 96       	adiw	r28, 0x07	; 7
    526e:	0f b6       	in	r0, 0x3f	; 63
    5270:	f8 94       	cli
    5272:	de bf       	out	0x3e, r29	; 62
    5274:	0f be       	out	0x3f, r0	; 63
    5276:	cd bf       	out	0x3d, r28	; 61
    5278:	cf 91       	pop	r28
    527a:	df 91       	pop	r29
    527c:	08 95       	ret

0000527e <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    527e:	df 93       	push	r29
    5280:	cf 93       	push	r28
    5282:	cd b7       	in	r28, 0x3d	; 61
    5284:	de b7       	in	r29, 0x3e	; 62
    5286:	27 97       	sbiw	r28, 0x07	; 7
    5288:	0f b6       	in	r0, 0x3f	; 63
    528a:	f8 94       	cli
    528c:	de bf       	out	0x3e, r29	; 62
    528e:	0f be       	out	0x3f, r0	; 63
    5290:	cd bf       	out	0x3d, r28	; 61
    5292:	9e 83       	std	Y+6, r25	; 0x06
    5294:	8d 83       	std	Y+5, r24	; 0x05
    5296:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5298:	80 91 ac 06 	lds	r24, 0x06AC
    529c:	90 91 ad 06 	lds	r25, 0x06AD
    52a0:	9a 83       	std	Y+2, r25	; 0x02
    52a2:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    52a4:	80 91 a8 06 	lds	r24, 0x06A8
    52a8:	90 91 a9 06 	lds	r25, 0x06A9
    52ac:	02 96       	adiw	r24, 0x02	; 2
    52ae:	0e 94 b3 0a 	call	0x1566	; 0x1566 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    52b2:	8d 81       	ldd	r24, Y+5	; 0x05
    52b4:	9e 81       	ldd	r25, Y+6	; 0x06
    52b6:	2f ef       	ldi	r18, 0xFF	; 255
    52b8:	8f 3f       	cpi	r24, 0xFF	; 255
    52ba:	92 07       	cpc	r25, r18
    52bc:	81 f4       	brne	.+32     	; 0x52de <prvAddCurrentTaskToDelayedList+0x60>
    52be:	8f 81       	ldd	r24, Y+7	; 0x07
    52c0:	88 23       	and	r24, r24
    52c2:	69 f0       	breq	.+26     	; 0x52de <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    52c4:	80 91 a8 06 	lds	r24, 0x06A8
    52c8:	90 91 a9 06 	lds	r25, 0x06A9
    52cc:	9c 01       	movw	r18, r24
    52ce:	2e 5f       	subi	r18, 0xFE	; 254
    52d0:	3f 4f       	sbci	r19, 0xFF	; 255
    52d2:	8e e0       	ldi	r24, 0x0E	; 14
    52d4:	97 e0       	ldi	r25, 0x07	; 7
    52d6:	b9 01       	movw	r22, r18
    52d8:	0e 94 03 0a 	call	0x1406	; 0x1406 <vListInsertEnd>
    52dc:	43 c0       	rjmp	.+134    	; 0x5364 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    52de:	29 81       	ldd	r18, Y+1	; 0x01
    52e0:	3a 81       	ldd	r19, Y+2	; 0x02
    52e2:	8d 81       	ldd	r24, Y+5	; 0x05
    52e4:	9e 81       	ldd	r25, Y+6	; 0x06
    52e6:	82 0f       	add	r24, r18
    52e8:	93 1f       	adc	r25, r19
    52ea:	9c 83       	std	Y+4, r25	; 0x04
    52ec:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    52ee:	e0 91 a8 06 	lds	r30, 0x06A8
    52f2:	f0 91 a9 06 	lds	r31, 0x06A9
    52f6:	8b 81       	ldd	r24, Y+3	; 0x03
    52f8:	9c 81       	ldd	r25, Y+4	; 0x04
    52fa:	93 83       	std	Z+3, r25	; 0x03
    52fc:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    52fe:	2b 81       	ldd	r18, Y+3	; 0x03
    5300:	3c 81       	ldd	r19, Y+4	; 0x04
    5302:	89 81       	ldd	r24, Y+1	; 0x01
    5304:	9a 81       	ldd	r25, Y+2	; 0x02
    5306:	28 17       	cp	r18, r24
    5308:	39 07       	cpc	r19, r25
    530a:	70 f4       	brcc	.+28     	; 0x5328 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    530c:	80 91 fa 06 	lds	r24, 0x06FA
    5310:	90 91 fb 06 	lds	r25, 0x06FB
    5314:	20 91 a8 06 	lds	r18, 0x06A8
    5318:	30 91 a9 06 	lds	r19, 0x06A9
    531c:	2e 5f       	subi	r18, 0xFE	; 254
    531e:	3f 4f       	sbci	r19, 0xFF	; 255
    5320:	b9 01       	movw	r22, r18
    5322:	0e 94 47 0a 	call	0x148e	; 0x148e <vListInsert>
    5326:	1e c0       	rjmp	.+60     	; 0x5364 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5328:	40 91 f8 06 	lds	r20, 0x06F8
    532c:	50 91 f9 06 	lds	r21, 0x06F9
    5330:	80 91 a8 06 	lds	r24, 0x06A8
    5334:	90 91 a9 06 	lds	r25, 0x06A9
    5338:	9c 01       	movw	r18, r24
    533a:	2e 5f       	subi	r18, 0xFE	; 254
    533c:	3f 4f       	sbci	r19, 0xFF	; 255
    533e:	ca 01       	movw	r24, r20
    5340:	b9 01       	movw	r22, r18
    5342:	0e 94 47 0a 	call	0x148e	; 0x148e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5346:	20 91 b4 06 	lds	r18, 0x06B4
    534a:	30 91 b5 06 	lds	r19, 0x06B5
    534e:	8b 81       	ldd	r24, Y+3	; 0x03
    5350:	9c 81       	ldd	r25, Y+4	; 0x04
    5352:	82 17       	cp	r24, r18
    5354:	93 07       	cpc	r25, r19
    5356:	30 f4       	brcc	.+12     	; 0x5364 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5358:	8b 81       	ldd	r24, Y+3	; 0x03
    535a:	9c 81       	ldd	r25, Y+4	; 0x04
    535c:	90 93 b5 06 	sts	0x06B5, r25
    5360:	80 93 b4 06 	sts	0x06B4, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5364:	27 96       	adiw	r28, 0x07	; 7
    5366:	0f b6       	in	r0, 0x3f	; 63
    5368:	f8 94       	cli
    536a:	de bf       	out	0x3e, r29	; 62
    536c:	0f be       	out	0x3f, r0	; 63
    536e:	cd bf       	out	0x3d, r28	; 61
    5370:	cf 91       	pop	r28
    5372:	df 91       	pop	r29
    5374:	08 95       	ret

00005376 <memcpy>:
    5376:	fb 01       	movw	r30, r22
    5378:	dc 01       	movw	r26, r24
    537a:	02 c0       	rjmp	.+4      	; 0x5380 <memcpy+0xa>
    537c:	01 90       	ld	r0, Z+
    537e:	0d 92       	st	X+, r0
    5380:	41 50       	subi	r20, 0x01	; 1
    5382:	50 40       	sbci	r21, 0x00	; 0
    5384:	d8 f7       	brcc	.-10     	; 0x537c <memcpy+0x6>
    5386:	08 95       	ret

00005388 <memset>:
    5388:	dc 01       	movw	r26, r24
    538a:	01 c0       	rjmp	.+2      	; 0x538e <memset+0x6>
    538c:	6d 93       	st	X+, r22
    538e:	41 50       	subi	r20, 0x01	; 1
    5390:	50 40       	sbci	r21, 0x00	; 0
    5392:	e0 f7       	brcc	.-8      	; 0x538c <memset+0x4>
    5394:	08 95       	ret

00005396 <_exit>:
    5396:	f8 94       	cli

00005398 <__stop_program>:
    5398:	ff cf       	rjmp	.-2      	; 0x5398 <__stop_program>
