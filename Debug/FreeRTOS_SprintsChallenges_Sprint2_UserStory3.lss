
FreeRTOS_SprintsChallenges_Sprint2_UserStory3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005c4e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000086  00800060  00005c4e  00005ce2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000066b  008000e6  008000e6  00005d68  2**0
                  ALLOC
  3 .stab         00009588  00000000  00000000  00005d68  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004c85  00000000  00000000  0000f2f0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 c9 0f 	jmp	0x1f92	; 0x1f92 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e4       	ldi	r30, 0x4E	; 78
      68:	fc e5       	ldi	r31, 0x5C	; 92
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3e       	cpi	r26, 0xE6	; 230
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a6 ee       	ldi	r26, 0xE6	; 230
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 35       	cpi	r26, 0x51	; 81
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <main>
      8a:	0c 94 25 2e 	jmp	0x5c4a	; 0x5c4a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <PushButton_Init>:
 * Outputs:         NULL
 *
 * Return:          NULL
 *******************************************************************************/
void PushButton_Init(void)
{
     532:	df 93       	push	r29
     534:	cf 93       	push	r28
     536:	cd b7       	in	r28, 0x3d	; 61
     538:	de b7       	in	r29, 0x3e	; 62
    /*set Pins Of Push Button*/
    DIO_SetPinDirection(DIO_PIN10 , INPUT);
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	60 e0       	ldi	r22, 0x00	; 0
     53e:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
    DIO_SetPinDirection(DIO_PIN20 , INPUT);
     542:	84 e1       	ldi	r24, 0x14	; 20
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>


}
     54a:	cf 91       	pop	r28
     54c:	df 91       	pop	r29
     54e:	08 95       	ret

00000550 <Buttons_getPressedButton>:
 * Outputs:         NULL
 *
 * Return:          pressed Push Button (uint8_t)
 *******************************************************************************/
uint8 Buttons_getPressedButton(void)
{
     550:	df 93       	push	r29
     552:	cf 93       	push	r28
     554:	0f 92       	push	r0
     556:	cd b7       	in	r28, 0x3d	; 61
     558:	de b7       	in	r29, 0x3e	; 62
    /*return value*/
    uint8 ReturnVal=10;
     55a:	8a e0       	ldi	r24, 0x0A	; 10
     55c:	89 83       	std	Y+1, r24	; 0x01


    /*Loop to check if button is pressed to return its value*/

    if(DIO_ReadPin(DIO_PIN10) == 1)
     55e:	8a e0       	ldi	r24, 0x0A	; 10
     560:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     564:	81 30       	cpi	r24, 0x01	; 1
     566:	19 f4       	brne	.+6      	; 0x56e <Buttons_getPressedButton+0x1e>
    {
        ReturnVal = 2;
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	89 83       	std	Y+1, r24	; 0x01
     56c:	07 c0       	rjmp	.+14     	; 0x57c <Buttons_getPressedButton+0x2c>
    }
    else if(DIO_ReadPin(DIO_PIN20) == 1)
     56e:	84 e1       	ldi	r24, 0x14	; 20
     570:	0e 94 38 01 	call	0x270	; 0x270 <DIO_ReadPin>
     574:	81 30       	cpi	r24, 0x01	; 1
     576:	11 f4       	brne	.+4      	; 0x57c <Buttons_getPressedButton+0x2c>
    {
        ReturnVal = 1;
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	89 83       	std	Y+1, r24	; 0x01
    }
    else
    {
        /*Do Nothing*/
    }
    return ReturnVal;
     57c:	89 81       	ldd	r24, Y+1	; 0x01
}
     57e:	0f 90       	pop	r0
     580:	cf 91       	pop	r28
     582:	df 91       	pop	r29
     584:	08 95       	ret

00000586 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	0f 93       	push	r16
     58c:	df 93       	push	r29
     58e:	cf 93       	push	r28
     590:	00 d0       	rcall	.+0      	; 0x592 <init_Task+0xc>
     592:	cd b7       	in	r28, 0x3d	; 61
     594:	de b7       	in	r29, 0x3e	; 62
     596:	9a 83       	std	Y+2, r25	; 0x02
     598:	89 83       	std	Y+1, r24	; 0x01
	/*Create Queues*/
	Queue_PushButton_A = xQueueCreate( 3 , sizeof(uint8) );
     59a:	83 e0       	ldi	r24, 0x03	; 3
     59c:	61 e0       	ldi	r22, 0x01	; 1
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	0e 94 52 10 	call	0x20a4	; 0x20a4 <xQueueGenericCreate>
     5a4:	90 93 eb 00 	sts	0x00EB, r25
     5a8:	80 93 ea 00 	sts	0x00EA, r24
	Queue_PushButton_B = xQueueCreate( 3 , sizeof(uint8) );
     5ac:	83 e0       	ldi	r24, 0x03	; 3
     5ae:	61 e0       	ldi	r22, 0x01	; 1
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	0e 94 52 10 	call	0x20a4	; 0x20a4 <xQueueGenericCreate>
     5b6:	90 93 ed 00 	sts	0x00ED, r25
     5ba:	80 93 ec 00 	sts	0x00EC, r24

	/*Create Mutex to make one Push Button is pressed*/
	FirstButtonPressed = xSemaphoreCreateMutex();
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	0e 94 02 11 	call	0x2204	; 0x2204 <xQueueCreateMutex>
     5c4:	90 93 50 07 	sts	0x0750, r25
     5c8:	80 93 4f 07 	sts	0x074F, r24



	/*Create 4 Tasks*/
	/*Task for initialize Hardware components*/
	xTaskCreate(All_Hardware_Init_Task  , "InitTasks" , configMINIMAL_STACK_SIZE ,
     5cc:	8d e2       	ldi	r24, 0x2D	; 45
     5ce:	93 e0       	ldi	r25, 0x03	; 3
     5d0:	20 e6       	ldi	r18, 0x60	; 96
     5d2:	30 e0       	ldi	r19, 0x00	; 0
     5d4:	e6 ee       	ldi	r30, 0xE6	; 230
     5d6:	f0 e0       	ldi	r31, 0x00	; 0
     5d8:	b9 01       	movw	r22, r18
     5da:	46 e9       	ldi	r20, 0x96	; 150
     5dc:	50 e0       	ldi	r21, 0x00	; 0
     5de:	20 e0       	ldi	r18, 0x00	; 0
     5e0:	30 e0       	ldi	r19, 0x00	; 0
     5e2:	06 e0       	ldi	r16, 0x06	; 6
     5e4:	7f 01       	movw	r14, r30
     5e6:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <xTaskCreate>
			NULL , (6 | portPRIVILEGE_BIT) , &AllHardwareInit_Flag);

	/*Task of Push Button 1*/
	xTaskCreate(PushButtonA_Task  , "PushButtonA_Task" , configMINIMAL_STACK_SIZE ,
     5ea:	83 e4       	ldi	r24, 0x43	; 67
     5ec:	93 e0       	ldi	r25, 0x03	; 3
     5ee:	2a e6       	ldi	r18, 0x6A	; 106
     5f0:	30 e0       	ldi	r19, 0x00	; 0
     5f2:	b9 01       	movw	r22, r18
     5f4:	46 e9       	ldi	r20, 0x96	; 150
     5f6:	50 e0       	ldi	r21, 0x00	; 0
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	30 e0       	ldi	r19, 0x00	; 0
     5fc:	04 e0       	ldi	r16, 0x04	; 4
     5fe:	ee 24       	eor	r14, r14
     600:	ff 24       	eor	r15, r15
     602:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , NULL);

	/*Task of Push Button 2*/
	xTaskCreate(PushButtonB_Task  , "PushButtonB_Task" , configMINIMAL_STACK_SIZE ,
     606:	8a ec       	ldi	r24, 0xCA	; 202
     608:	93 e0       	ldi	r25, 0x03	; 3
     60a:	2b e7       	ldi	r18, 0x7B	; 123
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	b9 01       	movw	r22, r18
     610:	46 e9       	ldi	r20, 0x96	; 150
     612:	50 e0       	ldi	r21, 0x00	; 0
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	03 e0       	ldi	r16, 0x03	; 3
     61a:	ee 24       	eor	r14, r14
     61c:	ff 24       	eor	r15, r15
     61e:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , NULL);

	/*Task for LCD*/
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE ,
     622:	81 e5       	ldi	r24, 0x51	; 81
     624:	94 e0       	ldi	r25, 0x04	; 4
     626:	2c e8       	ldi	r18, 0x8C	; 140
     628:	30 e0       	ldi	r19, 0x00	; 0
     62a:	b9 01       	movw	r22, r18
     62c:	46 e9       	ldi	r20, 0x96	; 150
     62e:	50 e0       	ldi	r21, 0x00	; 0
     630:	20 e0       	ldi	r18, 0x00	; 0
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	02 e0       	ldi	r16, 0x02	; 2
     636:	ee 24       	eor	r14, r14
     638:	ff 24       	eor	r15, r15
     63a:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);

	/*Suspend this task from the system*/
	vTaskSuspend( InitTask_Flag);
     63e:	80 91 e8 00 	lds	r24, 0x00E8
     642:	90 91 e9 00 	lds	r25, 0x00E9
     646:	0e 94 73 21 	call	0x42e6	; 0x42e6 <vTaskSuspend>
}
     64a:	0f 90       	pop	r0
     64c:	0f 90       	pop	r0
     64e:	cf 91       	pop	r28
     650:	df 91       	pop	r29
     652:	0f 91       	pop	r16
     654:	ff 90       	pop	r15
     656:	ef 90       	pop	r14
     658:	08 95       	ret

0000065a <All_Hardware_Init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void All_Hardware_Init_Task(void * a_Task_ptr)
{
     65a:	df 93       	push	r29
     65c:	cf 93       	push	r28
     65e:	00 d0       	rcall	.+0      	; 0x660 <All_Hardware_Init_Task+0x6>
     660:	cd b7       	in	r28, 0x3d	; 61
     662:	de b7       	in	r29, 0x3e	; 62
     664:	9a 83       	std	Y+2, r25	; 0x02
     666:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		/*initialize Hardware components*/
		PushButton_Init();
     668:	0e 94 99 02 	call	0x532	; 0x532 <PushButton_Init>
		LCD_init();
     66c:	0e 94 1c 0a 	call	0x1438	; 0x1438 <LCD_init>
		DIO_SetPinDirection(DIO_PIN13,OUTPUT);
     670:	8d e0       	ldi	r24, 0x0D	; 13
     672:	61 e0       	ldi	r22, 0x01	; 1
     674:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>

		/*Suspend this task from the system*/
		vTaskSuspend( AllHardwareInit_Flag);
     678:	80 91 e6 00 	lds	r24, 0x00E6
     67c:	90 91 e7 00 	lds	r25, 0x00E7
     680:	0e 94 73 21 	call	0x42e6	; 0x42e6 <vTaskSuspend>
     684:	f1 cf       	rjmp	.-30     	; 0x668 <All_Hardware_Init_Task+0xe>

00000686 <PushButtonA_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButtonA_Task(void * a_Task_ptr)
{
     686:	df 93       	push	r29
     688:	cf 93       	push	r28
     68a:	00 d0       	rcall	.+0      	; 0x68c <PushButtonA_Task+0x6>
     68c:	00 d0       	rcall	.+0      	; 0x68e <PushButtonA_Task+0x8>
     68e:	0f 92       	push	r0
     690:	cd b7       	in	r28, 0x3d	; 61
     692:	de b7       	in	r29, 0x3e	; 62
     694:	9d 83       	std	Y+5, r25	; 0x05
     696:	8c 83       	std	Y+4, r24	; 0x04
	vTaskDelay(50);
     698:	82 e3       	ldi	r24, 0x32	; 50
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     6a0:	81 e0       	ldi	r24, 0x01	; 1
     6a2:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     6a4:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     6a6:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==2)
     6a8:	8a 81       	ldd	r24, Y+2	; 0x02
     6aa:	88 23       	and	r24, r24
     6ac:	79 f4       	brne	.+30     	; 0x6cc <PushButtonA_Task+0x46>
     6ae:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6b2:	82 30       	cpi	r24, 0x02	; 2
     6b4:	59 f4       	brne	.+22     	; 0x6cc <PushButtonA_Task+0x46>
		{
			OldPressedValue =  Buttons_getPressedButton();
     6b6:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     6ba:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     6bc:	8a 81       	ldd	r24, Y+2	; 0x02
     6be:	8f 5f       	subi	r24, 0xFF	; 255
     6c0:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     6c2:	8a e0       	ldi	r24, 0x0A	; 10
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     6ca:	ee cf       	rjmp	.-36     	; 0x6a8 <PushButtonA_Task+0x22>
		}
		else if(Debouncing == 1)
     6cc:	8a 81       	ldd	r24, Y+2	; 0x02
     6ce:	81 30       	cpi	r24, 0x01	; 1
     6d0:	59 f5       	brne	.+86     	; 0x728 <PushButtonA_Task+0xa2>
     6d2:	1d c0       	rjmp	.+58     	; 0x70e <PushButtonA_Task+0x88>
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{
				/*Check if other push Button is pressed and if not take Mutex*/
				if (xSemaphoreTake(FirstButtonPressed , 10))
     6d4:	80 91 4f 07 	lds	r24, 0x074F
     6d8:	90 91 50 07 	lds	r25, 0x0750
     6dc:	6a e0       	ldi	r22, 0x0A	; 10
     6de:	70 e0       	ldi	r23, 0x00	; 0
     6e0:	0e 94 22 13 	call	0x2644	; 0x2644 <xQueueSemaphoreTake>
     6e4:	88 23       	and	r24, r24
     6e6:	99 f0       	breq	.+38     	; 0x70e <PushButtonA_Task+0x88>
				{
					SendData = 1;
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	8b 83       	std	Y+3, r24	; 0x03
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_A , &SendData , 100);
     6ec:	80 91 ea 00 	lds	r24, 0x00EA
     6f0:	90 91 eb 00 	lds	r25, 0x00EB
     6f4:	9e 01       	movw	r18, r28
     6f6:	2d 5f       	subi	r18, 0xFD	; 253
     6f8:	3f 4f       	sbci	r19, 0xFF	; 255
     6fa:	b9 01       	movw	r22, r18
     6fc:	44 e6       	ldi	r20, 0x64	; 100
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	20 e0       	ldi	r18, 0x00	; 0
     702:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
					vTaskDelay(20);
     706:	84 e1       	ldi	r24, 0x14	; 20
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
			vTaskDelay(10);
		}
		else if(Debouncing == 1)
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
     70e:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     712:	98 2f       	mov	r25, r24
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	98 17       	cp	r25, r24
     718:	e9 f2       	breq	.-70     	; 0x6d4 <PushButtonA_Task+0x4e>
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_A , &SendData , 100);
					vTaskDelay(20);
				}
			}
			Debouncing = 2;
     71a:	82 e0       	ldi	r24, 0x02	; 2
     71c:	8a 83       	std	Y+2, r24	; 0x02
			vTaskDelay(20);
     71e:	84 e1       	ldi	r24, 0x14	; 20
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     726:	c0 cf       	rjmp	.-128    	; 0x6a8 <PushButtonA_Task+0x22>
		}
		/*chech if button is released*/
		else if(Debouncing == 2)
     728:	8a 81       	ldd	r24, Y+2	; 0x02
     72a:	82 30       	cpi	r24, 0x02	; 2
     72c:	f9 f4       	brne	.+62     	; 0x76c <PushButtonA_Task+0xe6>
		{
			/*released Mutex*/
			xSemaphoreGive(FirstButtonPressed);
     72e:	80 91 4f 07 	lds	r24, 0x074F
     732:	90 91 50 07 	lds	r25, 0x0750
     736:	60 e0       	ldi	r22, 0x00	; 0
     738:	70 e0       	ldi	r23, 0x00	; 0
     73a:	40 e0       	ldi	r20, 0x00	; 0
     73c:	50 e0       	ldi	r21, 0x00	; 0
     73e:	20 e0       	ldi	r18, 0x00	; 0
     740:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
			SendData = 0;
     744:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(Queue_PushButton_A , &SendData , 100);
     746:	80 91 ea 00 	lds	r24, 0x00EA
     74a:	90 91 eb 00 	lds	r25, 0x00EB
     74e:	9e 01       	movw	r18, r28
     750:	2d 5f       	subi	r18, 0xFD	; 253
     752:	3f 4f       	sbci	r19, 0xFF	; 255
     754:	b9 01       	movw	r22, r18
     756:	44 e6       	ldi	r20, 0x64	; 100
     758:	50 e0       	ldi	r21, 0x00	; 0
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
			Debouncing = 0;
     760:	1a 82       	std	Y+2, r1	; 0x02
			vTaskDelay(20);
     762:	84 e1       	ldi	r24, 0x14	; 20
     764:	90 e0       	ldi	r25, 0x00	; 0
     766:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     76a:	9e cf       	rjmp	.-196    	; 0x6a8 <PushButtonA_Task+0x22>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     76c:	83 e0       	ldi	r24, 0x03	; 3
     76e:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(Queue_PushButton_A , &SendData , 100);
     770:	80 91 ea 00 	lds	r24, 0x00EA
     774:	90 91 eb 00 	lds	r25, 0x00EB
     778:	9e 01       	movw	r18, r28
     77a:	2d 5f       	subi	r18, 0xFD	; 253
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	44 e6       	ldi	r20, 0x64	; 100
     782:	50 e0       	ldi	r21, 0x00	; 0
     784:	20 e0       	ldi	r18, 0x00	; 0
     786:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
			vTaskDelay(20);
     78a:	84 e1       	ldi	r24, 0x14	; 20
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     792:	8a cf       	rjmp	.-236    	; 0x6a8 <PushButtonA_Task+0x22>

00000794 <PushButtonB_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void PushButtonB_Task(void * a_Task_ptr)
{
     794:	df 93       	push	r29
     796:	cf 93       	push	r28
     798:	00 d0       	rcall	.+0      	; 0x79a <PushButtonB_Task+0x6>
     79a:	00 d0       	rcall	.+0      	; 0x79c <PushButtonB_Task+0x8>
     79c:	0f 92       	push	r0
     79e:	cd b7       	in	r28, 0x3d	; 61
     7a0:	de b7       	in	r29, 0x3e	; 62
     7a2:	9d 83       	std	Y+5, r25	; 0x05
     7a4:	8c 83       	std	Y+4, r24	; 0x04
	vTaskDelay(60);
     7a6:	8c e3       	ldi	r24, 0x3C	; 60
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	/* Data is sent to LCD by Queue*/
	uint8 SendData = 1;
     7ae:	81 e0       	ldi	r24, 0x01	; 1
     7b0:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     7b2:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     7b4:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		/*Check if Button is pressed and enable de_bouncing*/
		if(Debouncing == 0 && Buttons_getPressedButton()==1)
     7b6:	8a 81       	ldd	r24, Y+2	; 0x02
     7b8:	88 23       	and	r24, r24
     7ba:	79 f4       	brne	.+30     	; 0x7da <PushButtonB_Task+0x46>
     7bc:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     7c0:	81 30       	cpi	r24, 0x01	; 1
     7c2:	59 f4       	brne	.+22     	; 0x7da <PushButtonB_Task+0x46>
		{
			OldPressedValue =  Buttons_getPressedButton();
     7c4:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     7c8:	89 83       	std	Y+1, r24	; 0x01
			Debouncing++;
     7ca:	8a 81       	ldd	r24, Y+2	; 0x02
     7cc:	8f 5f       	subi	r24, 0xFF	; 255
     7ce:	8a 83       	std	Y+2, r24	; 0x02
			/*de_bouncing Delay*/
			vTaskDelay(10);
     7d0:	8a e0       	ldi	r24, 0x0A	; 10
     7d2:	90 e0       	ldi	r25, 0x00	; 0
     7d4:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     7d8:	ee cf       	rjmp	.-36     	; 0x7b6 <PushButtonB_Task+0x22>
		}
		else if(Debouncing == 1)
     7da:	8a 81       	ldd	r24, Y+2	; 0x02
     7dc:	81 30       	cpi	r24, 0x01	; 1
     7de:	59 f5       	brne	.+86     	; 0x836 <PushButtonB_Task+0xa2>
     7e0:	1d c0       	rjmp	.+58     	; 0x81c <PushButtonB_Task+0x88>
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
			{
				/*Check if other push Button is pressed and if not take Mutex*/
				if (xSemaphoreTake(FirstButtonPressed , 10))
     7e2:	80 91 4f 07 	lds	r24, 0x074F
     7e6:	90 91 50 07 	lds	r25, 0x0750
     7ea:	6a e0       	ldi	r22, 0x0A	; 10
     7ec:	70 e0       	ldi	r23, 0x00	; 0
     7ee:	0e 94 22 13 	call	0x2644	; 0x2644 <xQueueSemaphoreTake>
     7f2:	88 23       	and	r24, r24
     7f4:	99 f0       	breq	.+38     	; 0x81c <PushButtonB_Task+0x88>
				{
					SendData = 1;
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	8b 83       	std	Y+3, r24	; 0x03
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_B , &SendData , 100);
     7fa:	80 91 ec 00 	lds	r24, 0x00EC
     7fe:	90 91 ed 00 	lds	r25, 0x00ED
     802:	9e 01       	movw	r18, r28
     804:	2d 5f       	subi	r18, 0xFD	; 253
     806:	3f 4f       	sbci	r19, 0xFF	; 255
     808:	b9 01       	movw	r22, r18
     80a:	44 e6       	ldi	r20, 0x64	; 100
     80c:	50 e0       	ldi	r21, 0x00	; 0
     80e:	20 e0       	ldi	r18, 0x00	; 0
     810:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
					vTaskDelay(20);
     814:	84 e1       	ldi	r24, 0x14	; 20
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
			vTaskDelay(10);
		}
		else if(Debouncing == 1)
		{
			/*check if button is still pressed after de_bouncing time*/
			while(OldPressedValue == Buttons_getPressedButton())
     81c:	0e 94 a8 02 	call	0x550	; 0x550 <Buttons_getPressedButton>
     820:	98 2f       	mov	r25, r24
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	98 17       	cp	r25, r24
     826:	e9 f2       	breq	.-70     	; 0x7e2 <PushButtonB_Task+0x4e>
					/*Send push Button was pressed to Lcd by queue*/
					xQueueSend(Queue_PushButton_B , &SendData , 100);
					vTaskDelay(20);
				}
			}
			Debouncing = 2;
     828:	82 e0       	ldi	r24, 0x02	; 2
     82a:	8a 83       	std	Y+2, r24	; 0x02
			vTaskDelay(20);
     82c:	84 e1       	ldi	r24, 0x14	; 20
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     834:	c0 cf       	rjmp	.-128    	; 0x7b6 <PushButtonB_Task+0x22>
		}
		/*chech if button is released*/
		else if(Debouncing == 2)
     836:	8a 81       	ldd	r24, Y+2	; 0x02
     838:	82 30       	cpi	r24, 0x02	; 2
     83a:	f9 f4       	brne	.+62     	; 0x87a <__stack+0x1b>
		{
			/*released Mutex*/
			xSemaphoreGive(FirstButtonPressed);
     83c:	80 91 4f 07 	lds	r24, 0x074F
     840:	90 91 50 07 	lds	r25, 0x0750
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	70 e0       	ldi	r23, 0x00	; 0
     848:	40 e0       	ldi	r20, 0x00	; 0
     84a:	50 e0       	ldi	r21, 0x00	; 0
     84c:	20 e0       	ldi	r18, 0x00	; 0
     84e:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
			SendData = 0;
     852:	1b 82       	std	Y+3, r1	; 0x03
			/*Send push Button was released to Lcd by queue*/
			xQueueSend(Queue_PushButton_B , &SendData , 100);
     854:	80 91 ec 00 	lds	r24, 0x00EC
     858:	90 91 ed 00 	lds	r25, 0x00ED
     85c:	9e 01       	movw	r18, r28
     85e:	2d 5f       	subi	r18, 0xFD	; 253
     860:	3f 4f       	sbci	r19, 0xFF	; 255
     862:	b9 01       	movw	r22, r18
     864:	44 e6       	ldi	r20, 0x64	; 100
     866:	50 e0       	ldi	r21, 0x00	; 0
     868:	20 e0       	ldi	r18, 0x00	; 0
     86a:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
			Debouncing = 0;
     86e:	1a 82       	std	Y+2, r1	; 0x02
			vTaskDelay(20);
     870:	84 e1       	ldi	r24, 0x14	; 20
     872:	90 e0       	ldi	r25, 0x00	; 0
     874:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     878:	9e cf       	rjmp	.-196    	; 0x7b6 <PushButtonB_Task+0x22>
		}
		else
		{
			/*Send push Button is in Idle state to Lcd by queue*/
			SendData = 3;
     87a:	83 e0       	ldi	r24, 0x03	; 3
     87c:	8b 83       	std	Y+3, r24	; 0x03
			xQueueSend(Queue_PushButton_B , &SendData , 100);
     87e:	80 91 ec 00 	lds	r24, 0x00EC
     882:	90 91 ed 00 	lds	r25, 0x00ED
     886:	9e 01       	movw	r18, r28
     888:	2d 5f       	subi	r18, 0xFD	; 253
     88a:	3f 4f       	sbci	r19, 0xFF	; 255
     88c:	b9 01       	movw	r22, r18
     88e:	44 e6       	ldi	r20, 0x64	; 100
     890:	50 e0       	ldi	r21, 0x00	; 0
     892:	20 e0       	ldi	r18, 0x00	; 0
     894:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
			vTaskDelay(20);
     898:	84 e1       	ldi	r24, 0x14	; 20
     89a:	90 e0       	ldi	r25, 0x00	; 0
     89c:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     8a0:	8a cf       	rjmp	.-236    	; 0x7b6 <PushButtonB_Task+0x22>

000008a2 <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     8a2:	df 93       	push	r29
     8a4:	cf 93       	push	r28
     8a6:	cd b7       	in	r28, 0x3d	; 61
     8a8:	de b7       	in	r29, 0x3e	; 62
     8aa:	c2 56       	subi	r28, 0x62	; 98
     8ac:	d0 40       	sbci	r29, 0x00	; 0
     8ae:	0f b6       	in	r0, 0x3f	; 63
     8b0:	f8 94       	cli
     8b2:	de bf       	out	0x3e, r29	; 62
     8b4:	0f be       	out	0x3f, r0	; 63
     8b6:	cd bf       	out	0x3d, r28	; 61
     8b8:	fe 01       	movw	r30, r28
     8ba:	e8 5b       	subi	r30, 0xB8	; 184
     8bc:	ff 4f       	sbci	r31, 0xFF	; 255
     8be:	91 83       	std	Z+1, r25	; 0x01
     8c0:	80 83       	st	Z, r24

	vTaskDelay(100);
     8c2:	84 e6       	ldi	r24, 0x64	; 100
     8c4:	90 e0       	ldi	r25, 0x00	; 0
     8c6:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	/*received data from Push Button A Task to display button state on LCD*/
	uint8 PushButton_A_Task_Data = 0;
     8ca:	1c 82       	std	Y+4, r1	; 0x04

	/*received message from PushButton_B Task to display button state on LCD*/
	uint8 PushButton_B_Task_Data = 0;
     8cc:	1d 82       	std	Y+5, r1	; 0x05

	/*Synchronize between displaying of Push Button task and hello task*/
	uint8 Flag = 0;
     8ce:	1b 82       	std	Y+3, r1	; 0x03
	uint8 PlayerOne = 0;
     8d0:	1a 82       	std	Y+2, r1	; 0x02
	uint8 PlayerTwo = 0;
     8d2:	19 82       	std	Y+1, r1	; 0x01

	/*LED States & Buttons Strings*/
	uint8 ButtonA[] = "Player One ";
     8d4:	ce 01       	movw	r24, r28
     8d6:	06 96       	adiw	r24, 0x06	; 6
     8d8:	2c 96       	adiw	r28, 0x0c	; 12
     8da:	9f af       	std	Y+63, r25	; 0x3f
     8dc:	8e af       	std	Y+62, r24	; 0x3e
     8de:	2c 97       	sbiw	r28, 0x0c	; 12
     8e0:	e5 e9       	ldi	r30, 0x95	; 149
     8e2:	f0 e0       	ldi	r31, 0x00	; 0
     8e4:	2e 96       	adiw	r28, 0x0e	; 14
     8e6:	ff af       	std	Y+63, r31	; 0x3f
     8e8:	ee af       	std	Y+62, r30	; 0x3e
     8ea:	2e 97       	sbiw	r28, 0x0e	; 14
     8ec:	fc e0       	ldi	r31, 0x0C	; 12
     8ee:	2f 96       	adiw	r28, 0x0f	; 15
     8f0:	ff af       	std	Y+63, r31	; 0x3f
     8f2:	2f 97       	sbiw	r28, 0x0f	; 15
     8f4:	2e 96       	adiw	r28, 0x0e	; 14
     8f6:	ee ad       	ldd	r30, Y+62	; 0x3e
     8f8:	ff ad       	ldd	r31, Y+63	; 0x3f
     8fa:	2e 97       	sbiw	r28, 0x0e	; 14
     8fc:	00 80       	ld	r0, Z
     8fe:	2e 96       	adiw	r28, 0x0e	; 14
     900:	8e ad       	ldd	r24, Y+62	; 0x3e
     902:	9f ad       	ldd	r25, Y+63	; 0x3f
     904:	2e 97       	sbiw	r28, 0x0e	; 14
     906:	01 96       	adiw	r24, 0x01	; 1
     908:	2e 96       	adiw	r28, 0x0e	; 14
     90a:	9f af       	std	Y+63, r25	; 0x3f
     90c:	8e af       	std	Y+62, r24	; 0x3e
     90e:	2e 97       	sbiw	r28, 0x0e	; 14
     910:	2c 96       	adiw	r28, 0x0c	; 12
     912:	ee ad       	ldd	r30, Y+62	; 0x3e
     914:	ff ad       	ldd	r31, Y+63	; 0x3f
     916:	2c 97       	sbiw	r28, 0x0c	; 12
     918:	00 82       	st	Z, r0
     91a:	2c 96       	adiw	r28, 0x0c	; 12
     91c:	8e ad       	ldd	r24, Y+62	; 0x3e
     91e:	9f ad       	ldd	r25, Y+63	; 0x3f
     920:	2c 97       	sbiw	r28, 0x0c	; 12
     922:	01 96       	adiw	r24, 0x01	; 1
     924:	2c 96       	adiw	r28, 0x0c	; 12
     926:	9f af       	std	Y+63, r25	; 0x3f
     928:	8e af       	std	Y+62, r24	; 0x3e
     92a:	2c 97       	sbiw	r28, 0x0c	; 12
     92c:	2f 96       	adiw	r28, 0x0f	; 15
     92e:	9f ad       	ldd	r25, Y+63	; 0x3f
     930:	2f 97       	sbiw	r28, 0x0f	; 15
     932:	91 50       	subi	r25, 0x01	; 1
     934:	2f 96       	adiw	r28, 0x0f	; 15
     936:	9f af       	std	Y+63, r25	; 0x3f
     938:	2f 97       	sbiw	r28, 0x0f	; 15
     93a:	2f 96       	adiw	r28, 0x0f	; 15
     93c:	ef ad       	ldd	r30, Y+63	; 0x3f
     93e:	2f 97       	sbiw	r28, 0x0f	; 15
     940:	ee 23       	and	r30, r30
     942:	c1 f6       	brne	.-80     	; 0x8f4 <LCD_Task+0x52>
	uint8 ButtonB[] = "Player Two ";
     944:	ce 01       	movw	r24, r28
     946:	42 96       	adiw	r24, 0x12	; 18
     948:	61 96       	adiw	r28, 0x11	; 17
     94a:	9f af       	std	Y+63, r25	; 0x3f
     94c:	8e af       	std	Y+62, r24	; 0x3e
     94e:	61 97       	sbiw	r28, 0x11	; 17
     950:	e1 ea       	ldi	r30, 0xA1	; 161
     952:	f0 e0       	ldi	r31, 0x00	; 0
     954:	63 96       	adiw	r28, 0x13	; 19
     956:	ff af       	std	Y+63, r31	; 0x3f
     958:	ee af       	std	Y+62, r30	; 0x3e
     95a:	63 97       	sbiw	r28, 0x13	; 19
     95c:	fc e0       	ldi	r31, 0x0C	; 12
     95e:	64 96       	adiw	r28, 0x14	; 20
     960:	ff af       	std	Y+63, r31	; 0x3f
     962:	64 97       	sbiw	r28, 0x14	; 20
     964:	63 96       	adiw	r28, 0x13	; 19
     966:	ee ad       	ldd	r30, Y+62	; 0x3e
     968:	ff ad       	ldd	r31, Y+63	; 0x3f
     96a:	63 97       	sbiw	r28, 0x13	; 19
     96c:	00 80       	ld	r0, Z
     96e:	63 96       	adiw	r28, 0x13	; 19
     970:	8e ad       	ldd	r24, Y+62	; 0x3e
     972:	9f ad       	ldd	r25, Y+63	; 0x3f
     974:	63 97       	sbiw	r28, 0x13	; 19
     976:	01 96       	adiw	r24, 0x01	; 1
     978:	63 96       	adiw	r28, 0x13	; 19
     97a:	9f af       	std	Y+63, r25	; 0x3f
     97c:	8e af       	std	Y+62, r24	; 0x3e
     97e:	63 97       	sbiw	r28, 0x13	; 19
     980:	61 96       	adiw	r28, 0x11	; 17
     982:	ee ad       	ldd	r30, Y+62	; 0x3e
     984:	ff ad       	ldd	r31, Y+63	; 0x3f
     986:	61 97       	sbiw	r28, 0x11	; 17
     988:	00 82       	st	Z, r0
     98a:	61 96       	adiw	r28, 0x11	; 17
     98c:	8e ad       	ldd	r24, Y+62	; 0x3e
     98e:	9f ad       	ldd	r25, Y+63	; 0x3f
     990:	61 97       	sbiw	r28, 0x11	; 17
     992:	01 96       	adiw	r24, 0x01	; 1
     994:	61 96       	adiw	r28, 0x11	; 17
     996:	9f af       	std	Y+63, r25	; 0x3f
     998:	8e af       	std	Y+62, r24	; 0x3e
     99a:	61 97       	sbiw	r28, 0x11	; 17
     99c:	64 96       	adiw	r28, 0x14	; 20
     99e:	9f ad       	ldd	r25, Y+63	; 0x3f
     9a0:	64 97       	sbiw	r28, 0x14	; 20
     9a2:	91 50       	subi	r25, 0x01	; 1
     9a4:	64 96       	adiw	r28, 0x14	; 20
     9a6:	9f af       	std	Y+63, r25	; 0x3f
     9a8:	64 97       	sbiw	r28, 0x14	; 20
     9aa:	64 96       	adiw	r28, 0x14	; 20
     9ac:	ef ad       	ldd	r30, Y+63	; 0x3f
     9ae:	64 97       	sbiw	r28, 0x14	; 20
     9b0:	ee 23       	and	r30, r30
     9b2:	c1 f6       	brne	.-80     	; 0x964 <LCD_Task+0xc2>
	uint8 Player1_Win_Message[] = "Player 1 Won";
     9b4:	ce 01       	movw	r24, r28
     9b6:	4e 96       	adiw	r24, 0x1e	; 30
     9b8:	66 96       	adiw	r28, 0x16	; 22
     9ba:	9f af       	std	Y+63, r25	; 0x3f
     9bc:	8e af       	std	Y+62, r24	; 0x3e
     9be:	66 97       	sbiw	r28, 0x16	; 22
     9c0:	ed ea       	ldi	r30, 0xAD	; 173
     9c2:	f0 e0       	ldi	r31, 0x00	; 0
     9c4:	68 96       	adiw	r28, 0x18	; 24
     9c6:	ff af       	std	Y+63, r31	; 0x3f
     9c8:	ee af       	std	Y+62, r30	; 0x3e
     9ca:	68 97       	sbiw	r28, 0x18	; 24
     9cc:	fd e0       	ldi	r31, 0x0D	; 13
     9ce:	69 96       	adiw	r28, 0x19	; 25
     9d0:	ff af       	std	Y+63, r31	; 0x3f
     9d2:	69 97       	sbiw	r28, 0x19	; 25
     9d4:	68 96       	adiw	r28, 0x18	; 24
     9d6:	ee ad       	ldd	r30, Y+62	; 0x3e
     9d8:	ff ad       	ldd	r31, Y+63	; 0x3f
     9da:	68 97       	sbiw	r28, 0x18	; 24
     9dc:	00 80       	ld	r0, Z
     9de:	68 96       	adiw	r28, 0x18	; 24
     9e0:	8e ad       	ldd	r24, Y+62	; 0x3e
     9e2:	9f ad       	ldd	r25, Y+63	; 0x3f
     9e4:	68 97       	sbiw	r28, 0x18	; 24
     9e6:	01 96       	adiw	r24, 0x01	; 1
     9e8:	68 96       	adiw	r28, 0x18	; 24
     9ea:	9f af       	std	Y+63, r25	; 0x3f
     9ec:	8e af       	std	Y+62, r24	; 0x3e
     9ee:	68 97       	sbiw	r28, 0x18	; 24
     9f0:	66 96       	adiw	r28, 0x16	; 22
     9f2:	ee ad       	ldd	r30, Y+62	; 0x3e
     9f4:	ff ad       	ldd	r31, Y+63	; 0x3f
     9f6:	66 97       	sbiw	r28, 0x16	; 22
     9f8:	00 82       	st	Z, r0
     9fa:	66 96       	adiw	r28, 0x16	; 22
     9fc:	8e ad       	ldd	r24, Y+62	; 0x3e
     9fe:	9f ad       	ldd	r25, Y+63	; 0x3f
     a00:	66 97       	sbiw	r28, 0x16	; 22
     a02:	01 96       	adiw	r24, 0x01	; 1
     a04:	66 96       	adiw	r28, 0x16	; 22
     a06:	9f af       	std	Y+63, r25	; 0x3f
     a08:	8e af       	std	Y+62, r24	; 0x3e
     a0a:	66 97       	sbiw	r28, 0x16	; 22
     a0c:	69 96       	adiw	r28, 0x19	; 25
     a0e:	9f ad       	ldd	r25, Y+63	; 0x3f
     a10:	69 97       	sbiw	r28, 0x19	; 25
     a12:	91 50       	subi	r25, 0x01	; 1
     a14:	69 96       	adiw	r28, 0x19	; 25
     a16:	9f af       	std	Y+63, r25	; 0x3f
     a18:	69 97       	sbiw	r28, 0x19	; 25
     a1a:	69 96       	adiw	r28, 0x19	; 25
     a1c:	ef ad       	ldd	r30, Y+63	; 0x3f
     a1e:	69 97       	sbiw	r28, 0x19	; 25
     a20:	ee 23       	and	r30, r30
     a22:	c1 f6       	brne	.-80     	; 0x9d4 <LCD_Task+0x132>
	uint8 Player2_Win_Message[] = "Player 2 Won";
     a24:	ce 01       	movw	r24, r28
     a26:	8b 96       	adiw	r24, 0x2b	; 43
     a28:	6b 96       	adiw	r28, 0x1b	; 27
     a2a:	9f af       	std	Y+63, r25	; 0x3f
     a2c:	8e af       	std	Y+62, r24	; 0x3e
     a2e:	6b 97       	sbiw	r28, 0x1b	; 27
     a30:	ea eb       	ldi	r30, 0xBA	; 186
     a32:	f0 e0       	ldi	r31, 0x00	; 0
     a34:	6d 96       	adiw	r28, 0x1d	; 29
     a36:	ff af       	std	Y+63, r31	; 0x3f
     a38:	ee af       	std	Y+62, r30	; 0x3e
     a3a:	6d 97       	sbiw	r28, 0x1d	; 29
     a3c:	fd e0       	ldi	r31, 0x0D	; 13
     a3e:	6e 96       	adiw	r28, 0x1e	; 30
     a40:	ff af       	std	Y+63, r31	; 0x3f
     a42:	6e 97       	sbiw	r28, 0x1e	; 30
     a44:	6d 96       	adiw	r28, 0x1d	; 29
     a46:	ee ad       	ldd	r30, Y+62	; 0x3e
     a48:	ff ad       	ldd	r31, Y+63	; 0x3f
     a4a:	6d 97       	sbiw	r28, 0x1d	; 29
     a4c:	00 80       	ld	r0, Z
     a4e:	6d 96       	adiw	r28, 0x1d	; 29
     a50:	8e ad       	ldd	r24, Y+62	; 0x3e
     a52:	9f ad       	ldd	r25, Y+63	; 0x3f
     a54:	6d 97       	sbiw	r28, 0x1d	; 29
     a56:	01 96       	adiw	r24, 0x01	; 1
     a58:	6d 96       	adiw	r28, 0x1d	; 29
     a5a:	9f af       	std	Y+63, r25	; 0x3f
     a5c:	8e af       	std	Y+62, r24	; 0x3e
     a5e:	6d 97       	sbiw	r28, 0x1d	; 29
     a60:	6b 96       	adiw	r28, 0x1b	; 27
     a62:	ee ad       	ldd	r30, Y+62	; 0x3e
     a64:	ff ad       	ldd	r31, Y+63	; 0x3f
     a66:	6b 97       	sbiw	r28, 0x1b	; 27
     a68:	00 82       	st	Z, r0
     a6a:	6b 96       	adiw	r28, 0x1b	; 27
     a6c:	8e ad       	ldd	r24, Y+62	; 0x3e
     a6e:	9f ad       	ldd	r25, Y+63	; 0x3f
     a70:	6b 97       	sbiw	r28, 0x1b	; 27
     a72:	01 96       	adiw	r24, 0x01	; 1
     a74:	6b 96       	adiw	r28, 0x1b	; 27
     a76:	9f af       	std	Y+63, r25	; 0x3f
     a78:	8e af       	std	Y+62, r24	; 0x3e
     a7a:	6b 97       	sbiw	r28, 0x1b	; 27
     a7c:	6e 96       	adiw	r28, 0x1e	; 30
     a7e:	9f ad       	ldd	r25, Y+63	; 0x3f
     a80:	6e 97       	sbiw	r28, 0x1e	; 30
     a82:	91 50       	subi	r25, 0x01	; 1
     a84:	6e 96       	adiw	r28, 0x1e	; 30
     a86:	9f af       	std	Y+63, r25	; 0x3f
     a88:	6e 97       	sbiw	r28, 0x1e	; 30
     a8a:	6e 96       	adiw	r28, 0x1e	; 30
     a8c:	ef ad       	ldd	r30, Y+63	; 0x3f
     a8e:	6e 97       	sbiw	r28, 0x1e	; 30
     a90:	ee 23       	and	r30, r30
     a92:	c1 f6       	brne	.-80     	; 0xa44 <LCD_Task+0x1a2>
	uint8 Congrat_Message[] = "Congratulations";
     a94:	ce 01       	movw	r24, r28
     a96:	c8 96       	adiw	r24, 0x38	; 56
     a98:	a0 96       	adiw	r28, 0x20	; 32
     a9a:	9f af       	std	Y+63, r25	; 0x3f
     a9c:	8e af       	std	Y+62, r24	; 0x3e
     a9e:	a0 97       	sbiw	r28, 0x20	; 32
     aa0:	e7 ec       	ldi	r30, 0xC7	; 199
     aa2:	f0 e0       	ldi	r31, 0x00	; 0
     aa4:	a2 96       	adiw	r28, 0x22	; 34
     aa6:	ff af       	std	Y+63, r31	; 0x3f
     aa8:	ee af       	std	Y+62, r30	; 0x3e
     aaa:	a2 97       	sbiw	r28, 0x22	; 34
     aac:	f0 e1       	ldi	r31, 0x10	; 16
     aae:	a3 96       	adiw	r28, 0x23	; 35
     ab0:	ff af       	std	Y+63, r31	; 0x3f
     ab2:	a3 97       	sbiw	r28, 0x23	; 35
     ab4:	a2 96       	adiw	r28, 0x22	; 34
     ab6:	ee ad       	ldd	r30, Y+62	; 0x3e
     ab8:	ff ad       	ldd	r31, Y+63	; 0x3f
     aba:	a2 97       	sbiw	r28, 0x22	; 34
     abc:	00 80       	ld	r0, Z
     abe:	a2 96       	adiw	r28, 0x22	; 34
     ac0:	8e ad       	ldd	r24, Y+62	; 0x3e
     ac2:	9f ad       	ldd	r25, Y+63	; 0x3f
     ac4:	a2 97       	sbiw	r28, 0x22	; 34
     ac6:	01 96       	adiw	r24, 0x01	; 1
     ac8:	a2 96       	adiw	r28, 0x22	; 34
     aca:	9f af       	std	Y+63, r25	; 0x3f
     acc:	8e af       	std	Y+62, r24	; 0x3e
     ace:	a2 97       	sbiw	r28, 0x22	; 34
     ad0:	a0 96       	adiw	r28, 0x20	; 32
     ad2:	ee ad       	ldd	r30, Y+62	; 0x3e
     ad4:	ff ad       	ldd	r31, Y+63	; 0x3f
     ad6:	a0 97       	sbiw	r28, 0x20	; 32
     ad8:	00 82       	st	Z, r0
     ada:	a0 96       	adiw	r28, 0x20	; 32
     adc:	8e ad       	ldd	r24, Y+62	; 0x3e
     ade:	9f ad       	ldd	r25, Y+63	; 0x3f
     ae0:	a0 97       	sbiw	r28, 0x20	; 32
     ae2:	01 96       	adiw	r24, 0x01	; 1
     ae4:	a0 96       	adiw	r28, 0x20	; 32
     ae6:	9f af       	std	Y+63, r25	; 0x3f
     ae8:	8e af       	std	Y+62, r24	; 0x3e
     aea:	a0 97       	sbiw	r28, 0x20	; 32
     aec:	a3 96       	adiw	r28, 0x23	; 35
     aee:	9f ad       	ldd	r25, Y+63	; 0x3f
     af0:	a3 97       	sbiw	r28, 0x23	; 35
     af2:	91 50       	subi	r25, 0x01	; 1
     af4:	a3 96       	adiw	r28, 0x23	; 35
     af6:	9f af       	std	Y+63, r25	; 0x3f
     af8:	a3 97       	sbiw	r28, 0x23	; 35
     afa:	a3 96       	adiw	r28, 0x23	; 35
     afc:	ef ad       	ldd	r30, Y+63	; 0x3f
     afe:	a3 97       	sbiw	r28, 0x23	; 35
     b00:	ee 23       	and	r30, r30
     b02:	c1 f6       	brne	.-80     	; 0xab4 <LCD_Task+0x212>

	while(1)
	{
		/*check if any player have 50 points*/
		if(PlayerOne ==50 || PlayerTwo==50)
     b04:	8a 81       	ldd	r24, Y+2	; 0x02
     b06:	82 33       	cpi	r24, 0x32	; 50
     b08:	19 f0       	breq	.+6      	; 0xb10 <LCD_Task+0x26e>
     b0a:	89 81       	ldd	r24, Y+1	; 0x01
     b0c:	82 33       	cpi	r24, 0x32	; 50
     b0e:	49 f5       	brne	.+82     	; 0xb62 <LCD_Task+0x2c0>
		{
			/*if Player 1 get 50 points*/
			if(PlayerOne == 50)
     b10:	8a 81       	ldd	r24, Y+2	; 0x02
     b12:	82 33       	cpi	r24, 0x32	; 50
     b14:	79 f4       	brne	.+30     	; 0xb34 <LCD_Task+0x292>
			{
				LCD_clearScreen();
     b16:	0e 94 9b 0b 	call	0x1736	; 0x1736 <LCD_clearScreen>
				LCD_displayString(Congrat_Message);
     b1a:	ce 01       	movw	r24, r28
     b1c:	c8 96       	adiw	r24, 0x38	; 56
     b1e:	0e 94 17 0b 	call	0x162e	; 0x162e <LCD_displayString>
				LCD_displayStringRowColumn(1 , 0 , Player1_Win_Message);
     b22:	9e 01       	movw	r18, r28
     b24:	22 5e       	subi	r18, 0xE2	; 226
     b26:	3f 4f       	sbci	r19, 0xFF	; 255
     b28:	81 e0       	ldi	r24, 0x01	; 1
     b2a:	60 e0       	ldi	r22, 0x00	; 0
     b2c:	a9 01       	movw	r20, r18
     b2e:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_displayStringRowColumn>
     b32:	0e c0       	rjmp	.+28     	; 0xb50 <LCD_Task+0x2ae>
			}
			/*if Player 2 get 50 points*/
			else
			{
				LCD_clearScreen();
     b34:	0e 94 9b 0b 	call	0x1736	; 0x1736 <LCD_clearScreen>
				LCD_displayString(Congrat_Message);
     b38:	ce 01       	movw	r24, r28
     b3a:	c8 96       	adiw	r24, 0x38	; 56
     b3c:	0e 94 17 0b 	call	0x162e	; 0x162e <LCD_displayString>
				LCD_displayStringRowColumn(1 , 0 , Player2_Win_Message);
     b40:	9e 01       	movw	r18, r28
     b42:	25 5d       	subi	r18, 0xD5	; 213
     b44:	3f 4f       	sbci	r19, 0xFF	; 255
     b46:	81 e0       	ldi	r24, 0x01	; 1
     b48:	60 e0       	ldi	r22, 0x00	; 0
     b4a:	a9 01       	movw	r20, r18
     b4c:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_displayStringRowColumn>
			}
			vTaskDelay(5000);
     b50:	88 e8       	ldi	r24, 0x88	; 136
     b52:	93 e1       	ldi	r25, 0x13	; 19
     b54:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
			PlayerOne = 0;
     b58:	1a 82       	std	Y+2, r1	; 0x02
			PlayerTwo = 0;
     b5a:	19 82       	std	Y+1, r1	; 0x01
			LCD_clearScreen();
     b5c:	0e 94 9b 0b 	call	0x1736	; 0x1736 <LCD_clearScreen>
     b60:	d1 cf       	rjmp	.-94     	; 0xb04 <LCD_Task+0x262>
		}
		else
		{
			/*receive messages from other tasks by queues*/
			xQueueReceive(Queue_PushButton_A , &PushButton_A_Task_Data , 10);
     b62:	80 91 ea 00 	lds	r24, 0x00EA
     b66:	90 91 eb 00 	lds	r25, 0x00EB
     b6a:	9e 01       	movw	r18, r28
     b6c:	2c 5f       	subi	r18, 0xFC	; 252
     b6e:	3f 4f       	sbci	r19, 0xFF	; 255
     b70:	b9 01       	movw	r22, r18
     b72:	4a e0       	ldi	r20, 0x0A	; 10
     b74:	50 e0       	ldi	r21, 0x00	; 0
     b76:	0e 94 77 12 	call	0x24ee	; 0x24ee <xQueueReceive>
			xQueueReceive(Queue_PushButton_B , &PushButton_B_Task_Data , 10);
     b7a:	80 91 ec 00 	lds	r24, 0x00EC
     b7e:	90 91 ed 00 	lds	r25, 0x00ED
     b82:	9e 01       	movw	r18, r28
     b84:	2b 5f       	subi	r18, 0xFB	; 251
     b86:	3f 4f       	sbci	r19, 0xFF	; 255
     b88:	b9 01       	movw	r22, r18
     b8a:	4a e0       	ldi	r20, 0x0A	; 10
     b8c:	50 e0       	ldi	r21, 0x00	; 0
     b8e:	0e 94 77 12 	call	0x24ee	; 0x24ee <xQueueReceive>

			/*Increment points of Player 1 if Push Button A was pressed*/
			if(PushButton_A_Task_Data == 1)
     b92:	8c 81       	ldd	r24, Y+4	; 0x04
     b94:	81 30       	cpi	r24, 0x01	; 1
     b96:	09 f0       	breq	.+2      	; 0xb9a <LCD_Task+0x2f8>
     b98:	43 c0       	rjmp	.+134    	; 0xc20 <LCD_Task+0x37e>
			{
				if(Flag == 1)
     b9a:	8b 81       	ldd	r24, Y+3	; 0x03
     b9c:	81 30       	cpi	r24, 0x01	; 1
     b9e:	11 f4       	brne	.+4      	; 0xba4 <LCD_Task+0x302>
				{
					LCD_clearScreen();
     ba0:	0e 94 9b 0b 	call	0x1736	; 0x1736 <LCD_clearScreen>
				}
				PlayerOne++;
     ba4:	8a 81       	ldd	r24, Y+2	; 0x02
     ba6:	8f 5f       	subi	r24, 0xFF	; 255
     ba8:	8a 83       	std	Y+2, r24	; 0x02
				/*Decrement points of Player 2 if Push Button A was pressed*/
				if(PlayerTwo>0)
     baa:	89 81       	ldd	r24, Y+1	; 0x01
     bac:	88 23       	and	r24, r24
     bae:	19 f0       	breq	.+6      	; 0xbb6 <LCD_Task+0x314>
				{
					PlayerTwo--;
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
     bb2:	81 50       	subi	r24, 0x01	; 1
     bb4:	89 83       	std	Y+1, r24	; 0x01
				}
				/*display result on LCD*/
				LCD_displayStringRowColumn(0 , 0 , ButtonA);
     bb6:	9e 01       	movw	r18, r28
     bb8:	2a 5f       	subi	r18, 0xFA	; 250
     bba:	3f 4f       	sbci	r19, 0xFF	; 255
     bbc:	80 e0       	ldi	r24, 0x00	; 0
     bbe:	60 e0       	ldi	r22, 0x00	; 0
     bc0:	a9 01       	movw	r20, r18
     bc2:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_displayStringRowColumn>
				LCD_displayCharacter((PlayerOne/10)+48);
     bc6:	8a 81       	ldd	r24, Y+2	; 0x02
     bc8:	9a e0       	ldi	r25, 0x0A	; 10
     bca:	69 2f       	mov	r22, r25
     bcc:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <__udivmodqi4>
     bd0:	80 5d       	subi	r24, 0xD0	; 208
     bd2:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
				LCD_displayCharacter((PlayerOne % 10)+48);
     bd6:	8a 81       	ldd	r24, Y+2	; 0x02
     bd8:	9a e0       	ldi	r25, 0x0A	; 10
     bda:	69 2f       	mov	r22, r25
     bdc:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <__udivmodqi4>
     be0:	89 2f       	mov	r24, r25
     be2:	80 5d       	subi	r24, 0xD0	; 208
     be4:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
				LCD_displayStringRowColumn(1 , 0 , ButtonB);
     be8:	9e 01       	movw	r18, r28
     bea:	2e 5e       	subi	r18, 0xEE	; 238
     bec:	3f 4f       	sbci	r19, 0xFF	; 255
     bee:	81 e0       	ldi	r24, 0x01	; 1
     bf0:	60 e0       	ldi	r22, 0x00	; 0
     bf2:	a9 01       	movw	r20, r18
     bf4:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_displayStringRowColumn>
				LCD_displayCharacter((PlayerTwo/10)+48);
     bf8:	89 81       	ldd	r24, Y+1	; 0x01
     bfa:	9a e0       	ldi	r25, 0x0A	; 10
     bfc:	69 2f       	mov	r22, r25
     bfe:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <__udivmodqi4>
     c02:	80 5d       	subi	r24, 0xD0	; 208
     c04:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
				LCD_displayCharacter((PlayerTwo % 10)+48);
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a e0       	ldi	r25, 0x0A	; 10
     c0c:	69 2f       	mov	r22, r25
     c0e:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <__udivmodqi4>
     c12:	89 2f       	mov	r24, r25
     c14:	80 5d       	subi	r24, 0xD0	; 208
     c16:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
				PushButton_A_Task_Data = 0;
     c1a:	1c 82       	std	Y+4, r1	; 0x04
				Flag = 0;
     c1c:	1b 82       	std	Y+3, r1	; 0x03
     c1e:	46 c0       	rjmp	.+140    	; 0xcac <LCD_Task+0x40a>
			}
			/*Increment points of Player 2 if Push Button B was pressed*/
			else if(PushButton_B_Task_Data == 1)
     c20:	8d 81       	ldd	r24, Y+5	; 0x05
     c22:	81 30       	cpi	r24, 0x01	; 1
     c24:	09 f0       	breq	.+2      	; 0xc28 <LCD_Task+0x386>
     c26:	42 c0       	rjmp	.+132    	; 0xcac <LCD_Task+0x40a>
			{
				if(Flag == 1)
     c28:	8b 81       	ldd	r24, Y+3	; 0x03
     c2a:	81 30       	cpi	r24, 0x01	; 1
     c2c:	11 f4       	brne	.+4      	; 0xc32 <LCD_Task+0x390>
				{
					LCD_clearScreen();
     c2e:	0e 94 9b 0b 	call	0x1736	; 0x1736 <LCD_clearScreen>
				}
				PlayerTwo++;
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	8f 5f       	subi	r24, 0xFF	; 255
     c36:	89 83       	std	Y+1, r24	; 0x01
				/*Decrement points of Player 1 if Push Button B was pressed*/
				if(PlayerOne>0)
     c38:	8a 81       	ldd	r24, Y+2	; 0x02
     c3a:	88 23       	and	r24, r24
     c3c:	19 f0       	breq	.+6      	; 0xc44 <LCD_Task+0x3a2>
				{
					PlayerOne--;
     c3e:	8a 81       	ldd	r24, Y+2	; 0x02
     c40:	81 50       	subi	r24, 0x01	; 1
     c42:	8a 83       	std	Y+2, r24	; 0x02
				}
				/*display result on LCD*/
				LCD_displayStringRowColumn(0 , 0 , ButtonA);
     c44:	9e 01       	movw	r18, r28
     c46:	2a 5f       	subi	r18, 0xFA	; 250
     c48:	3f 4f       	sbci	r19, 0xFF	; 255
     c4a:	80 e0       	ldi	r24, 0x00	; 0
     c4c:	60 e0       	ldi	r22, 0x00	; 0
     c4e:	a9 01       	movw	r20, r18
     c50:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_displayStringRowColumn>
				LCD_displayCharacter((PlayerOne/10)+48);
     c54:	8a 81       	ldd	r24, Y+2	; 0x02
     c56:	9a e0       	ldi	r25, 0x0A	; 10
     c58:	69 2f       	mov	r22, r25
     c5a:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <__udivmodqi4>
     c5e:	80 5d       	subi	r24, 0xD0	; 208
     c60:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
				LCD_displayCharacter((PlayerOne % 10)+48);
     c64:	8a 81       	ldd	r24, Y+2	; 0x02
     c66:	9a e0       	ldi	r25, 0x0A	; 10
     c68:	69 2f       	mov	r22, r25
     c6a:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <__udivmodqi4>
     c6e:	89 2f       	mov	r24, r25
     c70:	80 5d       	subi	r24, 0xD0	; 208
     c72:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
				LCD_displayStringRowColumn(1 , 0 , ButtonB);
     c76:	9e 01       	movw	r18, r28
     c78:	2e 5e       	subi	r18, 0xEE	; 238
     c7a:	3f 4f       	sbci	r19, 0xFF	; 255
     c7c:	81 e0       	ldi	r24, 0x01	; 1
     c7e:	60 e0       	ldi	r22, 0x00	; 0
     c80:	a9 01       	movw	r20, r18
     c82:	0e 94 82 0b 	call	0x1704	; 0x1704 <LCD_displayStringRowColumn>
				LCD_displayCharacter((PlayerTwo/10)+48);
     c86:	89 81       	ldd	r24, Y+1	; 0x01
     c88:	9a e0       	ldi	r25, 0x0A	; 10
     c8a:	69 2f       	mov	r22, r25
     c8c:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <__udivmodqi4>
     c90:	80 5d       	subi	r24, 0xD0	; 208
     c92:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
				LCD_displayCharacter((PlayerTwo % 10)+48);
     c96:	89 81       	ldd	r24, Y+1	; 0x01
     c98:	9a e0       	ldi	r25, 0x0A	; 10
     c9a:	69 2f       	mov	r22, r25
     c9c:	0e 94 09 2e 	call	0x5c12	; 0x5c12 <__udivmodqi4>
     ca0:	89 2f       	mov	r24, r25
     ca2:	80 5d       	subi	r24, 0xD0	; 208
     ca4:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
				PushButton_B_Task_Data = 0;
     ca8:	1d 82       	std	Y+5, r1	; 0x05
				Flag = 0;
     caa:	1b 82       	std	Y+3, r1	; 0x03
			}
			else
			{
				/*Do Nothing*/
			}
			vTaskDelay(20);
     cac:	84 e1       	ldi	r24, 0x14	; 20
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
     cb4:	27 cf       	rjmp	.-434    	; 0xb04 <LCD_Task+0x262>

00000cb6 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     cb6:	df 93       	push	r29
     cb8:	cf 93       	push	r28
     cba:	00 d0       	rcall	.+0      	; 0xcbc <xEventGroupCreate+0x6>
     cbc:	cd b7       	in	r28, 0x3d	; 61
     cbe:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     cc0:	8b e0       	ldi	r24, 0x0B	; 11
     cc2:	90 e0       	ldi	r25, 0x00	; 0
     cc4:	0e 94 a0 09 	call	0x1340	; 0x1340 <pvPortMalloc>
     cc8:	9a 83       	std	Y+2, r25	; 0x02
     cca:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     ccc:	89 81       	ldd	r24, Y+1	; 0x01
     cce:	9a 81       	ldd	r25, Y+2	; 0x02
     cd0:	00 97       	sbiw	r24, 0x00	; 0
     cd2:	49 f0       	breq	.+18     	; 0xce6 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     cd4:	e9 81       	ldd	r30, Y+1	; 0x01
     cd6:	fa 81       	ldd	r31, Y+2	; 0x02
     cd8:	11 82       	std	Z+1, r1	; 0x01
     cda:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     cdc:	89 81       	ldd	r24, Y+1	; 0x01
     cde:	9a 81       	ldd	r25, Y+2	; 0x02
     ce0:	02 96       	adiw	r24, 0x02	; 2
     ce2:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     ce6:	89 81       	ldd	r24, Y+1	; 0x01
     ce8:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     cea:	0f 90       	pop	r0
     cec:	0f 90       	pop	r0
     cee:	cf 91       	pop	r28
     cf0:	df 91       	pop	r29
     cf2:	08 95       	ret

00000cf4 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     cf4:	df 93       	push	r29
     cf6:	cf 93       	push	r28
     cf8:	cd b7       	in	r28, 0x3d	; 61
     cfa:	de b7       	in	r29, 0x3e	; 62
     cfc:	60 97       	sbiw	r28, 0x10	; 16
     cfe:	0f b6       	in	r0, 0x3f	; 63
     d00:	f8 94       	cli
     d02:	de bf       	out	0x3e, r29	; 62
     d04:	0f be       	out	0x3f, r0	; 63
     d06:	cd bf       	out	0x3d, r28	; 61
     d08:	9a 87       	std	Y+10, r25	; 0x0a
     d0a:	89 87       	std	Y+9, r24	; 0x09
     d0c:	7c 87       	std	Y+12, r23	; 0x0c
     d0e:	6b 87       	std	Y+11, r22	; 0x0b
     d10:	5e 87       	std	Y+14, r21	; 0x0e
     d12:	4d 87       	std	Y+13, r20	; 0x0d
     d14:	38 8b       	std	Y+16, r19	; 0x10
     d16:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     d18:	89 85       	ldd	r24, Y+9	; 0x09
     d1a:	9a 85       	ldd	r25, Y+10	; 0x0a
     d1c:	9c 83       	std	Y+4, r25	; 0x04
     d1e:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     d20:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     d22:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     d26:	eb 81       	ldd	r30, Y+3	; 0x03
     d28:	fc 81       	ldd	r31, Y+4	; 0x04
     d2a:	80 81       	ld	r24, Z
     d2c:	91 81       	ldd	r25, Z+1	; 0x01
     d2e:	98 87       	std	Y+8, r25	; 0x08
     d30:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     d32:	89 85       	ldd	r24, Y+9	; 0x09
     d34:	9a 85       	ldd	r25, Y+10	; 0x0a
     d36:	2b 85       	ldd	r18, Y+11	; 0x0b
     d38:	3c 85       	ldd	r19, Y+12	; 0x0c
     d3a:	b9 01       	movw	r22, r18
     d3c:	0e 94 51 08 	call	0x10a2	; 0x10a2 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     d40:	2f 81       	ldd	r18, Y+7	; 0x07
     d42:	38 85       	ldd	r19, Y+8	; 0x08
     d44:	8b 85       	ldd	r24, Y+11	; 0x0b
     d46:	9c 85       	ldd	r25, Y+12	; 0x0c
     d48:	28 2b       	or	r18, r24
     d4a:	39 2b       	or	r19, r25
     d4c:	8d 85       	ldd	r24, Y+13	; 0x0d
     d4e:	9e 85       	ldd	r25, Y+14	; 0x0e
     d50:	28 23       	and	r18, r24
     d52:	39 23       	and	r19, r25
     d54:	8d 85       	ldd	r24, Y+13	; 0x0d
     d56:	9e 85       	ldd	r25, Y+14	; 0x0e
     d58:	28 17       	cp	r18, r24
     d5a:	39 07       	cpc	r19, r25
     d5c:	c9 f4       	brne	.+50     	; 0xd90 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     d5e:	2f 81       	ldd	r18, Y+7	; 0x07
     d60:	38 85       	ldd	r19, Y+8	; 0x08
     d62:	8b 85       	ldd	r24, Y+11	; 0x0b
     d64:	9c 85       	ldd	r25, Y+12	; 0x0c
     d66:	82 2b       	or	r24, r18
     d68:	93 2b       	or	r25, r19
     d6a:	9e 83       	std	Y+6, r25	; 0x06
     d6c:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     d6e:	eb 81       	ldd	r30, Y+3	; 0x03
     d70:	fc 81       	ldd	r31, Y+4	; 0x04
     d72:	20 81       	ld	r18, Z
     d74:	31 81       	ldd	r19, Z+1	; 0x01
     d76:	8d 85       	ldd	r24, Y+13	; 0x0d
     d78:	9e 85       	ldd	r25, Y+14	; 0x0e
     d7a:	80 95       	com	r24
     d7c:	90 95       	com	r25
     d7e:	82 23       	and	r24, r18
     d80:	93 23       	and	r25, r19
     d82:	eb 81       	ldd	r30, Y+3	; 0x03
     d84:	fc 81       	ldd	r31, Y+4	; 0x04
     d86:	91 83       	std	Z+1, r25	; 0x01
     d88:	80 83       	st	Z, r24

			xTicksToWait = 0;
     d8a:	18 8a       	std	Y+16, r1	; 0x10
     d8c:	1f 86       	std	Y+15, r1	; 0x0f
     d8e:	1e c0       	rjmp	.+60     	; 0xdcc <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     d90:	8f 85       	ldd	r24, Y+15	; 0x0f
     d92:	98 89       	ldd	r25, Y+16	; 0x10
     d94:	00 97       	sbiw	r24, 0x00	; 0
     d96:	91 f0       	breq	.+36     	; 0xdbc <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     d98:	8b 81       	ldd	r24, Y+3	; 0x03
     d9a:	9c 81       	ldd	r25, Y+4	; 0x04
     d9c:	bc 01       	movw	r22, r24
     d9e:	6e 5f       	subi	r22, 0xFE	; 254
     da0:	7f 4f       	sbci	r23, 0xFF	; 255
     da2:	8d 85       	ldd	r24, Y+13	; 0x0d
     da4:	9e 85       	ldd	r25, Y+14	; 0x0e
     da6:	9c 01       	movw	r18, r24
     da8:	35 60       	ori	r19, 0x05	; 5
     daa:	4f 85       	ldd	r20, Y+15	; 0x0f
     dac:	58 89       	ldd	r21, Y+16	; 0x10
     dae:	cb 01       	movw	r24, r22
     db0:	b9 01       	movw	r22, r18
     db2:	0e 94 8e 25 	call	0x4b1c	; 0x4b1c <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     db6:	1e 82       	std	Y+6, r1	; 0x06
     db8:	1d 82       	std	Y+5, r1	; 0x05
     dba:	08 c0       	rjmp	.+16     	; 0xdcc <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     dbc:	eb 81       	ldd	r30, Y+3	; 0x03
     dbe:	fc 81       	ldd	r31, Y+4	; 0x04
     dc0:	80 81       	ld	r24, Z
     dc2:	91 81       	ldd	r25, Z+1	; 0x01
     dc4:	9e 83       	std	Y+6, r25	; 0x06
     dc6:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     dc8:	81 e0       	ldi	r24, 0x01	; 1
     dca:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     dcc:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
     dd0:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     dd2:	8f 85       	ldd	r24, Y+15	; 0x0f
     dd4:	98 89       	ldd	r25, Y+16	; 0x10
     dd6:	00 97       	sbiw	r24, 0x00	; 0
     dd8:	09 f4       	brne	.+2      	; 0xddc <xEventGroupSync+0xe8>
     dda:	3a c0       	rjmp	.+116    	; 0xe50 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     ddc:	8a 81       	ldd	r24, Y+2	; 0x02
     dde:	88 23       	and	r24, r24
     de0:	11 f4       	brne	.+4      	; 0xde6 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     de2:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     de6:	0e 94 a6 29 	call	0x534c	; 0x534c <uxTaskResetEventItemValue>
     dea:	9e 83       	std	Y+6, r25	; 0x06
     dec:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     dee:	8d 81       	ldd	r24, Y+5	; 0x05
     df0:	9e 81       	ldd	r25, Y+6	; 0x06
     df2:	80 70       	andi	r24, 0x00	; 0
     df4:	92 70       	andi	r25, 0x02	; 2
     df6:	00 97       	sbiw	r24, 0x00	; 0
     df8:	31 f5       	brne	.+76     	; 0xe46 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     dfa:	0f b6       	in	r0, 0x3f	; 63
     dfc:	f8 94       	cli
     dfe:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     e00:	eb 81       	ldd	r30, Y+3	; 0x03
     e02:	fc 81       	ldd	r31, Y+4	; 0x04
     e04:	80 81       	ld	r24, Z
     e06:	91 81       	ldd	r25, Z+1	; 0x01
     e08:	9e 83       	std	Y+6, r25	; 0x06
     e0a:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e0c:	2d 81       	ldd	r18, Y+5	; 0x05
     e0e:	3e 81       	ldd	r19, Y+6	; 0x06
     e10:	8d 85       	ldd	r24, Y+13	; 0x0d
     e12:	9e 85       	ldd	r25, Y+14	; 0x0e
     e14:	28 23       	and	r18, r24
     e16:	39 23       	and	r19, r25
     e18:	8d 85       	ldd	r24, Y+13	; 0x0d
     e1a:	9e 85       	ldd	r25, Y+14	; 0x0e
     e1c:	28 17       	cp	r18, r24
     e1e:	39 07       	cpc	r19, r25
     e20:	71 f4       	brne	.+28     	; 0xe3e <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     e22:	eb 81       	ldd	r30, Y+3	; 0x03
     e24:	fc 81       	ldd	r31, Y+4	; 0x04
     e26:	20 81       	ld	r18, Z
     e28:	31 81       	ldd	r19, Z+1	; 0x01
     e2a:	8d 85       	ldd	r24, Y+13	; 0x0d
     e2c:	9e 85       	ldd	r25, Y+14	; 0x0e
     e2e:	80 95       	com	r24
     e30:	90 95       	com	r25
     e32:	82 23       	and	r24, r18
     e34:	93 23       	and	r25, r19
     e36:	eb 81       	ldd	r30, Y+3	; 0x03
     e38:	fc 81       	ldd	r31, Y+4	; 0x04
     e3a:	91 83       	std	Z+1, r25	; 0x01
     e3c:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     e3e:	0f 90       	pop	r0
     e40:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     e42:	81 e0       	ldi	r24, 0x01	; 1
     e44:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     e46:	8d 81       	ldd	r24, Y+5	; 0x05
     e48:	9e 81       	ldd	r25, Y+6	; 0x06
     e4a:	90 70       	andi	r25, 0x00	; 0
     e4c:	9e 83       	std	Y+6, r25	; 0x06
     e4e:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     e50:	8d 81       	ldd	r24, Y+5	; 0x05
     e52:	9e 81       	ldd	r25, Y+6	; 0x06
}
     e54:	60 96       	adiw	r28, 0x10	; 16
     e56:	0f b6       	in	r0, 0x3f	; 63
     e58:	f8 94       	cli
     e5a:	de bf       	out	0x3e, r29	; 62
     e5c:	0f be       	out	0x3f, r0	; 63
     e5e:	cd bf       	out	0x3d, r28	; 61
     e60:	cf 91       	pop	r28
     e62:	df 91       	pop	r29
     e64:	08 95       	ret

00000e66 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     e66:	0f 93       	push	r16
     e68:	1f 93       	push	r17
     e6a:	df 93       	push	r29
     e6c:	cf 93       	push	r28
     e6e:	cd b7       	in	r28, 0x3d	; 61
     e70:	de b7       	in	r29, 0x3e	; 62
     e72:	63 97       	sbiw	r28, 0x13	; 19
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	f8 94       	cli
     e78:	de bf       	out	0x3e, r29	; 62
     e7a:	0f be       	out	0x3f, r0	; 63
     e7c:	cd bf       	out	0x3d, r28	; 61
     e7e:	9d 87       	std	Y+13, r25	; 0x0d
     e80:	8c 87       	std	Y+12, r24	; 0x0c
     e82:	7f 87       	std	Y+15, r23	; 0x0f
     e84:	6e 87       	std	Y+14, r22	; 0x0e
     e86:	48 8b       	std	Y+16, r20	; 0x10
     e88:	29 8b       	std	Y+17, r18	; 0x11
     e8a:	1b 8b       	std	Y+19, r17	; 0x13
     e8c:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     e8e:	8c 85       	ldd	r24, Y+12	; 0x0c
     e90:	9d 85       	ldd	r25, Y+13	; 0x0d
     e92:	9b 87       	std	Y+11, r25	; 0x0b
     e94:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     e96:	1f 82       	std	Y+7, r1	; 0x07
     e98:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     e9a:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     e9c:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     ea0:	ea 85       	ldd	r30, Y+10	; 0x0a
     ea2:	fb 85       	ldd	r31, Y+11	; 0x0b
     ea4:	80 81       	ld	r24, Z
     ea6:	91 81       	ldd	r25, Z+1	; 0x01
     ea8:	9a 83       	std	Y+2, r25	; 0x02
     eaa:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     eac:	89 81       	ldd	r24, Y+1	; 0x01
     eae:	9a 81       	ldd	r25, Y+2	; 0x02
     eb0:	2e 85       	ldd	r18, Y+14	; 0x0e
     eb2:	3f 85       	ldd	r19, Y+15	; 0x0f
     eb4:	b9 01       	movw	r22, r18
     eb6:	49 89       	ldd	r20, Y+17	; 0x11
     eb8:	0e 94 6e 09 	call	0x12dc	; 0x12dc <prvTestWaitCondition>
     ebc:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     ebe:	8d 81       	ldd	r24, Y+5	; 0x05
     ec0:	88 23       	and	r24, r24
     ec2:	c1 f0       	breq	.+48     	; 0xef4 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     ec4:	89 81       	ldd	r24, Y+1	; 0x01
     ec6:	9a 81       	ldd	r25, Y+2	; 0x02
     ec8:	99 87       	std	Y+9, r25	; 0x09
     eca:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     ecc:	1b 8a       	std	Y+19, r1	; 0x13
     ece:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     ed0:	88 89       	ldd	r24, Y+16	; 0x10
     ed2:	88 23       	and	r24, r24
     ed4:	e9 f1       	breq	.+122    	; 0xf50 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ed6:	ea 85       	ldd	r30, Y+10	; 0x0a
     ed8:	fb 85       	ldd	r31, Y+11	; 0x0b
     eda:	20 81       	ld	r18, Z
     edc:	31 81       	ldd	r19, Z+1	; 0x01
     ede:	8e 85       	ldd	r24, Y+14	; 0x0e
     ee0:	9f 85       	ldd	r25, Y+15	; 0x0f
     ee2:	80 95       	com	r24
     ee4:	90 95       	com	r25
     ee6:	82 23       	and	r24, r18
     ee8:	93 23       	and	r25, r19
     eea:	ea 85       	ldd	r30, Y+10	; 0x0a
     eec:	fb 85       	ldd	r31, Y+11	; 0x0b
     eee:	91 83       	std	Z+1, r25	; 0x01
     ef0:	80 83       	st	Z, r24
     ef2:	2e c0       	rjmp	.+92     	; 0xf50 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     ef4:	8a 89       	ldd	r24, Y+18	; 0x12
     ef6:	9b 89       	ldd	r25, Y+19	; 0x13
     ef8:	00 97       	sbiw	r24, 0x00	; 0
     efa:	39 f4       	brne	.+14     	; 0xf0a <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     efc:	89 81       	ldd	r24, Y+1	; 0x01
     efe:	9a 81       	ldd	r25, Y+2	; 0x02
     f00:	99 87       	std	Y+9, r25	; 0x09
     f02:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     f04:	81 e0       	ldi	r24, 0x01	; 1
     f06:	8b 83       	std	Y+3, r24	; 0x03
     f08:	23 c0       	rjmp	.+70     	; 0xf50 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     f0a:	88 89       	ldd	r24, Y+16	; 0x10
     f0c:	88 23       	and	r24, r24
     f0e:	29 f0       	breq	.+10     	; 0xf1a <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     f10:	8e 81       	ldd	r24, Y+6	; 0x06
     f12:	9f 81       	ldd	r25, Y+7	; 0x07
     f14:	91 60       	ori	r25, 0x01	; 1
     f16:	9f 83       	std	Y+7, r25	; 0x07
     f18:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     f1a:	89 89       	ldd	r24, Y+17	; 0x11
     f1c:	88 23       	and	r24, r24
     f1e:	29 f0       	breq	.+10     	; 0xf2a <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     f20:	8e 81       	ldd	r24, Y+6	; 0x06
     f22:	9f 81       	ldd	r25, Y+7	; 0x07
     f24:	94 60       	ori	r25, 0x04	; 4
     f26:	9f 83       	std	Y+7, r25	; 0x07
     f28:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     f2a:	8a 85       	ldd	r24, Y+10	; 0x0a
     f2c:	9b 85       	ldd	r25, Y+11	; 0x0b
     f2e:	bc 01       	movw	r22, r24
     f30:	6e 5f       	subi	r22, 0xFE	; 254
     f32:	7f 4f       	sbci	r23, 0xFF	; 255
     f34:	2e 85       	ldd	r18, Y+14	; 0x0e
     f36:	3f 85       	ldd	r19, Y+15	; 0x0f
     f38:	8e 81       	ldd	r24, Y+6	; 0x06
     f3a:	9f 81       	ldd	r25, Y+7	; 0x07
     f3c:	28 2b       	or	r18, r24
     f3e:	39 2b       	or	r19, r25
     f40:	4a 89       	ldd	r20, Y+18	; 0x12
     f42:	5b 89       	ldd	r21, Y+19	; 0x13
     f44:	cb 01       	movw	r24, r22
     f46:	b9 01       	movw	r22, r18
     f48:	0e 94 8e 25 	call	0x4b1c	; 0x4b1c <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     f4c:	19 86       	std	Y+9, r1	; 0x09
     f4e:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     f50:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
     f54:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     f56:	8a 89       	ldd	r24, Y+18	; 0x12
     f58:	9b 89       	ldd	r25, Y+19	; 0x13
     f5a:	00 97       	sbiw	r24, 0x00	; 0
     f5c:	09 f4       	brne	.+2      	; 0xf60 <xEventGroupWaitBits+0xfa>
     f5e:	3c c0       	rjmp	.+120    	; 0xfd8 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     f60:	8c 81       	ldd	r24, Y+4	; 0x04
     f62:	88 23       	and	r24, r24
     f64:	11 f4       	brne	.+4      	; 0xf6a <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     f66:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     f6a:	0e 94 a6 29 	call	0x534c	; 0x534c <uxTaskResetEventItemValue>
     f6e:	99 87       	std	Y+9, r25	; 0x09
     f70:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     f72:	88 85       	ldd	r24, Y+8	; 0x08
     f74:	99 85       	ldd	r25, Y+9	; 0x09
     f76:	80 70       	andi	r24, 0x00	; 0
     f78:	92 70       	andi	r25, 0x02	; 2
     f7a:	00 97       	sbiw	r24, 0x00	; 0
     f7c:	41 f5       	brne	.+80     	; 0xfce <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     f7e:	0f b6       	in	r0, 0x3f	; 63
     f80:	f8 94       	cli
     f82:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     f84:	ea 85       	ldd	r30, Y+10	; 0x0a
     f86:	fb 85       	ldd	r31, Y+11	; 0x0b
     f88:	80 81       	ld	r24, Z
     f8a:	91 81       	ldd	r25, Z+1	; 0x01
     f8c:	99 87       	std	Y+9, r25	; 0x09
     f8e:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     f90:	88 85       	ldd	r24, Y+8	; 0x08
     f92:	99 85       	ldd	r25, Y+9	; 0x09
     f94:	2e 85       	ldd	r18, Y+14	; 0x0e
     f96:	3f 85       	ldd	r19, Y+15	; 0x0f
     f98:	b9 01       	movw	r22, r18
     f9a:	49 89       	ldd	r20, Y+17	; 0x11
     f9c:	0e 94 6e 09 	call	0x12dc	; 0x12dc <prvTestWaitCondition>
     fa0:	88 23       	and	r24, r24
     fa2:	89 f0       	breq	.+34     	; 0xfc6 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     fa4:	88 89       	ldd	r24, Y+16	; 0x10
     fa6:	88 23       	and	r24, r24
     fa8:	71 f0       	breq	.+28     	; 0xfc6 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     faa:	ea 85       	ldd	r30, Y+10	; 0x0a
     fac:	fb 85       	ldd	r31, Y+11	; 0x0b
     fae:	20 81       	ld	r18, Z
     fb0:	31 81       	ldd	r19, Z+1	; 0x01
     fb2:	8e 85       	ldd	r24, Y+14	; 0x0e
     fb4:	9f 85       	ldd	r25, Y+15	; 0x0f
     fb6:	80 95       	com	r24
     fb8:	90 95       	com	r25
     fba:	82 23       	and	r24, r18
     fbc:	93 23       	and	r25, r19
     fbe:	ea 85       	ldd	r30, Y+10	; 0x0a
     fc0:	fb 85       	ldd	r31, Y+11	; 0x0b
     fc2:	91 83       	std	Z+1, r25	; 0x01
     fc4:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     fc6:	81 e0       	ldi	r24, 0x01	; 1
     fc8:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     fca:	0f 90       	pop	r0
     fcc:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     fce:	88 85       	ldd	r24, Y+8	; 0x08
     fd0:	99 85       	ldd	r25, Y+9	; 0x09
     fd2:	90 70       	andi	r25, 0x00	; 0
     fd4:	99 87       	std	Y+9, r25	; 0x09
     fd6:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     fd8:	88 85       	ldd	r24, Y+8	; 0x08
     fda:	99 85       	ldd	r25, Y+9	; 0x09
}
     fdc:	63 96       	adiw	r28, 0x13	; 19
     fde:	0f b6       	in	r0, 0x3f	; 63
     fe0:	f8 94       	cli
     fe2:	de bf       	out	0x3e, r29	; 62
     fe4:	0f be       	out	0x3f, r0	; 63
     fe6:	cd bf       	out	0x3d, r28	; 61
     fe8:	cf 91       	pop	r28
     fea:	df 91       	pop	r29
     fec:	1f 91       	pop	r17
     fee:	0f 91       	pop	r16
     ff0:	08 95       	ret

00000ff2 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     ff2:	df 93       	push	r29
     ff4:	cf 93       	push	r28
     ff6:	cd b7       	in	r28, 0x3d	; 61
     ff8:	de b7       	in	r29, 0x3e	; 62
     ffa:	28 97       	sbiw	r28, 0x08	; 8
     ffc:	0f b6       	in	r0, 0x3f	; 63
     ffe:	f8 94       	cli
    1000:	de bf       	out	0x3e, r29	; 62
    1002:	0f be       	out	0x3f, r0	; 63
    1004:	cd bf       	out	0x3d, r28	; 61
    1006:	9e 83       	std	Y+6, r25	; 0x06
    1008:	8d 83       	std	Y+5, r24	; 0x05
    100a:	78 87       	std	Y+8, r23	; 0x08
    100c:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    100e:	8d 81       	ldd	r24, Y+5	; 0x05
    1010:	9e 81       	ldd	r25, Y+6	; 0x06
    1012:	9c 83       	std	Y+4, r25	; 0x04
    1014:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    1016:	0f b6       	in	r0, 0x3f	; 63
    1018:	f8 94       	cli
    101a:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    101c:	eb 81       	ldd	r30, Y+3	; 0x03
    101e:	fc 81       	ldd	r31, Y+4	; 0x04
    1020:	80 81       	ld	r24, Z
    1022:	91 81       	ldd	r25, Z+1	; 0x01
    1024:	9a 83       	std	Y+2, r25	; 0x02
    1026:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1028:	eb 81       	ldd	r30, Y+3	; 0x03
    102a:	fc 81       	ldd	r31, Y+4	; 0x04
    102c:	20 81       	ld	r18, Z
    102e:	31 81       	ldd	r19, Z+1	; 0x01
    1030:	8f 81       	ldd	r24, Y+7	; 0x07
    1032:	98 85       	ldd	r25, Y+8	; 0x08
    1034:	80 95       	com	r24
    1036:	90 95       	com	r25
    1038:	82 23       	and	r24, r18
    103a:	93 23       	and	r25, r19
    103c:	eb 81       	ldd	r30, Y+3	; 0x03
    103e:	fc 81       	ldd	r31, Y+4	; 0x04
    1040:	91 83       	std	Z+1, r25	; 0x01
    1042:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    1044:	0f 90       	pop	r0
    1046:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1048:	89 81       	ldd	r24, Y+1	; 0x01
    104a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    104c:	28 96       	adiw	r28, 0x08	; 8
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	f8 94       	cli
    1052:	de bf       	out	0x3e, r29	; 62
    1054:	0f be       	out	0x3f, r0	; 63
    1056:	cd bf       	out	0x3d, r28	; 61
    1058:	cf 91       	pop	r28
    105a:	df 91       	pop	r29
    105c:	08 95       	ret

0000105e <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    105e:	df 93       	push	r29
    1060:	cf 93       	push	r28
    1062:	cd b7       	in	r28, 0x3d	; 61
    1064:	de b7       	in	r29, 0x3e	; 62
    1066:	27 97       	sbiw	r28, 0x07	; 7
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	9f 83       	std	Y+7, r25	; 0x07
    1074:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    1076:	8e 81       	ldd	r24, Y+6	; 0x06
    1078:	9f 81       	ldd	r25, Y+7	; 0x07
    107a:	9c 83       	std	Y+4, r25	; 0x04
    107c:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    107e:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    1080:	eb 81       	ldd	r30, Y+3	; 0x03
    1082:	fc 81       	ldd	r31, Y+4	; 0x04
    1084:	80 81       	ld	r24, Z
    1086:	91 81       	ldd	r25, Z+1	; 0x01
    1088:	9a 83       	std	Y+2, r25	; 0x02
    108a:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    108c:	89 81       	ldd	r24, Y+1	; 0x01
    108e:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1090:	27 96       	adiw	r28, 0x07	; 7
    1092:	0f b6       	in	r0, 0x3f	; 63
    1094:	f8 94       	cli
    1096:	de bf       	out	0x3e, r29	; 62
    1098:	0f be       	out	0x3f, r0	; 63
    109a:	cd bf       	out	0x3d, r28	; 61
    109c:	cf 91       	pop	r28
    109e:	df 91       	pop	r29
    10a0:	08 95       	ret

000010a2 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    10a2:	df 93       	push	r29
    10a4:	cf 93       	push	r28
    10a6:	cd b7       	in	r28, 0x3d	; 61
    10a8:	de b7       	in	r29, 0x3e	; 62
    10aa:	65 97       	sbiw	r28, 0x15	; 21
    10ac:	0f b6       	in	r0, 0x3f	; 63
    10ae:	f8 94       	cli
    10b0:	de bf       	out	0x3e, r29	; 62
    10b2:	0f be       	out	0x3f, r0	; 63
    10b4:	cd bf       	out	0x3d, r28	; 61
    10b6:	9b 8b       	std	Y+19, r25	; 0x13
    10b8:	8a 8b       	std	Y+18, r24	; 0x12
    10ba:	7d 8b       	std	Y+21, r23	; 0x15
    10bc:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    10be:	19 86       	std	Y+9, r1	; 0x09
    10c0:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    10c2:	8a 89       	ldd	r24, Y+18	; 0x12
    10c4:	9b 89       	ldd	r25, Y+19	; 0x13
    10c6:	9b 83       	std	Y+3, r25	; 0x03
    10c8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    10ca:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    10cc:	8a 81       	ldd	r24, Y+2	; 0x02
    10ce:	9b 81       	ldd	r25, Y+3	; 0x03
    10d0:	02 96       	adiw	r24, 0x02	; 2
    10d2:	9b 87       	std	Y+11, r25	; 0x0b
    10d4:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    10d6:	8a 85       	ldd	r24, Y+10	; 0x0a
    10d8:	9b 85       	ldd	r25, Y+11	; 0x0b
    10da:	03 96       	adiw	r24, 0x03	; 3
    10dc:	9d 87       	std	Y+13, r25	; 0x0d
    10de:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    10e0:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    10e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    10e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    10e8:	85 81       	ldd	r24, Z+5	; 0x05
    10ea:	96 81       	ldd	r25, Z+6	; 0x06
    10ec:	99 8b       	std	Y+17, r25	; 0x11
    10ee:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    10f0:	ea 81       	ldd	r30, Y+2	; 0x02
    10f2:	fb 81       	ldd	r31, Y+3	; 0x03
    10f4:	20 81       	ld	r18, Z
    10f6:	31 81       	ldd	r19, Z+1	; 0x01
    10f8:	8c 89       	ldd	r24, Y+20	; 0x14
    10fa:	9d 89       	ldd	r25, Y+21	; 0x15
    10fc:	82 2b       	or	r24, r18
    10fe:	93 2b       	or	r25, r19
    1100:	ea 81       	ldd	r30, Y+2	; 0x02
    1102:	fb 81       	ldd	r31, Y+3	; 0x03
    1104:	91 83       	std	Z+1, r25	; 0x01
    1106:	80 83       	st	Z, r24
    1108:	59 c0       	rjmp	.+178    	; 0x11bc <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    110a:	e8 89       	ldd	r30, Y+16	; 0x10
    110c:	f9 89       	ldd	r31, Y+17	; 0x11
    110e:	82 81       	ldd	r24, Z+2	; 0x02
    1110:	93 81       	ldd	r25, Z+3	; 0x03
    1112:	9f 87       	std	Y+15, r25	; 0x0f
    1114:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1116:	e8 89       	ldd	r30, Y+16	; 0x10
    1118:	f9 89       	ldd	r31, Y+17	; 0x11
    111a:	80 81       	ld	r24, Z
    111c:	91 81       	ldd	r25, Z+1	; 0x01
    111e:	9f 83       	std	Y+7, r25	; 0x07
    1120:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    1122:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1124:	8e 81       	ldd	r24, Y+6	; 0x06
    1126:	9f 81       	ldd	r25, Y+7	; 0x07
    1128:	80 70       	andi	r24, 0x00	; 0
    112a:	9d 83       	std	Y+5, r25	; 0x05
    112c:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    112e:	8e 81       	ldd	r24, Y+6	; 0x06
    1130:	9f 81       	ldd	r25, Y+7	; 0x07
    1132:	90 70       	andi	r25, 0x00	; 0
    1134:	9f 83       	std	Y+7, r25	; 0x07
    1136:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1138:	8c 81       	ldd	r24, Y+4	; 0x04
    113a:	9d 81       	ldd	r25, Y+5	; 0x05
    113c:	80 70       	andi	r24, 0x00	; 0
    113e:	94 70       	andi	r25, 0x04	; 4
    1140:	00 97       	sbiw	r24, 0x00	; 0
    1142:	69 f4       	brne	.+26     	; 0x115e <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1144:	ea 81       	ldd	r30, Y+2	; 0x02
    1146:	fb 81       	ldd	r31, Y+3	; 0x03
    1148:	20 81       	ld	r18, Z
    114a:	31 81       	ldd	r19, Z+1	; 0x01
    114c:	8e 81       	ldd	r24, Y+6	; 0x06
    114e:	9f 81       	ldd	r25, Y+7	; 0x07
    1150:	82 23       	and	r24, r18
    1152:	93 23       	and	r25, r19
    1154:	00 97       	sbiw	r24, 0x00	; 0
    1156:	91 f0       	breq	.+36     	; 0x117c <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    1158:	81 e0       	ldi	r24, 0x01	; 1
    115a:	89 83       	std	Y+1, r24	; 0x01
    115c:	0f c0       	rjmp	.+30     	; 0x117c <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    115e:	ea 81       	ldd	r30, Y+2	; 0x02
    1160:	fb 81       	ldd	r31, Y+3	; 0x03
    1162:	20 81       	ld	r18, Z
    1164:	31 81       	ldd	r19, Z+1	; 0x01
    1166:	8e 81       	ldd	r24, Y+6	; 0x06
    1168:	9f 81       	ldd	r25, Y+7	; 0x07
    116a:	28 23       	and	r18, r24
    116c:	39 23       	and	r19, r25
    116e:	8e 81       	ldd	r24, Y+6	; 0x06
    1170:	9f 81       	ldd	r25, Y+7	; 0x07
    1172:	28 17       	cp	r18, r24
    1174:	39 07       	cpc	r19, r25
    1176:	11 f4       	brne	.+4      	; 0x117c <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    1178:	81 e0       	ldi	r24, 0x01	; 1
    117a:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    117c:	89 81       	ldd	r24, Y+1	; 0x01
    117e:	88 23       	and	r24, r24
    1180:	c9 f0       	breq	.+50     	; 0x11b4 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1182:	8c 81       	ldd	r24, Y+4	; 0x04
    1184:	9d 81       	ldd	r25, Y+5	; 0x05
    1186:	80 70       	andi	r24, 0x00	; 0
    1188:	91 70       	andi	r25, 0x01	; 1
    118a:	00 97       	sbiw	r24, 0x00	; 0
    118c:	41 f0       	breq	.+16     	; 0x119e <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    118e:	88 85       	ldd	r24, Y+8	; 0x08
    1190:	99 85       	ldd	r25, Y+9	; 0x09
    1192:	2e 81       	ldd	r18, Y+6	; 0x06
    1194:	3f 81       	ldd	r19, Y+7	; 0x07
    1196:	82 2b       	or	r24, r18
    1198:	93 2b       	or	r25, r19
    119a:	99 87       	std	Y+9, r25	; 0x09
    119c:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    119e:	ea 81       	ldd	r30, Y+2	; 0x02
    11a0:	fb 81       	ldd	r31, Y+3	; 0x03
    11a2:	80 81       	ld	r24, Z
    11a4:	91 81       	ldd	r25, Z+1	; 0x01
    11a6:	9c 01       	movw	r18, r24
    11a8:	32 60       	ori	r19, 0x02	; 2
    11aa:	88 89       	ldd	r24, Y+16	; 0x10
    11ac:	99 89       	ldd	r25, Y+17	; 0x11
    11ae:	b9 01       	movw	r22, r18
    11b0:	0e 94 29 26 	call	0x4c52	; 0x4c52 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    11b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    11b6:	9f 85       	ldd	r25, Y+15	; 0x0f
    11b8:	99 8b       	std	Y+17, r25	; 0x11
    11ba:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    11bc:	28 89       	ldd	r18, Y+16	; 0x10
    11be:	39 89       	ldd	r19, Y+17	; 0x11
    11c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    11c2:	9d 85       	ldd	r25, Y+13	; 0x0d
    11c4:	28 17       	cp	r18, r24
    11c6:	39 07       	cpc	r19, r25
    11c8:	09 f0       	breq	.+2      	; 0x11cc <xEventGroupSetBits+0x12a>
    11ca:	9f cf       	rjmp	.-194    	; 0x110a <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    11cc:	ea 81       	ldd	r30, Y+2	; 0x02
    11ce:	fb 81       	ldd	r31, Y+3	; 0x03
    11d0:	20 81       	ld	r18, Z
    11d2:	31 81       	ldd	r19, Z+1	; 0x01
    11d4:	88 85       	ldd	r24, Y+8	; 0x08
    11d6:	99 85       	ldd	r25, Y+9	; 0x09
    11d8:	80 95       	com	r24
    11da:	90 95       	com	r25
    11dc:	82 23       	and	r24, r18
    11de:	93 23       	and	r25, r19
    11e0:	ea 81       	ldd	r30, Y+2	; 0x02
    11e2:	fb 81       	ldd	r31, Y+3	; 0x03
    11e4:	91 83       	std	Z+1, r25	; 0x01
    11e6:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    11e8:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    11ec:	ea 81       	ldd	r30, Y+2	; 0x02
    11ee:	fb 81       	ldd	r31, Y+3	; 0x03
    11f0:	80 81       	ld	r24, Z
    11f2:	91 81       	ldd	r25, Z+1	; 0x01
}
    11f4:	65 96       	adiw	r28, 0x15	; 21
    11f6:	0f b6       	in	r0, 0x3f	; 63
    11f8:	f8 94       	cli
    11fa:	de bf       	out	0x3e, r29	; 62
    11fc:	0f be       	out	0x3f, r0	; 63
    11fe:	cd bf       	out	0x3d, r28	; 61
    1200:	cf 91       	pop	r28
    1202:	df 91       	pop	r29
    1204:	08 95       	ret

00001206 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1206:	df 93       	push	r29
    1208:	cf 93       	push	r28
    120a:	00 d0       	rcall	.+0      	; 0x120c <vEventGroupDelete+0x6>
    120c:	00 d0       	rcall	.+0      	; 0x120e <vEventGroupDelete+0x8>
    120e:	00 d0       	rcall	.+0      	; 0x1210 <vEventGroupDelete+0xa>
    1210:	cd b7       	in	r28, 0x3d	; 61
    1212:	de b7       	in	r29, 0x3e	; 62
    1214:	9e 83       	std	Y+6, r25	; 0x06
    1216:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    1218:	8d 81       	ldd	r24, Y+5	; 0x05
    121a:	9e 81       	ldd	r25, Y+6	; 0x06
    121c:	9c 83       	std	Y+4, r25	; 0x04
    121e:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1220:	8b 81       	ldd	r24, Y+3	; 0x03
    1222:	9c 81       	ldd	r25, Y+4	; 0x04
    1224:	02 96       	adiw	r24, 0x02	; 2
    1226:	9a 83       	std	Y+2, r25	; 0x02
    1228:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    122a:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
    122e:	08 c0       	rjmp	.+16     	; 0x1240 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1230:	e9 81       	ldd	r30, Y+1	; 0x01
    1232:	fa 81       	ldd	r31, Y+2	; 0x02
    1234:	85 81       	ldd	r24, Z+5	; 0x05
    1236:	96 81       	ldd	r25, Z+6	; 0x06
    1238:	60 e0       	ldi	r22, 0x00	; 0
    123a:	72 e0       	ldi	r23, 0x02	; 2
    123c:	0e 94 29 26 	call	0x4c52	; 0x4c52 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1240:	e9 81       	ldd	r30, Y+1	; 0x01
    1242:	fa 81       	ldd	r31, Y+2	; 0x02
    1244:	80 81       	ld	r24, Z
    1246:	88 23       	and	r24, r24
    1248:	99 f7       	brne	.-26     	; 0x1230 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    124a:	8b 81       	ldd	r24, Y+3	; 0x03
    124c:	9c 81       	ldd	r25, Y+4	; 0x04
    124e:	0e 94 f6 09 	call	0x13ec	; 0x13ec <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    1252:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
}
    1256:	26 96       	adiw	r28, 0x06	; 6
    1258:	0f b6       	in	r0, 0x3f	; 63
    125a:	f8 94       	cli
    125c:	de bf       	out	0x3e, r29	; 62
    125e:	0f be       	out	0x3f, r0	; 63
    1260:	cd bf       	out	0x3d, r28	; 61
    1262:	cf 91       	pop	r28
    1264:	df 91       	pop	r29
    1266:	08 95       	ret

00001268 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    1268:	df 93       	push	r29
    126a:	cf 93       	push	r28
    126c:	00 d0       	rcall	.+0      	; 0x126e <vEventGroupSetBitsCallback+0x6>
    126e:	00 d0       	rcall	.+0      	; 0x1270 <vEventGroupSetBitsCallback+0x8>
    1270:	00 d0       	rcall	.+0      	; 0x1272 <vEventGroupSetBitsCallback+0xa>
    1272:	cd b7       	in	r28, 0x3d	; 61
    1274:	de b7       	in	r29, 0x3e	; 62
    1276:	9a 83       	std	Y+2, r25	; 0x02
    1278:	89 83       	std	Y+1, r24	; 0x01
    127a:	4b 83       	std	Y+3, r20	; 0x03
    127c:	5c 83       	std	Y+4, r21	; 0x04
    127e:	6d 83       	std	Y+5, r22	; 0x05
    1280:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1282:	89 81       	ldd	r24, Y+1	; 0x01
    1284:	9a 81       	ldd	r25, Y+2	; 0x02
    1286:	2b 81       	ldd	r18, Y+3	; 0x03
    1288:	3c 81       	ldd	r19, Y+4	; 0x04
    128a:	b9 01       	movw	r22, r18
    128c:	0e 94 51 08 	call	0x10a2	; 0x10a2 <xEventGroupSetBits>
}
    1290:	26 96       	adiw	r28, 0x06	; 6
    1292:	0f b6       	in	r0, 0x3f	; 63
    1294:	f8 94       	cli
    1296:	de bf       	out	0x3e, r29	; 62
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	cd bf       	out	0x3d, r28	; 61
    129c:	cf 91       	pop	r28
    129e:	df 91       	pop	r29
    12a0:	08 95       	ret

000012a2 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    12a2:	df 93       	push	r29
    12a4:	cf 93       	push	r28
    12a6:	00 d0       	rcall	.+0      	; 0x12a8 <vEventGroupClearBitsCallback+0x6>
    12a8:	00 d0       	rcall	.+0      	; 0x12aa <vEventGroupClearBitsCallback+0x8>
    12aa:	00 d0       	rcall	.+0      	; 0x12ac <vEventGroupClearBitsCallback+0xa>
    12ac:	cd b7       	in	r28, 0x3d	; 61
    12ae:	de b7       	in	r29, 0x3e	; 62
    12b0:	9a 83       	std	Y+2, r25	; 0x02
    12b2:	89 83       	std	Y+1, r24	; 0x01
    12b4:	4b 83       	std	Y+3, r20	; 0x03
    12b6:	5c 83       	std	Y+4, r21	; 0x04
    12b8:	6d 83       	std	Y+5, r22	; 0x05
    12ba:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    12bc:	89 81       	ldd	r24, Y+1	; 0x01
    12be:	9a 81       	ldd	r25, Y+2	; 0x02
    12c0:	2b 81       	ldd	r18, Y+3	; 0x03
    12c2:	3c 81       	ldd	r19, Y+4	; 0x04
    12c4:	b9 01       	movw	r22, r18
    12c6:	0e 94 f9 07 	call	0xff2	; 0xff2 <xEventGroupClearBits>
}
    12ca:	26 96       	adiw	r28, 0x06	; 6
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	f8 94       	cli
    12d0:	de bf       	out	0x3e, r29	; 62
    12d2:	0f be       	out	0x3f, r0	; 63
    12d4:	cd bf       	out	0x3d, r28	; 61
    12d6:	cf 91       	pop	r28
    12d8:	df 91       	pop	r29
    12da:	08 95       	ret

000012dc <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    12dc:	df 93       	push	r29
    12de:	cf 93       	push	r28
    12e0:	00 d0       	rcall	.+0      	; 0x12e2 <prvTestWaitCondition+0x6>
    12e2:	00 d0       	rcall	.+0      	; 0x12e4 <prvTestWaitCondition+0x8>
    12e4:	00 d0       	rcall	.+0      	; 0x12e6 <prvTestWaitCondition+0xa>
    12e6:	cd b7       	in	r28, 0x3d	; 61
    12e8:	de b7       	in	r29, 0x3e	; 62
    12ea:	9b 83       	std	Y+3, r25	; 0x03
    12ec:	8a 83       	std	Y+2, r24	; 0x02
    12ee:	7d 83       	std	Y+5, r23	; 0x05
    12f0:	6c 83       	std	Y+4, r22	; 0x04
    12f2:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    12f4:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    12f6:	8e 81       	ldd	r24, Y+6	; 0x06
    12f8:	88 23       	and	r24, r24
    12fa:	59 f4       	brne	.+22     	; 0x1312 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    12fc:	8a 81       	ldd	r24, Y+2	; 0x02
    12fe:	9b 81       	ldd	r25, Y+3	; 0x03
    1300:	2c 81       	ldd	r18, Y+4	; 0x04
    1302:	3d 81       	ldd	r19, Y+5	; 0x05
    1304:	82 23       	and	r24, r18
    1306:	93 23       	and	r25, r19
    1308:	00 97       	sbiw	r24, 0x00	; 0
    130a:	81 f0       	breq	.+32     	; 0x132c <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	89 83       	std	Y+1, r24	; 0x01
    1310:	0d c0       	rjmp	.+26     	; 0x132c <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1312:	2a 81       	ldd	r18, Y+2	; 0x02
    1314:	3b 81       	ldd	r19, Y+3	; 0x03
    1316:	8c 81       	ldd	r24, Y+4	; 0x04
    1318:	9d 81       	ldd	r25, Y+5	; 0x05
    131a:	28 23       	and	r18, r24
    131c:	39 23       	and	r19, r25
    131e:	8c 81       	ldd	r24, Y+4	; 0x04
    1320:	9d 81       	ldd	r25, Y+5	; 0x05
    1322:	28 17       	cp	r18, r24
    1324:	39 07       	cpc	r19, r25
    1326:	11 f4       	brne	.+4      	; 0x132c <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    132c:	89 81       	ldd	r24, Y+1	; 0x01
}
    132e:	26 96       	adiw	r28, 0x06	; 6
    1330:	0f b6       	in	r0, 0x3f	; 63
    1332:	f8 94       	cli
    1334:	de bf       	out	0x3e, r29	; 62
    1336:	0f be       	out	0x3f, r0	; 63
    1338:	cd bf       	out	0x3d, r28	; 61
    133a:	cf 91       	pop	r28
    133c:	df 91       	pop	r29
    133e:	08 95       	ret

00001340 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1340:	df 93       	push	r29
    1342:	cf 93       	push	r28
    1344:	00 d0       	rcall	.+0      	; 0x1346 <pvPortMalloc+0x6>
    1346:	00 d0       	rcall	.+0      	; 0x1348 <pvPortMalloc+0x8>
    1348:	cd b7       	in	r28, 0x3d	; 61
    134a:	de b7       	in	r29, 0x3e	; 62
    134c:	9c 83       	std	Y+4, r25	; 0x04
    134e:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    1350:	1a 82       	std	Y+2, r1	; 0x02
    1352:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1354:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1358:	80 91 f0 00 	lds	r24, 0x00F0
    135c:	90 91 f1 00 	lds	r25, 0x00F1
    1360:	00 97       	sbiw	r24, 0x00	; 0
    1362:	31 f4       	brne	.+12     	; 0x1370 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1364:	83 ef       	ldi	r24, 0xF3	; 243
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	90 93 f1 00 	sts	0x00F1, r25
    136c:	80 93 f0 00 	sts	0x00F0, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1370:	80 91 ee 00 	lds	r24, 0x00EE
    1374:	90 91 ef 00 	lds	r25, 0x00EF
    1378:	2b 81       	ldd	r18, Y+3	; 0x03
    137a:	3c 81       	ldd	r19, Y+4	; 0x04
    137c:	82 0f       	add	r24, r18
    137e:	93 1f       	adc	r25, r19
    1380:	25 e0       	ldi	r18, 0x05	; 5
    1382:	8b 3d       	cpi	r24, 0xDB	; 219
    1384:	92 07       	cpc	r25, r18
    1386:	38 f5       	brcc	.+78     	; 0x13d6 <pvPortMalloc+0x96>
    1388:	20 91 ee 00 	lds	r18, 0x00EE
    138c:	30 91 ef 00 	lds	r19, 0x00EF
    1390:	8b 81       	ldd	r24, Y+3	; 0x03
    1392:	9c 81       	ldd	r25, Y+4	; 0x04
    1394:	28 0f       	add	r18, r24
    1396:	39 1f       	adc	r19, r25
    1398:	80 91 ee 00 	lds	r24, 0x00EE
    139c:	90 91 ef 00 	lds	r25, 0x00EF
    13a0:	82 17       	cp	r24, r18
    13a2:	93 07       	cpc	r25, r19
    13a4:	c0 f4       	brcc	.+48     	; 0x13d6 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    13a6:	20 91 f0 00 	lds	r18, 0x00F0
    13aa:	30 91 f1 00 	lds	r19, 0x00F1
    13ae:	80 91 ee 00 	lds	r24, 0x00EE
    13b2:	90 91 ef 00 	lds	r25, 0x00EF
    13b6:	82 0f       	add	r24, r18
    13b8:	93 1f       	adc	r25, r19
    13ba:	9a 83       	std	Y+2, r25	; 0x02
    13bc:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    13be:	20 91 ee 00 	lds	r18, 0x00EE
    13c2:	30 91 ef 00 	lds	r19, 0x00EF
    13c6:	8b 81       	ldd	r24, Y+3	; 0x03
    13c8:	9c 81       	ldd	r25, Y+4	; 0x04
    13ca:	82 0f       	add	r24, r18
    13cc:	93 1f       	adc	r25, r19
    13ce:	90 93 ef 00 	sts	0x00EF, r25
    13d2:	80 93 ee 00 	sts	0x00EE, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    13d6:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    13da:	89 81       	ldd	r24, Y+1	; 0x01
    13dc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    13de:	0f 90       	pop	r0
    13e0:	0f 90       	pop	r0
    13e2:	0f 90       	pop	r0
    13e4:	0f 90       	pop	r0
    13e6:	cf 91       	pop	r28
    13e8:	df 91       	pop	r29
    13ea:	08 95       	ret

000013ec <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    13ec:	df 93       	push	r29
    13ee:	cf 93       	push	r28
    13f0:	00 d0       	rcall	.+0      	; 0x13f2 <vPortFree+0x6>
    13f2:	cd b7       	in	r28, 0x3d	; 61
    13f4:	de b7       	in	r29, 0x3e	; 62
    13f6:	9a 83       	std	Y+2, r25	; 0x02
    13f8:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	cf 91       	pop	r28
    1400:	df 91       	pop	r29
    1402:	08 95       	ret

00001404 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1404:	df 93       	push	r29
    1406:	cf 93       	push	r28
    1408:	cd b7       	in	r28, 0x3d	; 61
    140a:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    140c:	10 92 ef 00 	sts	0x00EF, r1
    1410:	10 92 ee 00 	sts	0x00EE, r1
}
    1414:	cf 91       	pop	r28
    1416:	df 91       	pop	r29
    1418:	08 95       	ret

0000141a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    141a:	df 93       	push	r29
    141c:	cf 93       	push	r28
    141e:	cd b7       	in	r28, 0x3d	; 61
    1420:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    1422:	20 91 ee 00 	lds	r18, 0x00EE
    1426:	30 91 ef 00 	lds	r19, 0x00EF
    142a:	8b ed       	ldi	r24, 0xDB	; 219
    142c:	95 e0       	ldi	r25, 0x05	; 5
    142e:	82 1b       	sub	r24, r18
    1430:	93 0b       	sbc	r25, r19
}
    1432:	cf 91       	pop	r28
    1434:	df 91       	pop	r29
    1436:	08 95       	ret

00001438 <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    1438:	df 93       	push	r29
    143a:	cf 93       	push	r28
    143c:	cd b7       	in	r28, 0x3d	; 61
    143e:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1440:	aa e3       	ldi	r26, 0x3A	; 58
    1442:	b0 e0       	ldi	r27, 0x00	; 0
    1444:	ea e3       	ldi	r30, 0x3A	; 58
    1446:	f0 e0       	ldi	r31, 0x00	; 0
    1448:	80 81       	ld	r24, Z
    144a:	8e 60       	ori	r24, 0x0E	; 14
    144c:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    144e:	aa e3       	ldi	r26, 0x3A	; 58
    1450:	b0 e0       	ldi	r27, 0x00	; 0
    1452:	ea e3       	ldi	r30, 0x3A	; 58
    1454:	f0 e0       	ldi	r31, 0x00	; 0
    1456:	80 81       	ld	r24, Z
    1458:	80 6f       	ori	r24, 0xF0	; 240
    145a:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    145c:	82 e0       	ldi	r24, 0x02	; 2
    145e:	0e 94 3d 0a 	call	0x147a	; 0x147a <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    1462:	88 e2       	ldi	r24, 0x28	; 40
    1464:	0e 94 3d 0a 	call	0x147a	; 0x147a <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    1468:	8c e0       	ldi	r24, 0x0C	; 12
    146a:	0e 94 3d 0a 	call	0x147a	; 0x147a <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    146e:	81 e0       	ldi	r24, 0x01	; 1
    1470:	0e 94 3d 0a 	call	0x147a	; 0x147a <LCD_sendCommand>

}
    1474:	cf 91       	pop	r28
    1476:	df 91       	pop	r29
    1478:	08 95       	ret

0000147a <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    147a:	df 93       	push	r29
    147c:	cf 93       	push	r28
    147e:	0f 92       	push	r0
    1480:	cd b7       	in	r28, 0x3d	; 61
    1482:	de b7       	in	r29, 0x3e	; 62
    1484:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    1486:	ab e3       	ldi	r26, 0x3B	; 59
    1488:	b0 e0       	ldi	r27, 0x00	; 0
    148a:	eb e3       	ldi	r30, 0x3B	; 59
    148c:	f0 e0       	ldi	r31, 0x00	; 0
    148e:	80 81       	ld	r24, Z
    1490:	8d 7f       	andi	r24, 0xFD	; 253
    1492:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    1494:	ab e3       	ldi	r26, 0x3B	; 59
    1496:	b0 e0       	ldi	r27, 0x00	; 0
    1498:	eb e3       	ldi	r30, 0x3B	; 59
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	80 81       	ld	r24, Z
    149e:	8b 7f       	andi	r24, 0xFB	; 251
    14a0:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    14a2:	81 e0       	ldi	r24, 0x01	; 1
    14a4:	90 e0       	ldi	r25, 0x00	; 0
    14a6:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    14aa:	ab e3       	ldi	r26, 0x3B	; 59
    14ac:	b0 e0       	ldi	r27, 0x00	; 0
    14ae:	eb e3       	ldi	r30, 0x3B	; 59
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	80 81       	ld	r24, Z
    14b4:	88 60       	ori	r24, 0x08	; 8
    14b6:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    14b8:	81 e0       	ldi	r24, 0x01	; 1
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    14c0:	ab e3       	ldi	r26, 0x3B	; 59
    14c2:	b0 e0       	ldi	r27, 0x00	; 0
    14c4:	eb e3       	ldi	r30, 0x3B	; 59
    14c6:	f0 e0       	ldi	r31, 0x00	; 0
    14c8:	80 81       	ld	r24, Z
    14ca:	98 2f       	mov	r25, r24
    14cc:	9f 70       	andi	r25, 0x0F	; 15
    14ce:	89 81       	ldd	r24, Y+1	; 0x01
    14d0:	80 7f       	andi	r24, 0xF0	; 240
    14d2:	89 2b       	or	r24, r25
    14d4:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	90 e0       	ldi	r25, 0x00	; 0
    14da:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    14de:	ab e3       	ldi	r26, 0x3B	; 59
    14e0:	b0 e0       	ldi	r27, 0x00	; 0
    14e2:	eb e3       	ldi	r30, 0x3B	; 59
    14e4:	f0 e0       	ldi	r31, 0x00	; 0
    14e6:	80 81       	ld	r24, Z
    14e8:	87 7f       	andi	r24, 0xF7	; 247
    14ea:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    14ec:	81 e0       	ldi	r24, 0x01	; 1
    14ee:	90 e0       	ldi	r25, 0x00	; 0
    14f0:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    14f4:	ab e3       	ldi	r26, 0x3B	; 59
    14f6:	b0 e0       	ldi	r27, 0x00	; 0
    14f8:	eb e3       	ldi	r30, 0x3B	; 59
    14fa:	f0 e0       	ldi	r31, 0x00	; 0
    14fc:	80 81       	ld	r24, Z
    14fe:	88 60       	ori	r24, 0x08	; 8
    1500:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1502:	81 e0       	ldi	r24, 0x01	; 1
    1504:	90 e0       	ldi	r25, 0x00	; 0
    1506:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    150a:	ab e3       	ldi	r26, 0x3B	; 59
    150c:	b0 e0       	ldi	r27, 0x00	; 0
    150e:	eb e3       	ldi	r30, 0x3B	; 59
    1510:	f0 e0       	ldi	r31, 0x00	; 0
    1512:	80 81       	ld	r24, Z
    1514:	28 2f       	mov	r18, r24
    1516:	2f 70       	andi	r18, 0x0F	; 15
    1518:	89 81       	ldd	r24, Y+1	; 0x01
    151a:	88 2f       	mov	r24, r24
    151c:	90 e0       	ldi	r25, 0x00	; 0
    151e:	82 95       	swap	r24
    1520:	92 95       	swap	r25
    1522:	90 7f       	andi	r25, 0xF0	; 240
    1524:	98 27       	eor	r25, r24
    1526:	80 7f       	andi	r24, 0xF0	; 240
    1528:	98 27       	eor	r25, r24
    152a:	82 2b       	or	r24, r18
    152c:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    152e:	81 e0       	ldi	r24, 0x01	; 1
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1536:	ab e3       	ldi	r26, 0x3B	; 59
    1538:	b0 e0       	ldi	r27, 0x00	; 0
    153a:	eb e3       	ldi	r30, 0x3B	; 59
    153c:	f0 e0       	ldi	r31, 0x00	; 0
    153e:	80 81       	ld	r24, Z
    1540:	87 7f       	andi	r24, 0xF7	; 247
    1542:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1544:	81 e0       	ldi	r24, 0x01	; 1
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    154c:	0f 90       	pop	r0
    154e:	cf 91       	pop	r28
    1550:	df 91       	pop	r29
    1552:	08 95       	ret

00001554 <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    1554:	df 93       	push	r29
    1556:	cf 93       	push	r28
    1558:	0f 92       	push	r0
    155a:	cd b7       	in	r28, 0x3d	; 61
    155c:	de b7       	in	r29, 0x3e	; 62
    155e:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    1560:	ab e3       	ldi	r26, 0x3B	; 59
    1562:	b0 e0       	ldi	r27, 0x00	; 0
    1564:	eb e3       	ldi	r30, 0x3B	; 59
    1566:	f0 e0       	ldi	r31, 0x00	; 0
    1568:	80 81       	ld	r24, Z
    156a:	82 60       	ori	r24, 0x02	; 2
    156c:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    156e:	ab e3       	ldi	r26, 0x3B	; 59
    1570:	b0 e0       	ldi	r27, 0x00	; 0
    1572:	eb e3       	ldi	r30, 0x3B	; 59
    1574:	f0 e0       	ldi	r31, 0x00	; 0
    1576:	80 81       	ld	r24, Z
    1578:	8b 7f       	andi	r24, 0xFB	; 251
    157a:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    1584:	ab e3       	ldi	r26, 0x3B	; 59
    1586:	b0 e0       	ldi	r27, 0x00	; 0
    1588:	eb e3       	ldi	r30, 0x3B	; 59
    158a:	f0 e0       	ldi	r31, 0x00	; 0
    158c:	80 81       	ld	r24, Z
    158e:	88 60       	ori	r24, 0x08	; 8
    1590:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	90 e0       	ldi	r25, 0x00	; 0
    1596:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    159a:	ab e3       	ldi	r26, 0x3B	; 59
    159c:	b0 e0       	ldi	r27, 0x00	; 0
    159e:	eb e3       	ldi	r30, 0x3B	; 59
    15a0:	f0 e0       	ldi	r31, 0x00	; 0
    15a2:	80 81       	ld	r24, Z
    15a4:	98 2f       	mov	r25, r24
    15a6:	9f 70       	andi	r25, 0x0F	; 15
    15a8:	89 81       	ldd	r24, Y+1	; 0x01
    15aa:	80 7f       	andi	r24, 0xF0	; 240
    15ac:	89 2b       	or	r24, r25
    15ae:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    15b8:	ab e3       	ldi	r26, 0x3B	; 59
    15ba:	b0 e0       	ldi	r27, 0x00	; 0
    15bc:	eb e3       	ldi	r30, 0x3B	; 59
    15be:	f0 e0       	ldi	r31, 0x00	; 0
    15c0:	80 81       	ld	r24, Z
    15c2:	87 7f       	andi	r24, 0xF7	; 247
    15c4:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    15ce:	ab e3       	ldi	r26, 0x3B	; 59
    15d0:	b0 e0       	ldi	r27, 0x00	; 0
    15d2:	eb e3       	ldi	r30, 0x3B	; 59
    15d4:	f0 e0       	ldi	r31, 0x00	; 0
    15d6:	80 81       	ld	r24, Z
    15d8:	88 60       	ori	r24, 0x08	; 8
    15da:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    15dc:	81 e0       	ldi	r24, 0x01	; 1
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    15e4:	ab e3       	ldi	r26, 0x3B	; 59
    15e6:	b0 e0       	ldi	r27, 0x00	; 0
    15e8:	eb e3       	ldi	r30, 0x3B	; 59
    15ea:	f0 e0       	ldi	r31, 0x00	; 0
    15ec:	80 81       	ld	r24, Z
    15ee:	28 2f       	mov	r18, r24
    15f0:	2f 70       	andi	r18, 0x0F	; 15
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	88 2f       	mov	r24, r24
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	82 95       	swap	r24
    15fa:	92 95       	swap	r25
    15fc:	90 7f       	andi	r25, 0xF0	; 240
    15fe:	98 27       	eor	r25, r24
    1600:	80 7f       	andi	r24, 0xF0	; 240
    1602:	98 27       	eor	r25, r24
    1604:	82 2b       	or	r24, r18
    1606:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1608:	81 e0       	ldi	r24, 0x01	; 1
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1610:	ab e3       	ldi	r26, 0x3B	; 59
    1612:	b0 e0       	ldi	r27, 0x00	; 0
    1614:	eb e3       	ldi	r30, 0x3B	; 59
    1616:	f0 e0       	ldi	r31, 0x00	; 0
    1618:	80 81       	ld	r24, Z
    161a:	87 7f       	andi	r24, 0xF7	; 247
    161c:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    161e:	81 e0       	ldi	r24, 0x01	; 1
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	0e 94 51 21 	call	0x42a2	; 0x42a2 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1626:	0f 90       	pop	r0
    1628:	cf 91       	pop	r28
    162a:	df 91       	pop	r29
    162c:	08 95       	ret

0000162e <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    162e:	df 93       	push	r29
    1630:	cf 93       	push	r28
    1632:	00 d0       	rcall	.+0      	; 0x1634 <LCD_displayString+0x6>
    1634:	0f 92       	push	r0
    1636:	cd b7       	in	r28, 0x3d	; 61
    1638:	de b7       	in	r29, 0x3e	; 62
    163a:	9b 83       	std	Y+3, r25	; 0x03
    163c:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    163e:	19 82       	std	Y+1, r1	; 0x01
    1640:	0e c0       	rjmp	.+28     	; 0x165e <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    1642:	89 81       	ldd	r24, Y+1	; 0x01
    1644:	28 2f       	mov	r18, r24
    1646:	30 e0       	ldi	r19, 0x00	; 0
    1648:	8a 81       	ldd	r24, Y+2	; 0x02
    164a:	9b 81       	ldd	r25, Y+3	; 0x03
    164c:	fc 01       	movw	r30, r24
    164e:	e2 0f       	add	r30, r18
    1650:	f3 1f       	adc	r31, r19
    1652:	80 81       	ld	r24, Z
    1654:	0e 94 aa 0a 	call	0x1554	; 0x1554 <LCD_displayCharacter>
		i++;
    1658:	89 81       	ldd	r24, Y+1	; 0x01
    165a:	8f 5f       	subi	r24, 0xFF	; 255
    165c:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	28 2f       	mov	r18, r24
    1662:	30 e0       	ldi	r19, 0x00	; 0
    1664:	8a 81       	ldd	r24, Y+2	; 0x02
    1666:	9b 81       	ldd	r25, Y+3	; 0x03
    1668:	fc 01       	movw	r30, r24
    166a:	e2 0f       	add	r30, r18
    166c:	f3 1f       	adc	r31, r19
    166e:	80 81       	ld	r24, Z
    1670:	88 23       	and	r24, r24
    1672:	39 f7       	brne	.-50     	; 0x1642 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    1674:	0f 90       	pop	r0
    1676:	0f 90       	pop	r0
    1678:	0f 90       	pop	r0
    167a:	cf 91       	pop	r28
    167c:	df 91       	pop	r29
    167e:	08 95       	ret

00001680 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    1680:	df 93       	push	r29
    1682:	cf 93       	push	r28
    1684:	00 d0       	rcall	.+0      	; 0x1686 <LCD_goToRowColumn+0x6>
    1686:	00 d0       	rcall	.+0      	; 0x1688 <LCD_goToRowColumn+0x8>
    1688:	0f 92       	push	r0
    168a:	cd b7       	in	r28, 0x3d	; 61
    168c:	de b7       	in	r29, 0x3e	; 62
    168e:	8a 83       	std	Y+2, r24	; 0x02
    1690:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    1692:	8a 81       	ldd	r24, Y+2	; 0x02
    1694:	28 2f       	mov	r18, r24
    1696:	30 e0       	ldi	r19, 0x00	; 0
    1698:	3d 83       	std	Y+5, r19	; 0x05
    169a:	2c 83       	std	Y+4, r18	; 0x04
    169c:	8c 81       	ldd	r24, Y+4	; 0x04
    169e:	9d 81       	ldd	r25, Y+5	; 0x05
    16a0:	81 30       	cpi	r24, 0x01	; 1
    16a2:	91 05       	cpc	r25, r1
    16a4:	c1 f0       	breq	.+48     	; 0x16d6 <LCD_goToRowColumn+0x56>
    16a6:	2c 81       	ldd	r18, Y+4	; 0x04
    16a8:	3d 81       	ldd	r19, Y+5	; 0x05
    16aa:	22 30       	cpi	r18, 0x02	; 2
    16ac:	31 05       	cpc	r19, r1
    16ae:	2c f4       	brge	.+10     	; 0x16ba <LCD_goToRowColumn+0x3a>
    16b0:	8c 81       	ldd	r24, Y+4	; 0x04
    16b2:	9d 81       	ldd	r25, Y+5	; 0x05
    16b4:	00 97       	sbiw	r24, 0x00	; 0
    16b6:	61 f0       	breq	.+24     	; 0x16d0 <LCD_goToRowColumn+0x50>
    16b8:	19 c0       	rjmp	.+50     	; 0x16ec <LCD_goToRowColumn+0x6c>
    16ba:	2c 81       	ldd	r18, Y+4	; 0x04
    16bc:	3d 81       	ldd	r19, Y+5	; 0x05
    16be:	22 30       	cpi	r18, 0x02	; 2
    16c0:	31 05       	cpc	r19, r1
    16c2:	69 f0       	breq	.+26     	; 0x16de <LCD_goToRowColumn+0x5e>
    16c4:	8c 81       	ldd	r24, Y+4	; 0x04
    16c6:	9d 81       	ldd	r25, Y+5	; 0x05
    16c8:	83 30       	cpi	r24, 0x03	; 3
    16ca:	91 05       	cpc	r25, r1
    16cc:	61 f0       	breq	.+24     	; 0x16e6 <LCD_goToRowColumn+0x66>
    16ce:	0e c0       	rjmp	.+28     	; 0x16ec <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    16d0:	8b 81       	ldd	r24, Y+3	; 0x03
    16d2:	89 83       	std	Y+1, r24	; 0x01
    16d4:	0b c0       	rjmp	.+22     	; 0x16ec <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    16d6:	8b 81       	ldd	r24, Y+3	; 0x03
    16d8:	80 5c       	subi	r24, 0xC0	; 192
    16da:	89 83       	std	Y+1, r24	; 0x01
    16dc:	07 c0       	rjmp	.+14     	; 0x16ec <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    16de:	8b 81       	ldd	r24, Y+3	; 0x03
    16e0:	80 5f       	subi	r24, 0xF0	; 240
    16e2:	89 83       	std	Y+1, r24	; 0x01
    16e4:	03 c0       	rjmp	.+6      	; 0x16ec <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    16e6:	8b 81       	ldd	r24, Y+3	; 0x03
    16e8:	80 5b       	subi	r24, 0xB0	; 176
    16ea:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    16ec:	89 81       	ldd	r24, Y+1	; 0x01
    16ee:	80 68       	ori	r24, 0x80	; 128
    16f0:	0e 94 3d 0a 	call	0x147a	; 0x147a <LCD_sendCommand>
}
    16f4:	0f 90       	pop	r0
    16f6:	0f 90       	pop	r0
    16f8:	0f 90       	pop	r0
    16fa:	0f 90       	pop	r0
    16fc:	0f 90       	pop	r0
    16fe:	cf 91       	pop	r28
    1700:	df 91       	pop	r29
    1702:	08 95       	ret

00001704 <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    1704:	df 93       	push	r29
    1706:	cf 93       	push	r28
    1708:	00 d0       	rcall	.+0      	; 0x170a <LCD_displayStringRowColumn+0x6>
    170a:	00 d0       	rcall	.+0      	; 0x170c <LCD_displayStringRowColumn+0x8>
    170c:	cd b7       	in	r28, 0x3d	; 61
    170e:	de b7       	in	r29, 0x3e	; 62
    1710:	89 83       	std	Y+1, r24	; 0x01
    1712:	6a 83       	std	Y+2, r22	; 0x02
    1714:	5c 83       	std	Y+4, r21	; 0x04
    1716:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    1718:	89 81       	ldd	r24, Y+1	; 0x01
    171a:	6a 81       	ldd	r22, Y+2	; 0x02
    171c:	0e 94 40 0b 	call	0x1680	; 0x1680 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1720:	8b 81       	ldd	r24, Y+3	; 0x03
    1722:	9c 81       	ldd	r25, Y+4	; 0x04
    1724:	0e 94 17 0b 	call	0x162e	; 0x162e <LCD_displayString>
}
    1728:	0f 90       	pop	r0
    172a:	0f 90       	pop	r0
    172c:	0f 90       	pop	r0
    172e:	0f 90       	pop	r0
    1730:	cf 91       	pop	r28
    1732:	df 91       	pop	r29
    1734:	08 95       	ret

00001736 <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    1736:	df 93       	push	r29
    1738:	cf 93       	push	r28
    173a:	cd b7       	in	r28, 0x3d	; 61
    173c:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    173e:	81 e0       	ldi	r24, 0x01	; 1
    1740:	0e 94 3d 0a 	call	0x147a	; 0x147a <LCD_sendCommand>
}
    1744:	cf 91       	pop	r28
    1746:	df 91       	pop	r29
    1748:	08 95       	ret

0000174a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    174a:	df 93       	push	r29
    174c:	cf 93       	push	r28
    174e:	00 d0       	rcall	.+0      	; 0x1750 <vListInitialise+0x6>
    1750:	cd b7       	in	r28, 0x3d	; 61
    1752:	de b7       	in	r29, 0x3e	; 62
    1754:	9a 83       	std	Y+2, r25	; 0x02
    1756:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1758:	89 81       	ldd	r24, Y+1	; 0x01
    175a:	9a 81       	ldd	r25, Y+2	; 0x02
    175c:	03 96       	adiw	r24, 0x03	; 3
    175e:	e9 81       	ldd	r30, Y+1	; 0x01
    1760:	fa 81       	ldd	r31, Y+2	; 0x02
    1762:	92 83       	std	Z+2, r25	; 0x02
    1764:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1766:	e9 81       	ldd	r30, Y+1	; 0x01
    1768:	fa 81       	ldd	r31, Y+2	; 0x02
    176a:	8f ef       	ldi	r24, 0xFF	; 255
    176c:	9f ef       	ldi	r25, 0xFF	; 255
    176e:	94 83       	std	Z+4, r25	; 0x04
    1770:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1772:	89 81       	ldd	r24, Y+1	; 0x01
    1774:	9a 81       	ldd	r25, Y+2	; 0x02
    1776:	03 96       	adiw	r24, 0x03	; 3
    1778:	e9 81       	ldd	r30, Y+1	; 0x01
    177a:	fa 81       	ldd	r31, Y+2	; 0x02
    177c:	96 83       	std	Z+6, r25	; 0x06
    177e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1780:	89 81       	ldd	r24, Y+1	; 0x01
    1782:	9a 81       	ldd	r25, Y+2	; 0x02
    1784:	03 96       	adiw	r24, 0x03	; 3
    1786:	e9 81       	ldd	r30, Y+1	; 0x01
    1788:	fa 81       	ldd	r31, Y+2	; 0x02
    178a:	90 87       	std	Z+8, r25	; 0x08
    178c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    178e:	e9 81       	ldd	r30, Y+1	; 0x01
    1790:	fa 81       	ldd	r31, Y+2	; 0x02
    1792:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1794:	0f 90       	pop	r0
    1796:	0f 90       	pop	r0
    1798:	cf 91       	pop	r28
    179a:	df 91       	pop	r29
    179c:	08 95       	ret

0000179e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    179e:	df 93       	push	r29
    17a0:	cf 93       	push	r28
    17a2:	00 d0       	rcall	.+0      	; 0x17a4 <vListInitialiseItem+0x6>
    17a4:	cd b7       	in	r28, 0x3d	; 61
    17a6:	de b7       	in	r29, 0x3e	; 62
    17a8:	9a 83       	std	Y+2, r25	; 0x02
    17aa:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    17ac:	e9 81       	ldd	r30, Y+1	; 0x01
    17ae:	fa 81       	ldd	r31, Y+2	; 0x02
    17b0:	11 86       	std	Z+9, r1	; 0x09
    17b2:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    17b4:	0f 90       	pop	r0
    17b6:	0f 90       	pop	r0
    17b8:	cf 91       	pop	r28
    17ba:	df 91       	pop	r29
    17bc:	08 95       	ret

000017be <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    17be:	df 93       	push	r29
    17c0:	cf 93       	push	r28
    17c2:	00 d0       	rcall	.+0      	; 0x17c4 <vListInsertEnd+0x6>
    17c4:	00 d0       	rcall	.+0      	; 0x17c6 <vListInsertEnd+0x8>
    17c6:	00 d0       	rcall	.+0      	; 0x17c8 <vListInsertEnd+0xa>
    17c8:	cd b7       	in	r28, 0x3d	; 61
    17ca:	de b7       	in	r29, 0x3e	; 62
    17cc:	9c 83       	std	Y+4, r25	; 0x04
    17ce:	8b 83       	std	Y+3, r24	; 0x03
    17d0:	7e 83       	std	Y+6, r23	; 0x06
    17d2:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    17d4:	eb 81       	ldd	r30, Y+3	; 0x03
    17d6:	fc 81       	ldd	r31, Y+4	; 0x04
    17d8:	81 81       	ldd	r24, Z+1	; 0x01
    17da:	92 81       	ldd	r25, Z+2	; 0x02
    17dc:	9a 83       	std	Y+2, r25	; 0x02
    17de:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    17e0:	ed 81       	ldd	r30, Y+5	; 0x05
    17e2:	fe 81       	ldd	r31, Y+6	; 0x06
    17e4:	89 81       	ldd	r24, Y+1	; 0x01
    17e6:	9a 81       	ldd	r25, Y+2	; 0x02
    17e8:	93 83       	std	Z+3, r25	; 0x03
    17ea:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    17ec:	e9 81       	ldd	r30, Y+1	; 0x01
    17ee:	fa 81       	ldd	r31, Y+2	; 0x02
    17f0:	84 81       	ldd	r24, Z+4	; 0x04
    17f2:	95 81       	ldd	r25, Z+5	; 0x05
    17f4:	ed 81       	ldd	r30, Y+5	; 0x05
    17f6:	fe 81       	ldd	r31, Y+6	; 0x06
    17f8:	95 83       	std	Z+5, r25	; 0x05
    17fa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    17fc:	e9 81       	ldd	r30, Y+1	; 0x01
    17fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1800:	04 80       	ldd	r0, Z+4	; 0x04
    1802:	f5 81       	ldd	r31, Z+5	; 0x05
    1804:	e0 2d       	mov	r30, r0
    1806:	8d 81       	ldd	r24, Y+5	; 0x05
    1808:	9e 81       	ldd	r25, Y+6	; 0x06
    180a:	93 83       	std	Z+3, r25	; 0x03
    180c:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    180e:	e9 81       	ldd	r30, Y+1	; 0x01
    1810:	fa 81       	ldd	r31, Y+2	; 0x02
    1812:	8d 81       	ldd	r24, Y+5	; 0x05
    1814:	9e 81       	ldd	r25, Y+6	; 0x06
    1816:	95 83       	std	Z+5, r25	; 0x05
    1818:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    181a:	ed 81       	ldd	r30, Y+5	; 0x05
    181c:	fe 81       	ldd	r31, Y+6	; 0x06
    181e:	8b 81       	ldd	r24, Y+3	; 0x03
    1820:	9c 81       	ldd	r25, Y+4	; 0x04
    1822:	91 87       	std	Z+9, r25	; 0x09
    1824:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1826:	eb 81       	ldd	r30, Y+3	; 0x03
    1828:	fc 81       	ldd	r31, Y+4	; 0x04
    182a:	80 81       	ld	r24, Z
    182c:	8f 5f       	subi	r24, 0xFF	; 255
    182e:	eb 81       	ldd	r30, Y+3	; 0x03
    1830:	fc 81       	ldd	r31, Y+4	; 0x04
    1832:	80 83       	st	Z, r24
}
    1834:	26 96       	adiw	r28, 0x06	; 6
    1836:	0f b6       	in	r0, 0x3f	; 63
    1838:	f8 94       	cli
    183a:	de bf       	out	0x3e, r29	; 62
    183c:	0f be       	out	0x3f, r0	; 63
    183e:	cd bf       	out	0x3d, r28	; 61
    1840:	cf 91       	pop	r28
    1842:	df 91       	pop	r29
    1844:	08 95       	ret

00001846 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1846:	df 93       	push	r29
    1848:	cf 93       	push	r28
    184a:	cd b7       	in	r28, 0x3d	; 61
    184c:	de b7       	in	r29, 0x3e	; 62
    184e:	28 97       	sbiw	r28, 0x08	; 8
    1850:	0f b6       	in	r0, 0x3f	; 63
    1852:	f8 94       	cli
    1854:	de bf       	out	0x3e, r29	; 62
    1856:	0f be       	out	0x3f, r0	; 63
    1858:	cd bf       	out	0x3d, r28	; 61
    185a:	9e 83       	std	Y+6, r25	; 0x06
    185c:	8d 83       	std	Y+5, r24	; 0x05
    185e:	78 87       	std	Y+8, r23	; 0x08
    1860:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1862:	ef 81       	ldd	r30, Y+7	; 0x07
    1864:	f8 85       	ldd	r31, Y+8	; 0x08
    1866:	80 81       	ld	r24, Z
    1868:	91 81       	ldd	r25, Z+1	; 0x01
    186a:	9a 83       	std	Y+2, r25	; 0x02
    186c:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    186e:	89 81       	ldd	r24, Y+1	; 0x01
    1870:	9a 81       	ldd	r25, Y+2	; 0x02
    1872:	2f ef       	ldi	r18, 0xFF	; 255
    1874:	8f 3f       	cpi	r24, 0xFF	; 255
    1876:	92 07       	cpc	r25, r18
    1878:	39 f4       	brne	.+14     	; 0x1888 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    187a:	ed 81       	ldd	r30, Y+5	; 0x05
    187c:	fe 81       	ldd	r31, Y+6	; 0x06
    187e:	87 81       	ldd	r24, Z+7	; 0x07
    1880:	90 85       	ldd	r25, Z+8	; 0x08
    1882:	9c 83       	std	Y+4, r25	; 0x04
    1884:	8b 83       	std	Y+3, r24	; 0x03
    1886:	18 c0       	rjmp	.+48     	; 0x18b8 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1888:	8d 81       	ldd	r24, Y+5	; 0x05
    188a:	9e 81       	ldd	r25, Y+6	; 0x06
    188c:	03 96       	adiw	r24, 0x03	; 3
    188e:	9c 83       	std	Y+4, r25	; 0x04
    1890:	8b 83       	std	Y+3, r24	; 0x03
    1892:	06 c0       	rjmp	.+12     	; 0x18a0 <vListInsert+0x5a>
    1894:	eb 81       	ldd	r30, Y+3	; 0x03
    1896:	fc 81       	ldd	r31, Y+4	; 0x04
    1898:	82 81       	ldd	r24, Z+2	; 0x02
    189a:	93 81       	ldd	r25, Z+3	; 0x03
    189c:	9c 83       	std	Y+4, r25	; 0x04
    189e:	8b 83       	std	Y+3, r24	; 0x03
    18a0:	eb 81       	ldd	r30, Y+3	; 0x03
    18a2:	fc 81       	ldd	r31, Y+4	; 0x04
    18a4:	02 80       	ldd	r0, Z+2	; 0x02
    18a6:	f3 81       	ldd	r31, Z+3	; 0x03
    18a8:	e0 2d       	mov	r30, r0
    18aa:	20 81       	ld	r18, Z
    18ac:	31 81       	ldd	r19, Z+1	; 0x01
    18ae:	89 81       	ldd	r24, Y+1	; 0x01
    18b0:	9a 81       	ldd	r25, Y+2	; 0x02
    18b2:	82 17       	cp	r24, r18
    18b4:	93 07       	cpc	r25, r19
    18b6:	70 f7       	brcc	.-36     	; 0x1894 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    18b8:	eb 81       	ldd	r30, Y+3	; 0x03
    18ba:	fc 81       	ldd	r31, Y+4	; 0x04
    18bc:	82 81       	ldd	r24, Z+2	; 0x02
    18be:	93 81       	ldd	r25, Z+3	; 0x03
    18c0:	ef 81       	ldd	r30, Y+7	; 0x07
    18c2:	f8 85       	ldd	r31, Y+8	; 0x08
    18c4:	93 83       	std	Z+3, r25	; 0x03
    18c6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    18c8:	ef 81       	ldd	r30, Y+7	; 0x07
    18ca:	f8 85       	ldd	r31, Y+8	; 0x08
    18cc:	02 80       	ldd	r0, Z+2	; 0x02
    18ce:	f3 81       	ldd	r31, Z+3	; 0x03
    18d0:	e0 2d       	mov	r30, r0
    18d2:	8f 81       	ldd	r24, Y+7	; 0x07
    18d4:	98 85       	ldd	r25, Y+8	; 0x08
    18d6:	95 83       	std	Z+5, r25	; 0x05
    18d8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    18da:	ef 81       	ldd	r30, Y+7	; 0x07
    18dc:	f8 85       	ldd	r31, Y+8	; 0x08
    18de:	8b 81       	ldd	r24, Y+3	; 0x03
    18e0:	9c 81       	ldd	r25, Y+4	; 0x04
    18e2:	95 83       	std	Z+5, r25	; 0x05
    18e4:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    18e6:	eb 81       	ldd	r30, Y+3	; 0x03
    18e8:	fc 81       	ldd	r31, Y+4	; 0x04
    18ea:	8f 81       	ldd	r24, Y+7	; 0x07
    18ec:	98 85       	ldd	r25, Y+8	; 0x08
    18ee:	93 83       	std	Z+3, r25	; 0x03
    18f0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    18f2:	ef 81       	ldd	r30, Y+7	; 0x07
    18f4:	f8 85       	ldd	r31, Y+8	; 0x08
    18f6:	8d 81       	ldd	r24, Y+5	; 0x05
    18f8:	9e 81       	ldd	r25, Y+6	; 0x06
    18fa:	91 87       	std	Z+9, r25	; 0x09
    18fc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    18fe:	ed 81       	ldd	r30, Y+5	; 0x05
    1900:	fe 81       	ldd	r31, Y+6	; 0x06
    1902:	80 81       	ld	r24, Z
    1904:	8f 5f       	subi	r24, 0xFF	; 255
    1906:	ed 81       	ldd	r30, Y+5	; 0x05
    1908:	fe 81       	ldd	r31, Y+6	; 0x06
    190a:	80 83       	st	Z, r24
}
    190c:	28 96       	adiw	r28, 0x08	; 8
    190e:	0f b6       	in	r0, 0x3f	; 63
    1910:	f8 94       	cli
    1912:	de bf       	out	0x3e, r29	; 62
    1914:	0f be       	out	0x3f, r0	; 63
    1916:	cd bf       	out	0x3d, r28	; 61
    1918:	cf 91       	pop	r28
    191a:	df 91       	pop	r29
    191c:	08 95       	ret

0000191e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    191e:	df 93       	push	r29
    1920:	cf 93       	push	r28
    1922:	00 d0       	rcall	.+0      	; 0x1924 <uxListRemove+0x6>
    1924:	00 d0       	rcall	.+0      	; 0x1926 <uxListRemove+0x8>
    1926:	cd b7       	in	r28, 0x3d	; 61
    1928:	de b7       	in	r29, 0x3e	; 62
    192a:	9c 83       	std	Y+4, r25	; 0x04
    192c:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    192e:	eb 81       	ldd	r30, Y+3	; 0x03
    1930:	fc 81       	ldd	r31, Y+4	; 0x04
    1932:	80 85       	ldd	r24, Z+8	; 0x08
    1934:	91 85       	ldd	r25, Z+9	; 0x09
    1936:	9a 83       	std	Y+2, r25	; 0x02
    1938:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    193a:	eb 81       	ldd	r30, Y+3	; 0x03
    193c:	fc 81       	ldd	r31, Y+4	; 0x04
    193e:	a2 81       	ldd	r26, Z+2	; 0x02
    1940:	b3 81       	ldd	r27, Z+3	; 0x03
    1942:	eb 81       	ldd	r30, Y+3	; 0x03
    1944:	fc 81       	ldd	r31, Y+4	; 0x04
    1946:	84 81       	ldd	r24, Z+4	; 0x04
    1948:	95 81       	ldd	r25, Z+5	; 0x05
    194a:	15 96       	adiw	r26, 0x05	; 5
    194c:	9c 93       	st	X, r25
    194e:	8e 93       	st	-X, r24
    1950:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1952:	eb 81       	ldd	r30, Y+3	; 0x03
    1954:	fc 81       	ldd	r31, Y+4	; 0x04
    1956:	a4 81       	ldd	r26, Z+4	; 0x04
    1958:	b5 81       	ldd	r27, Z+5	; 0x05
    195a:	eb 81       	ldd	r30, Y+3	; 0x03
    195c:	fc 81       	ldd	r31, Y+4	; 0x04
    195e:	82 81       	ldd	r24, Z+2	; 0x02
    1960:	93 81       	ldd	r25, Z+3	; 0x03
    1962:	13 96       	adiw	r26, 0x03	; 3
    1964:	9c 93       	st	X, r25
    1966:	8e 93       	st	-X, r24
    1968:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    196a:	e9 81       	ldd	r30, Y+1	; 0x01
    196c:	fa 81       	ldd	r31, Y+2	; 0x02
    196e:	21 81       	ldd	r18, Z+1	; 0x01
    1970:	32 81       	ldd	r19, Z+2	; 0x02
    1972:	8b 81       	ldd	r24, Y+3	; 0x03
    1974:	9c 81       	ldd	r25, Y+4	; 0x04
    1976:	28 17       	cp	r18, r24
    1978:	39 07       	cpc	r19, r25
    197a:	41 f4       	brne	.+16     	; 0x198c <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    197c:	eb 81       	ldd	r30, Y+3	; 0x03
    197e:	fc 81       	ldd	r31, Y+4	; 0x04
    1980:	84 81       	ldd	r24, Z+4	; 0x04
    1982:	95 81       	ldd	r25, Z+5	; 0x05
    1984:	e9 81       	ldd	r30, Y+1	; 0x01
    1986:	fa 81       	ldd	r31, Y+2	; 0x02
    1988:	92 83       	std	Z+2, r25	; 0x02
    198a:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    198c:	eb 81       	ldd	r30, Y+3	; 0x03
    198e:	fc 81       	ldd	r31, Y+4	; 0x04
    1990:	11 86       	std	Z+9, r1	; 0x09
    1992:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1994:	e9 81       	ldd	r30, Y+1	; 0x01
    1996:	fa 81       	ldd	r31, Y+2	; 0x02
    1998:	80 81       	ld	r24, Z
    199a:	81 50       	subi	r24, 0x01	; 1
    199c:	e9 81       	ldd	r30, Y+1	; 0x01
    199e:	fa 81       	ldd	r31, Y+2	; 0x02
    19a0:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    19a2:	e9 81       	ldd	r30, Y+1	; 0x01
    19a4:	fa 81       	ldd	r31, Y+2	; 0x02
    19a6:	80 81       	ld	r24, Z
}
    19a8:	0f 90       	pop	r0
    19aa:	0f 90       	pop	r0
    19ac:	0f 90       	pop	r0
    19ae:	0f 90       	pop	r0
    19b0:	cf 91       	pop	r28
    19b2:	df 91       	pop	r29
    19b4:	08 95       	ret

000019b6 <main>:

#include "UserTasks.h"


void main(void)
{
    19b6:	ef 92       	push	r14
    19b8:	ff 92       	push	r15
    19ba:	0f 93       	push	r16
    19bc:	df 93       	push	r29
    19be:	cf 93       	push	r28
    19c0:	cd b7       	in	r28, 0x3d	; 61
    19c2:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(init_Task  , "Init_Task" , configMINIMAL_STACK_SIZE ,
    19c4:	83 ec       	ldi	r24, 0xC3	; 195
    19c6:	92 e0       	ldi	r25, 0x02	; 2
    19c8:	27 ed       	ldi	r18, 0xD7	; 215
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	e8 ee       	ldi	r30, 0xE8	; 232
    19ce:	f0 e0       	ldi	r31, 0x00	; 0
    19d0:	b9 01       	movw	r22, r18
    19d2:	46 e9       	ldi	r20, 0x96	; 150
    19d4:	50 e0       	ldi	r21, 0x00	; 0
    19d6:	20 e0       	ldi	r18, 0x00	; 0
    19d8:	30 e0       	ldi	r19, 0x00	; 0
    19da:	05 e0       	ldi	r16, 0x05	; 5
    19dc:	7f 01       	movw	r14, r30
    19de:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <xTaskCreate>
			NULL , (5 | portPRIVILEGE_BIT) , &InitTask_Flag);

	/* Start Scheduler */
	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
    19e2:	8c e0       	ldi	r24, 0x0C	; 12
    19e4:	61 e0       	ldi	r22, 0x01	; 1
    19e6:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	vTaskStartScheduler();
    19ea:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <vTaskStartScheduler>
    19ee:	ff cf       	rjmp	.-2      	; 0x19ee <main+0x38>

000019f0 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    19f0:	df 93       	push	r29
    19f2:	cf 93       	push	r28
    19f4:	cd b7       	in	r28, 0x3d	; 61
    19f6:	de b7       	in	r29, 0x3e	; 62
    19f8:	28 97       	sbiw	r28, 0x08	; 8
    19fa:	0f b6       	in	r0, 0x3f	; 63
    19fc:	f8 94       	cli
    19fe:	de bf       	out	0x3e, r29	; 62
    1a00:	0f be       	out	0x3f, r0	; 63
    1a02:	cd bf       	out	0x3d, r28	; 61
    1a04:	9c 83       	std	Y+4, r25	; 0x04
    1a06:	8b 83       	std	Y+3, r24	; 0x03
    1a08:	7e 83       	std	Y+6, r23	; 0x06
    1a0a:	6d 83       	std	Y+5, r22	; 0x05
    1a0c:	58 87       	std	Y+8, r21	; 0x08
    1a0e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1a10:	eb 81       	ldd	r30, Y+3	; 0x03
    1a12:	fc 81       	ldd	r31, Y+4	; 0x04
    1a14:	81 e1       	ldi	r24, 0x11	; 17
    1a16:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a18:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a1c:	01 97       	sbiw	r24, 0x01	; 1
    1a1e:	9c 83       	std	Y+4, r25	; 0x04
    1a20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1a22:	eb 81       	ldd	r30, Y+3	; 0x03
    1a24:	fc 81       	ldd	r31, Y+4	; 0x04
    1a26:	82 e2       	ldi	r24, 0x22	; 34
    1a28:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a2e:	01 97       	sbiw	r24, 0x01	; 1
    1a30:	9c 83       	std	Y+4, r25	; 0x04
    1a32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1a34:	eb 81       	ldd	r30, Y+3	; 0x03
    1a36:	fc 81       	ldd	r31, Y+4	; 0x04
    1a38:	83 e3       	ldi	r24, 0x33	; 51
    1a3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a40:	01 97       	sbiw	r24, 0x01	; 1
    1a42:	9c 83       	std	Y+4, r25	; 0x04
    1a44:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1a46:	8d 81       	ldd	r24, Y+5	; 0x05
    1a48:	9e 81       	ldd	r25, Y+6	; 0x06
    1a4a:	9a 83       	std	Y+2, r25	; 0x02
    1a4c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1a4e:	89 81       	ldd	r24, Y+1	; 0x01
    1a50:	eb 81       	ldd	r30, Y+3	; 0x03
    1a52:	fc 81       	ldd	r31, Y+4	; 0x04
    1a54:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a56:	8b 81       	ldd	r24, Y+3	; 0x03
    1a58:	9c 81       	ldd	r25, Y+4	; 0x04
    1a5a:	01 97       	sbiw	r24, 0x01	; 1
    1a5c:	9c 83       	std	Y+4, r25	; 0x04
    1a5e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1a60:	89 81       	ldd	r24, Y+1	; 0x01
    1a62:	9a 81       	ldd	r25, Y+2	; 0x02
    1a64:	89 2f       	mov	r24, r25
    1a66:	99 27       	eor	r25, r25
    1a68:	9a 83       	std	Y+2, r25	; 0x02
    1a6a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1a6c:	89 81       	ldd	r24, Y+1	; 0x01
    1a6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a70:	fc 81       	ldd	r31, Y+4	; 0x04
    1a72:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a74:	8b 81       	ldd	r24, Y+3	; 0x03
    1a76:	9c 81       	ldd	r25, Y+4	; 0x04
    1a78:	01 97       	sbiw	r24, 0x01	; 1
    1a7a:	9c 83       	std	Y+4, r25	; 0x04
    1a7c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1a7e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a80:	fc 81       	ldd	r31, Y+4	; 0x04
    1a82:	10 82       	st	Z, r1
	pxTopOfStack--;
    1a84:	8b 81       	ldd	r24, Y+3	; 0x03
    1a86:	9c 81       	ldd	r25, Y+4	; 0x04
    1a88:	01 97       	sbiw	r24, 0x01	; 1
    1a8a:	9c 83       	std	Y+4, r25	; 0x04
    1a8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a90:	fc 81       	ldd	r31, Y+4	; 0x04
    1a92:	80 e8       	ldi	r24, 0x80	; 128
    1a94:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a96:	8b 81       	ldd	r24, Y+3	; 0x03
    1a98:	9c 81       	ldd	r25, Y+4	; 0x04
    1a9a:	01 97       	sbiw	r24, 0x01	; 1
    1a9c:	9c 83       	std	Y+4, r25	; 0x04
    1a9e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1aa0:	eb 81       	ldd	r30, Y+3	; 0x03
    1aa2:	fc 81       	ldd	r31, Y+4	; 0x04
    1aa4:	10 82       	st	Z, r1
	pxTopOfStack--;
    1aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aaa:	01 97       	sbiw	r24, 0x01	; 1
    1aac:	9c 83       	std	Y+4, r25	; 0x04
    1aae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1ab0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ab2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ab4:	82 e0       	ldi	r24, 0x02	; 2
    1ab6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aba:	9c 81       	ldd	r25, Y+4	; 0x04
    1abc:	01 97       	sbiw	r24, 0x01	; 1
    1abe:	9c 83       	std	Y+4, r25	; 0x04
    1ac0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1ac2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ac4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ac6:	83 e0       	ldi	r24, 0x03	; 3
    1ac8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1aca:	8b 81       	ldd	r24, Y+3	; 0x03
    1acc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ace:	01 97       	sbiw	r24, 0x01	; 1
    1ad0:	9c 83       	std	Y+4, r25	; 0x04
    1ad2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1ad4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad8:	84 e0       	ldi	r24, 0x04	; 4
    1ada:	80 83       	st	Z, r24
	pxTopOfStack--;
    1adc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ade:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae0:	01 97       	sbiw	r24, 0x01	; 1
    1ae2:	9c 83       	std	Y+4, r25	; 0x04
    1ae4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1ae6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ae8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aea:	85 e0       	ldi	r24, 0x05	; 5
    1aec:	80 83       	st	Z, r24
	pxTopOfStack--;
    1aee:	8b 81       	ldd	r24, Y+3	; 0x03
    1af0:	9c 81       	ldd	r25, Y+4	; 0x04
    1af2:	01 97       	sbiw	r24, 0x01	; 1
    1af4:	9c 83       	std	Y+4, r25	; 0x04
    1af6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1af8:	eb 81       	ldd	r30, Y+3	; 0x03
    1afa:	fc 81       	ldd	r31, Y+4	; 0x04
    1afc:	86 e0       	ldi	r24, 0x06	; 6
    1afe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b00:	8b 81       	ldd	r24, Y+3	; 0x03
    1b02:	9c 81       	ldd	r25, Y+4	; 0x04
    1b04:	01 97       	sbiw	r24, 0x01	; 1
    1b06:	9c 83       	std	Y+4, r25	; 0x04
    1b08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1b0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b0e:	87 e0       	ldi	r24, 0x07	; 7
    1b10:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b12:	8b 81       	ldd	r24, Y+3	; 0x03
    1b14:	9c 81       	ldd	r25, Y+4	; 0x04
    1b16:	01 97       	sbiw	r24, 0x01	; 1
    1b18:	9c 83       	std	Y+4, r25	; 0x04
    1b1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1b1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b20:	88 e0       	ldi	r24, 0x08	; 8
    1b22:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b24:	8b 81       	ldd	r24, Y+3	; 0x03
    1b26:	9c 81       	ldd	r25, Y+4	; 0x04
    1b28:	01 97       	sbiw	r24, 0x01	; 1
    1b2a:	9c 83       	std	Y+4, r25	; 0x04
    1b2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1b2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1b30:	fc 81       	ldd	r31, Y+4	; 0x04
    1b32:	89 e0       	ldi	r24, 0x09	; 9
    1b34:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b36:	8b 81       	ldd	r24, Y+3	; 0x03
    1b38:	9c 81       	ldd	r25, Y+4	; 0x04
    1b3a:	01 97       	sbiw	r24, 0x01	; 1
    1b3c:	9c 83       	std	Y+4, r25	; 0x04
    1b3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1b40:	eb 81       	ldd	r30, Y+3	; 0x03
    1b42:	fc 81       	ldd	r31, Y+4	; 0x04
    1b44:	80 e1       	ldi	r24, 0x10	; 16
    1b46:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b48:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4c:	01 97       	sbiw	r24, 0x01	; 1
    1b4e:	9c 83       	std	Y+4, r25	; 0x04
    1b50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1b52:	eb 81       	ldd	r30, Y+3	; 0x03
    1b54:	fc 81       	ldd	r31, Y+4	; 0x04
    1b56:	81 e1       	ldi	r24, 0x11	; 17
    1b58:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5e:	01 97       	sbiw	r24, 0x01	; 1
    1b60:	9c 83       	std	Y+4, r25	; 0x04
    1b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1b64:	eb 81       	ldd	r30, Y+3	; 0x03
    1b66:	fc 81       	ldd	r31, Y+4	; 0x04
    1b68:	82 e1       	ldi	r24, 0x12	; 18
    1b6a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b70:	01 97       	sbiw	r24, 0x01	; 1
    1b72:	9c 83       	std	Y+4, r25	; 0x04
    1b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1b76:	eb 81       	ldd	r30, Y+3	; 0x03
    1b78:	fc 81       	ldd	r31, Y+4	; 0x04
    1b7a:	83 e1       	ldi	r24, 0x13	; 19
    1b7c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b80:	9c 81       	ldd	r25, Y+4	; 0x04
    1b82:	01 97       	sbiw	r24, 0x01	; 1
    1b84:	9c 83       	std	Y+4, r25	; 0x04
    1b86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1b88:	eb 81       	ldd	r30, Y+3	; 0x03
    1b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b8c:	84 e1       	ldi	r24, 0x14	; 20
    1b8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1b90:	8b 81       	ldd	r24, Y+3	; 0x03
    1b92:	9c 81       	ldd	r25, Y+4	; 0x04
    1b94:	01 97       	sbiw	r24, 0x01	; 1
    1b96:	9c 83       	std	Y+4, r25	; 0x04
    1b98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b9e:	85 e1       	ldi	r24, 0x15	; 21
    1ba0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba6:	01 97       	sbiw	r24, 0x01	; 1
    1ba8:	9c 83       	std	Y+4, r25	; 0x04
    1baa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1bac:	eb 81       	ldd	r30, Y+3	; 0x03
    1bae:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb0:	86 e1       	ldi	r24, 0x16	; 22
    1bb2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bb6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bb8:	01 97       	sbiw	r24, 0x01	; 1
    1bba:	9c 83       	std	Y+4, r25	; 0x04
    1bbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1bbe:	eb 81       	ldd	r30, Y+3	; 0x03
    1bc0:	fc 81       	ldd	r31, Y+4	; 0x04
    1bc2:	87 e1       	ldi	r24, 0x17	; 23
    1bc4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bc6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc8:	9c 81       	ldd	r25, Y+4	; 0x04
    1bca:	01 97       	sbiw	r24, 0x01	; 1
    1bcc:	9c 83       	std	Y+4, r25	; 0x04
    1bce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1bd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd4:	88 e1       	ldi	r24, 0x18	; 24
    1bd6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bd8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bda:	9c 81       	ldd	r25, Y+4	; 0x04
    1bdc:	01 97       	sbiw	r24, 0x01	; 1
    1bde:	9c 83       	std	Y+4, r25	; 0x04
    1be0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1be2:	eb 81       	ldd	r30, Y+3	; 0x03
    1be4:	fc 81       	ldd	r31, Y+4	; 0x04
    1be6:	89 e1       	ldi	r24, 0x19	; 25
    1be8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bea:	8b 81       	ldd	r24, Y+3	; 0x03
    1bec:	9c 81       	ldd	r25, Y+4	; 0x04
    1bee:	01 97       	sbiw	r24, 0x01	; 1
    1bf0:	9c 83       	std	Y+4, r25	; 0x04
    1bf2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf8:	80 e2       	ldi	r24, 0x20	; 32
    1bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1c00:	01 97       	sbiw	r24, 0x01	; 1
    1c02:	9c 83       	std	Y+4, r25	; 0x04
    1c04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1c06:	eb 81       	ldd	r30, Y+3	; 0x03
    1c08:	fc 81       	ldd	r31, Y+4	; 0x04
    1c0a:	81 e2       	ldi	r24, 0x21	; 33
    1c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c10:	9c 81       	ldd	r25, Y+4	; 0x04
    1c12:	01 97       	sbiw	r24, 0x01	; 1
    1c14:	9c 83       	std	Y+4, r25	; 0x04
    1c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1c18:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1c:	82 e2       	ldi	r24, 0x22	; 34
    1c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c20:	8b 81       	ldd	r24, Y+3	; 0x03
    1c22:	9c 81       	ldd	r25, Y+4	; 0x04
    1c24:	01 97       	sbiw	r24, 0x01	; 1
    1c26:	9c 83       	std	Y+4, r25	; 0x04
    1c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2e:	83 e2       	ldi	r24, 0x23	; 35
    1c30:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c32:	8b 81       	ldd	r24, Y+3	; 0x03
    1c34:	9c 81       	ldd	r25, Y+4	; 0x04
    1c36:	01 97       	sbiw	r24, 0x01	; 1
    1c38:	9c 83       	std	Y+4, r25	; 0x04
    1c3a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1c3c:	8f 81       	ldd	r24, Y+7	; 0x07
    1c3e:	98 85       	ldd	r25, Y+8	; 0x08
    1c40:	9a 83       	std	Y+2, r25	; 0x02
    1c42:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	eb 81       	ldd	r30, Y+3	; 0x03
    1c48:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c50:	01 97       	sbiw	r24, 0x01	; 1
    1c52:	9c 83       	std	Y+4, r25	; 0x04
    1c54:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1c56:	89 81       	ldd	r24, Y+1	; 0x01
    1c58:	9a 81       	ldd	r25, Y+2	; 0x02
    1c5a:	89 2f       	mov	r24, r25
    1c5c:	99 27       	eor	r25, r25
    1c5e:	9a 83       	std	Y+2, r25	; 0x02
    1c60:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1c62:	89 81       	ldd	r24, Y+1	; 0x01
    1c64:	eb 81       	ldd	r30, Y+3	; 0x03
    1c66:	fc 81       	ldd	r31, Y+4	; 0x04
    1c68:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c6e:	01 97       	sbiw	r24, 0x01	; 1
    1c70:	9c 83       	std	Y+4, r25	; 0x04
    1c72:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1c74:	eb 81       	ldd	r30, Y+3	; 0x03
    1c76:	fc 81       	ldd	r31, Y+4	; 0x04
    1c78:	86 e2       	ldi	r24, 0x26	; 38
    1c7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c80:	01 97       	sbiw	r24, 0x01	; 1
    1c82:	9c 83       	std	Y+4, r25	; 0x04
    1c84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1c86:	eb 81       	ldd	r30, Y+3	; 0x03
    1c88:	fc 81       	ldd	r31, Y+4	; 0x04
    1c8a:	87 e2       	ldi	r24, 0x27	; 39
    1c8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c90:	9c 81       	ldd	r25, Y+4	; 0x04
    1c92:	01 97       	sbiw	r24, 0x01	; 1
    1c94:	9c 83       	std	Y+4, r25	; 0x04
    1c96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1c98:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c9c:	88 e2       	ldi	r24, 0x28	; 40
    1c9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca4:	01 97       	sbiw	r24, 0x01	; 1
    1ca6:	9c 83       	std	Y+4, r25	; 0x04
    1ca8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1caa:	eb 81       	ldd	r30, Y+3	; 0x03
    1cac:	fc 81       	ldd	r31, Y+4	; 0x04
    1cae:	89 e2       	ldi	r24, 0x29	; 41
    1cb0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb4:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb6:	01 97       	sbiw	r24, 0x01	; 1
    1cb8:	9c 83       	std	Y+4, r25	; 0x04
    1cba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1cbc:	eb 81       	ldd	r30, Y+3	; 0x03
    1cbe:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc0:	80 e3       	ldi	r24, 0x30	; 48
    1cc2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc8:	01 97       	sbiw	r24, 0x01	; 1
    1cca:	9c 83       	std	Y+4, r25	; 0x04
    1ccc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1cce:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd2:	81 e3       	ldi	r24, 0x31	; 49
    1cd4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cd8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cda:	01 97       	sbiw	r24, 0x01	; 1
    1cdc:	9c 83       	std	Y+4, r25	; 0x04
    1cde:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce2:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1ce4:	28 96       	adiw	r28, 0x08	; 8
    1ce6:	0f b6       	in	r0, 0x3f	; 63
    1ce8:	f8 94       	cli
    1cea:	de bf       	out	0x3e, r29	; 62
    1cec:	0f be       	out	0x3f, r0	; 63
    1cee:	cd bf       	out	0x3d, r28	; 61
    1cf0:	cf 91       	pop	r28
    1cf2:	df 91       	pop	r29
    1cf4:	08 95       	ret

00001cf6 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1cf6:	df 93       	push	r29
    1cf8:	cf 93       	push	r28
    1cfa:	cd b7       	in	r28, 0x3d	; 61
    1cfc:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1cfe:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1d02:	a0 91 ce 06 	lds	r26, 0x06CE
    1d06:	b0 91 cf 06 	lds	r27, 0x06CF
    1d0a:	cd 91       	ld	r28, X+
    1d0c:	cd bf       	out	0x3d, r28	; 61
    1d0e:	dd 91       	ld	r29, X+
    1d10:	de bf       	out	0x3e, r29	; 62
    1d12:	ff 91       	pop	r31
    1d14:	ef 91       	pop	r30
    1d16:	df 91       	pop	r29
    1d18:	cf 91       	pop	r28
    1d1a:	bf 91       	pop	r27
    1d1c:	af 91       	pop	r26
    1d1e:	9f 91       	pop	r25
    1d20:	8f 91       	pop	r24
    1d22:	7f 91       	pop	r23
    1d24:	6f 91       	pop	r22
    1d26:	5f 91       	pop	r21
    1d28:	4f 91       	pop	r20
    1d2a:	3f 91       	pop	r19
    1d2c:	2f 91       	pop	r18
    1d2e:	1f 91       	pop	r17
    1d30:	0f 91       	pop	r16
    1d32:	ff 90       	pop	r15
    1d34:	ef 90       	pop	r14
    1d36:	df 90       	pop	r13
    1d38:	cf 90       	pop	r12
    1d3a:	bf 90       	pop	r11
    1d3c:	af 90       	pop	r10
    1d3e:	9f 90       	pop	r9
    1d40:	8f 90       	pop	r8
    1d42:	7f 90       	pop	r7
    1d44:	6f 90       	pop	r6
    1d46:	5f 90       	pop	r5
    1d48:	4f 90       	pop	r4
    1d4a:	3f 90       	pop	r3
    1d4c:	2f 90       	pop	r2
    1d4e:	1f 90       	pop	r1
    1d50:	0f 90       	pop	r0
    1d52:	0f be       	out	0x3f, r0	; 63
    1d54:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1d56:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1d58:	81 e0       	ldi	r24, 0x01	; 1
}
    1d5a:	cf 91       	pop	r28
    1d5c:	df 91       	pop	r29
    1d5e:	08 95       	ret

00001d60 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1d60:	df 93       	push	r29
    1d62:	cf 93       	push	r28
    1d64:	cd b7       	in	r28, 0x3d	; 61
    1d66:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1d68:	cf 91       	pop	r28
    1d6a:	df 91       	pop	r29
    1d6c:	08 95       	ret

00001d6e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1d6e:	0f 92       	push	r0
    1d70:	0f b6       	in	r0, 0x3f	; 63
    1d72:	f8 94       	cli
    1d74:	0f 92       	push	r0
    1d76:	1f 92       	push	r1
    1d78:	11 24       	eor	r1, r1
    1d7a:	2f 92       	push	r2
    1d7c:	3f 92       	push	r3
    1d7e:	4f 92       	push	r4
    1d80:	5f 92       	push	r5
    1d82:	6f 92       	push	r6
    1d84:	7f 92       	push	r7
    1d86:	8f 92       	push	r8
    1d88:	9f 92       	push	r9
    1d8a:	af 92       	push	r10
    1d8c:	bf 92       	push	r11
    1d8e:	cf 92       	push	r12
    1d90:	df 92       	push	r13
    1d92:	ef 92       	push	r14
    1d94:	ff 92       	push	r15
    1d96:	0f 93       	push	r16
    1d98:	1f 93       	push	r17
    1d9a:	2f 93       	push	r18
    1d9c:	3f 93       	push	r19
    1d9e:	4f 93       	push	r20
    1da0:	5f 93       	push	r21
    1da2:	6f 93       	push	r22
    1da4:	7f 93       	push	r23
    1da6:	8f 93       	push	r24
    1da8:	9f 93       	push	r25
    1daa:	af 93       	push	r26
    1dac:	bf 93       	push	r27
    1dae:	cf 93       	push	r28
    1db0:	df 93       	push	r29
    1db2:	ef 93       	push	r30
    1db4:	ff 93       	push	r31
    1db6:	a0 91 ce 06 	lds	r26, 0x06CE
    1dba:	b0 91 cf 06 	lds	r27, 0x06CF
    1dbe:	0d b6       	in	r0, 0x3d	; 61
    1dc0:	0d 92       	st	X+, r0
    1dc2:	0e b6       	in	r0, 0x3e	; 62
    1dc4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1dc6:	0e 94 ff 24 	call	0x49fe	; 0x49fe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1dca:	a0 91 ce 06 	lds	r26, 0x06CE
    1dce:	b0 91 cf 06 	lds	r27, 0x06CF
    1dd2:	cd 91       	ld	r28, X+
    1dd4:	cd bf       	out	0x3d, r28	; 61
    1dd6:	dd 91       	ld	r29, X+
    1dd8:	de bf       	out	0x3e, r29	; 62
    1dda:	ff 91       	pop	r31
    1ddc:	ef 91       	pop	r30
    1dde:	df 91       	pop	r29
    1de0:	cf 91       	pop	r28
    1de2:	bf 91       	pop	r27
    1de4:	af 91       	pop	r26
    1de6:	9f 91       	pop	r25
    1de8:	8f 91       	pop	r24
    1dea:	7f 91       	pop	r23
    1dec:	6f 91       	pop	r22
    1dee:	5f 91       	pop	r21
    1df0:	4f 91       	pop	r20
    1df2:	3f 91       	pop	r19
    1df4:	2f 91       	pop	r18
    1df6:	1f 91       	pop	r17
    1df8:	0f 91       	pop	r16
    1dfa:	ff 90       	pop	r15
    1dfc:	ef 90       	pop	r14
    1dfe:	df 90       	pop	r13
    1e00:	cf 90       	pop	r12
    1e02:	bf 90       	pop	r11
    1e04:	af 90       	pop	r10
    1e06:	9f 90       	pop	r9
    1e08:	8f 90       	pop	r8
    1e0a:	7f 90       	pop	r7
    1e0c:	6f 90       	pop	r6
    1e0e:	5f 90       	pop	r5
    1e10:	4f 90       	pop	r4
    1e12:	3f 90       	pop	r3
    1e14:	2f 90       	pop	r2
    1e16:	1f 90       	pop	r1
    1e18:	0f 90       	pop	r0
    1e1a:	0f be       	out	0x3f, r0	; 63
    1e1c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e1e:	08 95       	ret

00001e20 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e20:	0f 92       	push	r0
    1e22:	0f b6       	in	r0, 0x3f	; 63
    1e24:	f8 94       	cli
    1e26:	0f 92       	push	r0
    1e28:	1f 92       	push	r1
    1e2a:	11 24       	eor	r1, r1
    1e2c:	2f 92       	push	r2
    1e2e:	3f 92       	push	r3
    1e30:	4f 92       	push	r4
    1e32:	5f 92       	push	r5
    1e34:	6f 92       	push	r6
    1e36:	7f 92       	push	r7
    1e38:	8f 92       	push	r8
    1e3a:	9f 92       	push	r9
    1e3c:	af 92       	push	r10
    1e3e:	bf 92       	push	r11
    1e40:	cf 92       	push	r12
    1e42:	df 92       	push	r13
    1e44:	ef 92       	push	r14
    1e46:	ff 92       	push	r15
    1e48:	0f 93       	push	r16
    1e4a:	1f 93       	push	r17
    1e4c:	2f 93       	push	r18
    1e4e:	3f 93       	push	r19
    1e50:	4f 93       	push	r20
    1e52:	5f 93       	push	r21
    1e54:	6f 93       	push	r22
    1e56:	7f 93       	push	r23
    1e58:	8f 93       	push	r24
    1e5a:	9f 93       	push	r25
    1e5c:	af 93       	push	r26
    1e5e:	bf 93       	push	r27
    1e60:	cf 93       	push	r28
    1e62:	df 93       	push	r29
    1e64:	ef 93       	push	r30
    1e66:	ff 93       	push	r31
    1e68:	a0 91 ce 06 	lds	r26, 0x06CE
    1e6c:	b0 91 cf 06 	lds	r27, 0x06CF
    1e70:	0d b6       	in	r0, 0x3d	; 61
    1e72:	0d 92       	st	X+, r0
    1e74:	0e b6       	in	r0, 0x3e	; 62
    1e76:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1e78:	0e 94 1a 24 	call	0x4834	; 0x4834 <xTaskIncrementTick>
    1e7c:	88 23       	and	r24, r24
    1e7e:	11 f0       	breq	.+4      	; 0x1e84 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1e80:	0e 94 ff 24 	call	0x49fe	; 0x49fe <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1e84:	a0 91 ce 06 	lds	r26, 0x06CE
    1e88:	b0 91 cf 06 	lds	r27, 0x06CF
    1e8c:	cd 91       	ld	r28, X+
    1e8e:	cd bf       	out	0x3d, r28	; 61
    1e90:	dd 91       	ld	r29, X+
    1e92:	de bf       	out	0x3e, r29	; 62
    1e94:	ff 91       	pop	r31
    1e96:	ef 91       	pop	r30
    1e98:	df 91       	pop	r29
    1e9a:	cf 91       	pop	r28
    1e9c:	bf 91       	pop	r27
    1e9e:	af 91       	pop	r26
    1ea0:	9f 91       	pop	r25
    1ea2:	8f 91       	pop	r24
    1ea4:	7f 91       	pop	r23
    1ea6:	6f 91       	pop	r22
    1ea8:	5f 91       	pop	r21
    1eaa:	4f 91       	pop	r20
    1eac:	3f 91       	pop	r19
    1eae:	2f 91       	pop	r18
    1eb0:	1f 91       	pop	r17
    1eb2:	0f 91       	pop	r16
    1eb4:	ff 90       	pop	r15
    1eb6:	ef 90       	pop	r14
    1eb8:	df 90       	pop	r13
    1eba:	cf 90       	pop	r12
    1ebc:	bf 90       	pop	r11
    1ebe:	af 90       	pop	r10
    1ec0:	9f 90       	pop	r9
    1ec2:	8f 90       	pop	r8
    1ec4:	7f 90       	pop	r7
    1ec6:	6f 90       	pop	r6
    1ec8:	5f 90       	pop	r5
    1eca:	4f 90       	pop	r4
    1ecc:	3f 90       	pop	r3
    1ece:	2f 90       	pop	r2
    1ed0:	1f 90       	pop	r1
    1ed2:	0f 90       	pop	r0
    1ed4:	0f be       	out	0x3f, r0	; 63
    1ed6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ed8:	08 95       	ret

00001eda <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1eda:	df 93       	push	r29
    1edc:	cf 93       	push	r28
    1ede:	00 d0       	rcall	.+0      	; 0x1ee0 <prvSetupTimerInterrupt+0x6>
    1ee0:	00 d0       	rcall	.+0      	; 0x1ee2 <prvSetupTimerInterrupt+0x8>
    1ee2:	00 d0       	rcall	.+0      	; 0x1ee4 <prvSetupTimerInterrupt+0xa>
    1ee4:	cd b7       	in	r28, 0x3d	; 61
    1ee6:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1ee8:	80 e4       	ldi	r24, 0x40	; 64
    1eea:	9f e1       	ldi	r25, 0x1F	; 31
    1eec:	a0 e0       	ldi	r26, 0x00	; 0
    1eee:	b0 e0       	ldi	r27, 0x00	; 0
    1ef0:	8b 83       	std	Y+3, r24	; 0x03
    1ef2:	9c 83       	std	Y+4, r25	; 0x04
    1ef4:	ad 83       	std	Y+5, r26	; 0x05
    1ef6:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    1efa:	9c 81       	ldd	r25, Y+4	; 0x04
    1efc:	ad 81       	ldd	r26, Y+5	; 0x05
    1efe:	be 81       	ldd	r27, Y+6	; 0x06
    1f00:	68 94       	set
    1f02:	15 f8       	bld	r1, 5
    1f04:	b6 95       	lsr	r27
    1f06:	a7 95       	ror	r26
    1f08:	97 95       	ror	r25
    1f0a:	87 95       	ror	r24
    1f0c:	16 94       	lsr	r1
    1f0e:	d1 f7       	brne	.-12     	; 0x1f04 <prvSetupTimerInterrupt+0x2a>
    1f10:	8b 83       	std	Y+3, r24	; 0x03
    1f12:	9c 83       	std	Y+4, r25	; 0x04
    1f14:	ad 83       	std	Y+5, r26	; 0x05
    1f16:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1f18:	8b 81       	ldd	r24, Y+3	; 0x03
    1f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f1c:	ad 81       	ldd	r26, Y+5	; 0x05
    1f1e:	be 81       	ldd	r27, Y+6	; 0x06
    1f20:	01 97       	sbiw	r24, 0x01	; 1
    1f22:	a1 09       	sbc	r26, r1
    1f24:	b1 09       	sbc	r27, r1
    1f26:	8b 83       	std	Y+3, r24	; 0x03
    1f28:	9c 83       	std	Y+4, r25	; 0x04
    1f2a:	ad 83       	std	Y+5, r26	; 0x05
    1f2c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1f2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1f30:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1f32:	8b 81       	ldd	r24, Y+3	; 0x03
    1f34:	9c 81       	ldd	r25, Y+4	; 0x04
    1f36:	ad 81       	ldd	r26, Y+5	; 0x05
    1f38:	be 81       	ldd	r27, Y+6	; 0x06
    1f3a:	89 2f       	mov	r24, r25
    1f3c:	9a 2f       	mov	r25, r26
    1f3e:	ab 2f       	mov	r26, r27
    1f40:	bb 27       	eor	r27, r27
    1f42:	8b 83       	std	Y+3, r24	; 0x03
    1f44:	9c 83       	std	Y+4, r25	; 0x04
    1f46:	ad 83       	std	Y+5, r26	; 0x05
    1f48:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1f4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f4c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1f4e:	eb e4       	ldi	r30, 0x4B	; 75
    1f50:	f0 e0       	ldi	r31, 0x00	; 0
    1f52:	8a 81       	ldd	r24, Y+2	; 0x02
    1f54:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1f56:	ea e4       	ldi	r30, 0x4A	; 74
    1f58:	f0 e0       	ldi	r31, 0x00	; 0
    1f5a:	89 81       	ldd	r24, Y+1	; 0x01
    1f5c:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1f5e:	8b e0       	ldi	r24, 0x0B	; 11
    1f60:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1f62:	ee e4       	ldi	r30, 0x4E	; 78
    1f64:	f0 e0       	ldi	r31, 0x00	; 0
    1f66:	89 81       	ldd	r24, Y+1	; 0x01
    1f68:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1f6a:	e9 e5       	ldi	r30, 0x59	; 89
    1f6c:	f0 e0       	ldi	r31, 0x00	; 0
    1f6e:	80 81       	ld	r24, Z
    1f70:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1f72:	89 81       	ldd	r24, Y+1	; 0x01
    1f74:	80 61       	ori	r24, 0x10	; 16
    1f76:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1f78:	e9 e5       	ldi	r30, 0x59	; 89
    1f7a:	f0 e0       	ldi	r31, 0x00	; 0
    1f7c:	89 81       	ldd	r24, Y+1	; 0x01
    1f7e:	80 83       	st	Z, r24
}
    1f80:	26 96       	adiw	r28, 0x06	; 6
    1f82:	0f b6       	in	r0, 0x3f	; 63
    1f84:	f8 94       	cli
    1f86:	de bf       	out	0x3e, r29	; 62
    1f88:	0f be       	out	0x3f, r0	; 63
    1f8a:	cd bf       	out	0x3d, r28	; 61
    1f8c:	cf 91       	pop	r28
    1f8e:	df 91       	pop	r29
    1f90:	08 95       	ret

00001f92 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1f92:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1f96:	18 95       	reti

00001f98 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1f98:	df 93       	push	r29
    1f9a:	cf 93       	push	r28
    1f9c:	00 d0       	rcall	.+0      	; 0x1f9e <xQueueGenericReset+0x6>
    1f9e:	00 d0       	rcall	.+0      	; 0x1fa0 <xQueueGenericReset+0x8>
    1fa0:	0f 92       	push	r0
    1fa2:	cd b7       	in	r28, 0x3d	; 61
    1fa4:	de b7       	in	r29, 0x3e	; 62
    1fa6:	9c 83       	std	Y+4, r25	; 0x04
    1fa8:	8b 83       	std	Y+3, r24	; 0x03
    1faa:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1fac:	8b 81       	ldd	r24, Y+3	; 0x03
    1fae:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb0:	9a 83       	std	Y+2, r25	; 0x02
    1fb2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1fb4:	0f b6       	in	r0, 0x3f	; 63
    1fb6:	f8 94       	cli
    1fb8:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1fba:	e9 81       	ldd	r30, Y+1	; 0x01
    1fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    1fbe:	40 81       	ld	r20, Z
    1fc0:	51 81       	ldd	r21, Z+1	; 0x01
    1fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1fc8:	28 2f       	mov	r18, r24
    1fca:	30 e0       	ldi	r19, 0x00	; 0
    1fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    1fce:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1fd2:	88 2f       	mov	r24, r24
    1fd4:	90 e0       	ldi	r25, 0x00	; 0
    1fd6:	bc 01       	movw	r22, r24
    1fd8:	26 9f       	mul	r18, r22
    1fda:	c0 01       	movw	r24, r0
    1fdc:	27 9f       	mul	r18, r23
    1fde:	90 0d       	add	r25, r0
    1fe0:	36 9f       	mul	r19, r22
    1fe2:	90 0d       	add	r25, r0
    1fe4:	11 24       	eor	r1, r1
    1fe6:	84 0f       	add	r24, r20
    1fe8:	95 1f       	adc	r25, r21
    1fea:	e9 81       	ldd	r30, Y+1	; 0x01
    1fec:	fa 81       	ldd	r31, Y+2	; 0x02
    1fee:	95 83       	std	Z+5, r25	; 0x05
    1ff0:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1ff2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ff6:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1ff8:	e9 81       	ldd	r30, Y+1	; 0x01
    1ffa:	fa 81       	ldd	r31, Y+2	; 0x02
    1ffc:	80 81       	ld	r24, Z
    1ffe:	91 81       	ldd	r25, Z+1	; 0x01
    2000:	e9 81       	ldd	r30, Y+1	; 0x01
    2002:	fa 81       	ldd	r31, Y+2	; 0x02
    2004:	93 83       	std	Z+3, r25	; 0x03
    2006:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2008:	e9 81       	ldd	r30, Y+1	; 0x01
    200a:	fa 81       	ldd	r31, Y+2	; 0x02
    200c:	40 81       	ld	r20, Z
    200e:	51 81       	ldd	r21, Z+1	; 0x01
    2010:	e9 81       	ldd	r30, Y+1	; 0x01
    2012:	fa 81       	ldd	r31, Y+2	; 0x02
    2014:	83 8d       	ldd	r24, Z+27	; 0x1b
    2016:	88 2f       	mov	r24, r24
    2018:	90 e0       	ldi	r25, 0x00	; 0
    201a:	9c 01       	movw	r18, r24
    201c:	21 50       	subi	r18, 0x01	; 1
    201e:	30 40       	sbci	r19, 0x00	; 0
    2020:	e9 81       	ldd	r30, Y+1	; 0x01
    2022:	fa 81       	ldd	r31, Y+2	; 0x02
    2024:	84 8d       	ldd	r24, Z+28	; 0x1c
    2026:	88 2f       	mov	r24, r24
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	bc 01       	movw	r22, r24
    202c:	26 9f       	mul	r18, r22
    202e:	c0 01       	movw	r24, r0
    2030:	27 9f       	mul	r18, r23
    2032:	90 0d       	add	r25, r0
    2034:	36 9f       	mul	r19, r22
    2036:	90 0d       	add	r25, r0
    2038:	11 24       	eor	r1, r1
    203a:	84 0f       	add	r24, r20
    203c:	95 1f       	adc	r25, r21
    203e:	e9 81       	ldd	r30, Y+1	; 0x01
    2040:	fa 81       	ldd	r31, Y+2	; 0x02
    2042:	97 83       	std	Z+7, r25	; 0x07
    2044:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2046:	e9 81       	ldd	r30, Y+1	; 0x01
    2048:	fa 81       	ldd	r31, Y+2	; 0x02
    204a:	8f ef       	ldi	r24, 0xFF	; 255
    204c:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    204e:	e9 81       	ldd	r30, Y+1	; 0x01
    2050:	fa 81       	ldd	r31, Y+2	; 0x02
    2052:	8f ef       	ldi	r24, 0xFF	; 255
    2054:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    2056:	8d 81       	ldd	r24, Y+5	; 0x05
    2058:	88 23       	and	r24, r24
    205a:	79 f4       	brne	.+30     	; 0x207a <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    205c:	e9 81       	ldd	r30, Y+1	; 0x01
    205e:	fa 81       	ldd	r31, Y+2	; 0x02
    2060:	80 85       	ldd	r24, Z+8	; 0x08
    2062:	88 23       	and	r24, r24
    2064:	a1 f0       	breq	.+40     	; 0x208e <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2066:	89 81       	ldd	r24, Y+1	; 0x01
    2068:	9a 81       	ldd	r25, Y+2	; 0x02
    206a:	08 96       	adiw	r24, 0x08	; 8
    206c:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    2070:	88 23       	and	r24, r24
    2072:	69 f0       	breq	.+26     	; 0x208e <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2074:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
    2078:	0a c0       	rjmp	.+20     	; 0x208e <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    207a:	89 81       	ldd	r24, Y+1	; 0x01
    207c:	9a 81       	ldd	r25, Y+2	; 0x02
    207e:	08 96       	adiw	r24, 0x08	; 8
    2080:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2084:	89 81       	ldd	r24, Y+1	; 0x01
    2086:	9a 81       	ldd	r25, Y+2	; 0x02
    2088:	41 96       	adiw	r24, 0x11	; 17
    208a:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    208e:	0f 90       	pop	r0
    2090:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    2092:	81 e0       	ldi	r24, 0x01	; 1
}
    2094:	0f 90       	pop	r0
    2096:	0f 90       	pop	r0
    2098:	0f 90       	pop	r0
    209a:	0f 90       	pop	r0
    209c:	0f 90       	pop	r0
    209e:	cf 91       	pop	r28
    20a0:	df 91       	pop	r29
    20a2:	08 95       	ret

000020a4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    20a4:	0f 93       	push	r16
    20a6:	1f 93       	push	r17
    20a8:	df 93       	push	r29
    20aa:	cf 93       	push	r28
    20ac:	cd b7       	in	r28, 0x3d	; 61
    20ae:	de b7       	in	r29, 0x3e	; 62
    20b0:	29 97       	sbiw	r28, 0x09	; 9
    20b2:	0f b6       	in	r0, 0x3f	; 63
    20b4:	f8 94       	cli
    20b6:	de bf       	out	0x3e, r29	; 62
    20b8:	0f be       	out	0x3f, r0	; 63
    20ba:	cd bf       	out	0x3d, r28	; 61
    20bc:	8f 83       	std	Y+7, r24	; 0x07
    20be:	68 87       	std	Y+8, r22	; 0x08
    20c0:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    20c2:	88 85       	ldd	r24, Y+8	; 0x08
    20c4:	88 23       	and	r24, r24
    20c6:	19 f4       	brne	.+6      	; 0x20ce <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    20c8:	1c 82       	std	Y+4, r1	; 0x04
    20ca:	1b 82       	std	Y+3, r1	; 0x03
    20cc:	10 c0       	rjmp	.+32     	; 0x20ee <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20ce:	8f 81       	ldd	r24, Y+7	; 0x07
    20d0:	28 2f       	mov	r18, r24
    20d2:	30 e0       	ldi	r19, 0x00	; 0
    20d4:	88 85       	ldd	r24, Y+8	; 0x08
    20d6:	88 2f       	mov	r24, r24
    20d8:	90 e0       	ldi	r25, 0x00	; 0
    20da:	ac 01       	movw	r20, r24
    20dc:	24 9f       	mul	r18, r20
    20de:	c0 01       	movw	r24, r0
    20e0:	25 9f       	mul	r18, r21
    20e2:	90 0d       	add	r25, r0
    20e4:	34 9f       	mul	r19, r20
    20e6:	90 0d       	add	r25, r0
    20e8:	11 24       	eor	r1, r1
    20ea:	9c 83       	std	Y+4, r25	; 0x04
    20ec:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    20ee:	8b 81       	ldd	r24, Y+3	; 0x03
    20f0:	9c 81       	ldd	r25, Y+4	; 0x04
    20f2:	4f 96       	adiw	r24, 0x1f	; 31
    20f4:	0e 94 a0 09 	call	0x1340	; 0x1340 <pvPortMalloc>
    20f8:	9e 83       	std	Y+6, r25	; 0x06
    20fa:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    20fc:	8d 81       	ldd	r24, Y+5	; 0x05
    20fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2100:	00 97       	sbiw	r24, 0x00	; 0
    2102:	a1 f0       	breq	.+40     	; 0x212c <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    2104:	8d 81       	ldd	r24, Y+5	; 0x05
    2106:	9e 81       	ldd	r25, Y+6	; 0x06
    2108:	9a 83       	std	Y+2, r25	; 0x02
    210a:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    210c:	89 81       	ldd	r24, Y+1	; 0x01
    210e:	9a 81       	ldd	r25, Y+2	; 0x02
    2110:	4f 96       	adiw	r24, 0x1f	; 31
    2112:	9a 83       	std	Y+2, r25	; 0x02
    2114:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    2116:	29 81       	ldd	r18, Y+1	; 0x01
    2118:	3a 81       	ldd	r19, Y+2	; 0x02
    211a:	ed 81       	ldd	r30, Y+5	; 0x05
    211c:	fe 81       	ldd	r31, Y+6	; 0x06
    211e:	8f 81       	ldd	r24, Y+7	; 0x07
    2120:	68 85       	ldd	r22, Y+8	; 0x08
    2122:	a9 01       	movw	r20, r18
    2124:	29 85       	ldd	r18, Y+9	; 0x09
    2126:	8f 01       	movw	r16, r30
    2128:	0e 94 a3 10 	call	0x2146	; 0x2146 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    212c:	8d 81       	ldd	r24, Y+5	; 0x05
    212e:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    2130:	29 96       	adiw	r28, 0x09	; 9
    2132:	0f b6       	in	r0, 0x3f	; 63
    2134:	f8 94       	cli
    2136:	de bf       	out	0x3e, r29	; 62
    2138:	0f be       	out	0x3f, r0	; 63
    213a:	cd bf       	out	0x3d, r28	; 61
    213c:	cf 91       	pop	r28
    213e:	df 91       	pop	r29
    2140:	1f 91       	pop	r17
    2142:	0f 91       	pop	r16
    2144:	08 95       	ret

00002146 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    2146:	0f 93       	push	r16
    2148:	1f 93       	push	r17
    214a:	df 93       	push	r29
    214c:	cf 93       	push	r28
    214e:	cd b7       	in	r28, 0x3d	; 61
    2150:	de b7       	in	r29, 0x3e	; 62
    2152:	27 97       	sbiw	r28, 0x07	; 7
    2154:	0f b6       	in	r0, 0x3f	; 63
    2156:	f8 94       	cli
    2158:	de bf       	out	0x3e, r29	; 62
    215a:	0f be       	out	0x3f, r0	; 63
    215c:	cd bf       	out	0x3d, r28	; 61
    215e:	89 83       	std	Y+1, r24	; 0x01
    2160:	6a 83       	std	Y+2, r22	; 0x02
    2162:	5c 83       	std	Y+4, r21	; 0x04
    2164:	4b 83       	std	Y+3, r20	; 0x03
    2166:	2d 83       	std	Y+5, r18	; 0x05
    2168:	1f 83       	std	Y+7, r17	; 0x07
    216a:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    216c:	8a 81       	ldd	r24, Y+2	; 0x02
    216e:	88 23       	and	r24, r24
    2170:	39 f4       	brne	.+14     	; 0x2180 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2172:	8e 81       	ldd	r24, Y+6	; 0x06
    2174:	9f 81       	ldd	r25, Y+7	; 0x07
    2176:	ee 81       	ldd	r30, Y+6	; 0x06
    2178:	ff 81       	ldd	r31, Y+7	; 0x07
    217a:	91 83       	std	Z+1, r25	; 0x01
    217c:	80 83       	st	Z, r24
    217e:	06 c0       	rjmp	.+12     	; 0x218c <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2180:	8b 81       	ldd	r24, Y+3	; 0x03
    2182:	9c 81       	ldd	r25, Y+4	; 0x04
    2184:	ee 81       	ldd	r30, Y+6	; 0x06
    2186:	ff 81       	ldd	r31, Y+7	; 0x07
    2188:	91 83       	std	Z+1, r25	; 0x01
    218a:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    218c:	ee 81       	ldd	r30, Y+6	; 0x06
    218e:	ff 81       	ldd	r31, Y+7	; 0x07
    2190:	89 81       	ldd	r24, Y+1	; 0x01
    2192:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    2194:	ee 81       	ldd	r30, Y+6	; 0x06
    2196:	ff 81       	ldd	r31, Y+7	; 0x07
    2198:	8a 81       	ldd	r24, Y+2	; 0x02
    219a:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    219c:	8e 81       	ldd	r24, Y+6	; 0x06
    219e:	9f 81       	ldd	r25, Y+7	; 0x07
    21a0:	61 e0       	ldi	r22, 0x01	; 1
    21a2:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    21a6:	27 96       	adiw	r28, 0x07	; 7
    21a8:	0f b6       	in	r0, 0x3f	; 63
    21aa:	f8 94       	cli
    21ac:	de bf       	out	0x3e, r29	; 62
    21ae:	0f be       	out	0x3f, r0	; 63
    21b0:	cd bf       	out	0x3d, r28	; 61
    21b2:	cf 91       	pop	r28
    21b4:	df 91       	pop	r29
    21b6:	1f 91       	pop	r17
    21b8:	0f 91       	pop	r16
    21ba:	08 95       	ret

000021bc <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    21bc:	df 93       	push	r29
    21be:	cf 93       	push	r28
    21c0:	00 d0       	rcall	.+0      	; 0x21c2 <prvInitialiseMutex+0x6>
    21c2:	cd b7       	in	r28, 0x3d	; 61
    21c4:	de b7       	in	r29, 0x3e	; 62
    21c6:	9a 83       	std	Y+2, r25	; 0x02
    21c8:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    21ca:	89 81       	ldd	r24, Y+1	; 0x01
    21cc:	9a 81       	ldd	r25, Y+2	; 0x02
    21ce:	00 97       	sbiw	r24, 0x00	; 0
    21d0:	a1 f0       	breq	.+40     	; 0x21fa <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    21d2:	e9 81       	ldd	r30, Y+1	; 0x01
    21d4:	fa 81       	ldd	r31, Y+2	; 0x02
    21d6:	15 82       	std	Z+5, r1	; 0x05
    21d8:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    21da:	e9 81       	ldd	r30, Y+1	; 0x01
    21dc:	fa 81       	ldd	r31, Y+2	; 0x02
    21de:	11 82       	std	Z+1, r1	; 0x01
    21e0:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    21e2:	e9 81       	ldd	r30, Y+1	; 0x01
    21e4:	fa 81       	ldd	r31, Y+2	; 0x02
    21e6:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    21e8:	89 81       	ldd	r24, Y+1	; 0x01
    21ea:	9a 81       	ldd	r25, Y+2	; 0x02
    21ec:	60 e0       	ldi	r22, 0x00	; 0
    21ee:	70 e0       	ldi	r23, 0x00	; 0
    21f0:	40 e0       	ldi	r20, 0x00	; 0
    21f2:	50 e0       	ldi	r21, 0x00	; 0
    21f4:	20 e0       	ldi	r18, 0x00	; 0
    21f6:	0e 94 22 11 	call	0x2244	; 0x2244 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    21fa:	0f 90       	pop	r0
    21fc:	0f 90       	pop	r0
    21fe:	cf 91       	pop	r28
    2200:	df 91       	pop	r29
    2202:	08 95       	ret

00002204 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    2204:	df 93       	push	r29
    2206:	cf 93       	push	r28
    2208:	00 d0       	rcall	.+0      	; 0x220a <xQueueCreateMutex+0x6>
    220a:	00 d0       	rcall	.+0      	; 0x220c <xQueueCreateMutex+0x8>
    220c:	0f 92       	push	r0
    220e:	cd b7       	in	r28, 0x3d	; 61
    2210:	de b7       	in	r29, 0x3e	; 62
    2212:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    2214:	81 e0       	ldi	r24, 0x01	; 1
    2216:	8a 83       	std	Y+2, r24	; 0x02
    2218:	19 82       	std	Y+1, r1	; 0x01

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    221a:	8a 81       	ldd	r24, Y+2	; 0x02
    221c:	69 81       	ldd	r22, Y+1	; 0x01
    221e:	4d 81       	ldd	r20, Y+5	; 0x05
    2220:	0e 94 52 10 	call	0x20a4	; 0x20a4 <xQueueGenericCreate>
    2224:	9c 83       	std	Y+4, r25	; 0x04
    2226:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    2228:	8b 81       	ldd	r24, Y+3	; 0x03
    222a:	9c 81       	ldd	r25, Y+4	; 0x04
    222c:	0e 94 de 10 	call	0x21bc	; 0x21bc <prvInitialiseMutex>

		return xNewQueue;
    2230:	8b 81       	ldd	r24, Y+3	; 0x03
    2232:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    2234:	0f 90       	pop	r0
    2236:	0f 90       	pop	r0
    2238:	0f 90       	pop	r0
    223a:	0f 90       	pop	r0
    223c:	0f 90       	pop	r0
    223e:	cf 91       	pop	r28
    2240:	df 91       	pop	r29
    2242:	08 95       	ret

00002244 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2244:	df 93       	push	r29
    2246:	cf 93       	push	r28
    2248:	cd b7       	in	r28, 0x3d	; 61
    224a:	de b7       	in	r29, 0x3e	; 62
    224c:	2f 97       	sbiw	r28, 0x0f	; 15
    224e:	0f b6       	in	r0, 0x3f	; 63
    2250:	f8 94       	cli
    2252:	de bf       	out	0x3e, r29	; 62
    2254:	0f be       	out	0x3f, r0	; 63
    2256:	cd bf       	out	0x3d, r28	; 61
    2258:	99 87       	std	Y+9, r25	; 0x09
    225a:	88 87       	std	Y+8, r24	; 0x08
    225c:	7b 87       	std	Y+11, r23	; 0x0b
    225e:	6a 87       	std	Y+10, r22	; 0x0a
    2260:	5d 87       	std	Y+13, r21	; 0x0d
    2262:	4c 87       	std	Y+12, r20	; 0x0c
    2264:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2266:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2268:	88 85       	ldd	r24, Y+8	; 0x08
    226a:	99 85       	ldd	r25, Y+9	; 0x09
    226c:	9a 83       	std	Y+2, r25	; 0x02
    226e:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2270:	0f b6       	in	r0, 0x3f	; 63
    2272:	f8 94       	cli
    2274:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2276:	e9 81       	ldd	r30, Y+1	; 0x01
    2278:	fa 81       	ldd	r31, Y+2	; 0x02
    227a:	92 8d       	ldd	r25, Z+26	; 0x1a
    227c:	e9 81       	ldd	r30, Y+1	; 0x01
    227e:	fa 81       	ldd	r31, Y+2	; 0x02
    2280:	83 8d       	ldd	r24, Z+27	; 0x1b
    2282:	98 17       	cp	r25, r24
    2284:	18 f0       	brcs	.+6      	; 0x228c <xQueueGenericSend+0x48>
    2286:	8e 85       	ldd	r24, Y+14	; 0x0e
    2288:	82 30       	cpi	r24, 0x02	; 2
    228a:	11 f5       	brne	.+68     	; 0x22d0 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    228c:	89 81       	ldd	r24, Y+1	; 0x01
    228e:	9a 81       	ldd	r25, Y+2	; 0x02
    2290:	2a 85       	ldd	r18, Y+10	; 0x0a
    2292:	3b 85       	ldd	r19, Y+11	; 0x0b
    2294:	b9 01       	movw	r22, r18
    2296:	4e 85       	ldd	r20, Y+14	; 0x0e
    2298:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <prvCopyDataToQueue>
    229c:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    229e:	e9 81       	ldd	r30, Y+1	; 0x01
    22a0:	fa 81       	ldd	r31, Y+2	; 0x02
    22a2:	81 89       	ldd	r24, Z+17	; 0x11
    22a4:	88 23       	and	r24, r24
    22a6:	51 f0       	breq	.+20     	; 0x22bc <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22a8:	89 81       	ldd	r24, Y+1	; 0x01
    22aa:	9a 81       	ldd	r25, Y+2	; 0x02
    22ac:	41 96       	adiw	r24, 0x11	; 17
    22ae:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    22b2:	88 23       	and	r24, r24
    22b4:	41 f0       	breq	.+16     	; 0x22c6 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    22b6:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
    22ba:	05 c0       	rjmp	.+10     	; 0x22c6 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    22bc:	8b 81       	ldd	r24, Y+3	; 0x03
    22be:	88 23       	and	r24, r24
    22c0:	11 f0       	breq	.+4      	; 0x22c6 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    22c2:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    22c6:	0f 90       	pop	r0
    22c8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    22ca:	81 e0       	ldi	r24, 0x01	; 1
    22cc:	8f 87       	std	Y+15, r24	; 0x0f
    22ce:	5c c0       	rjmp	.+184    	; 0x2388 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    22d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    22d2:	9d 85       	ldd	r25, Y+13	; 0x0d
    22d4:	00 97       	sbiw	r24, 0x00	; 0
    22d6:	21 f4       	brne	.+8      	; 0x22e0 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    22d8:	0f 90       	pop	r0
    22da:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    22dc:	1f 86       	std	Y+15, r1	; 0x0f
    22de:	54 c0       	rjmp	.+168    	; 0x2388 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    22e0:	8c 81       	ldd	r24, Y+4	; 0x04
    22e2:	88 23       	and	r24, r24
    22e4:	31 f4       	brne	.+12     	; 0x22f2 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    22e6:	ce 01       	movw	r24, r28
    22e8:	05 96       	adiw	r24, 0x05	; 5
    22ea:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    22ee:	81 e0       	ldi	r24, 0x01	; 1
    22f0:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    22f2:	0f 90       	pop	r0
    22f4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    22f6:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    22fa:	0f b6       	in	r0, 0x3f	; 63
    22fc:	f8 94       	cli
    22fe:	0f 92       	push	r0
    2300:	e9 81       	ldd	r30, Y+1	; 0x01
    2302:	fa 81       	ldd	r31, Y+2	; 0x02
    2304:	85 8d       	ldd	r24, Z+29	; 0x1d
    2306:	8f 3f       	cpi	r24, 0xFF	; 255
    2308:	19 f4       	brne	.+6      	; 0x2310 <xQueueGenericSend+0xcc>
    230a:	e9 81       	ldd	r30, Y+1	; 0x01
    230c:	fa 81       	ldd	r31, Y+2	; 0x02
    230e:	15 8e       	std	Z+29, r1	; 0x1d
    2310:	e9 81       	ldd	r30, Y+1	; 0x01
    2312:	fa 81       	ldd	r31, Y+2	; 0x02
    2314:	86 8d       	ldd	r24, Z+30	; 0x1e
    2316:	8f 3f       	cpi	r24, 0xFF	; 255
    2318:	19 f4       	brne	.+6      	; 0x2320 <xQueueGenericSend+0xdc>
    231a:	e9 81       	ldd	r30, Y+1	; 0x01
    231c:	fa 81       	ldd	r31, Y+2	; 0x02
    231e:	16 8e       	std	Z+30, r1	; 0x1e
    2320:	0f 90       	pop	r0
    2322:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2324:	ce 01       	movw	r24, r28
    2326:	05 96       	adiw	r24, 0x05	; 5
    2328:	9e 01       	movw	r18, r28
    232a:	24 5f       	subi	r18, 0xF4	; 244
    232c:	3f 4f       	sbci	r19, 0xFF	; 255
    232e:	b9 01       	movw	r22, r18
    2330:	0e 94 bd 26 	call	0x4d7a	; 0x4d7a <xTaskCheckForTimeOut>
    2334:	88 23       	and	r24, r24
    2336:	09 f5       	brne	.+66     	; 0x237a <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2338:	89 81       	ldd	r24, Y+1	; 0x01
    233a:	9a 81       	ldd	r25, Y+2	; 0x02
    233c:	0e 94 56 17 	call	0x2eac	; 0x2eac <prvIsQueueFull>
    2340:	88 23       	and	r24, r24
    2342:	a1 f0       	breq	.+40     	; 0x236c <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2344:	89 81       	ldd	r24, Y+1	; 0x01
    2346:	9a 81       	ldd	r25, Y+2	; 0x02
    2348:	08 96       	adiw	r24, 0x08	; 8
    234a:	2c 85       	ldd	r18, Y+12	; 0x0c
    234c:	3d 85       	ldd	r19, Y+13	; 0x0d
    234e:	b9 01       	movw	r22, r18
    2350:	0e 94 6c 25 	call	0x4ad8	; 0x4ad8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2354:	89 81       	ldd	r24, Y+1	; 0x01
    2356:	9a 81       	ldd	r25, Y+2	; 0x02
    2358:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    235c:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    2360:	88 23       	and	r24, r24
    2362:	09 f0       	breq	.+2      	; 0x2366 <xQueueGenericSend+0x122>
    2364:	85 cf       	rjmp	.-246    	; 0x2270 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2366:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
    236a:	82 cf       	rjmp	.-252    	; 0x2270 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    236c:	89 81       	ldd	r24, Y+1	; 0x01
    236e:	9a 81       	ldd	r25, Y+2	; 0x02
    2370:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2374:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    2378:	7b cf       	rjmp	.-266    	; 0x2270 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    237a:	89 81       	ldd	r24, Y+1	; 0x01
    237c:	9a 81       	ldd	r25, Y+2	; 0x02
    237e:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2382:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2386:	1f 86       	std	Y+15, r1	; 0x0f
    2388:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    238a:	2f 96       	adiw	r28, 0x0f	; 15
    238c:	0f b6       	in	r0, 0x3f	; 63
    238e:	f8 94       	cli
    2390:	de bf       	out	0x3e, r29	; 62
    2392:	0f be       	out	0x3f, r0	; 63
    2394:	cd bf       	out	0x3d, r28	; 61
    2396:	cf 91       	pop	r28
    2398:	df 91       	pop	r29
    239a:	08 95       	ret

0000239c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    239c:	df 93       	push	r29
    239e:	cf 93       	push	r28
    23a0:	cd b7       	in	r28, 0x3d	; 61
    23a2:	de b7       	in	r29, 0x3e	; 62
    23a4:	2c 97       	sbiw	r28, 0x0c	; 12
    23a6:	0f b6       	in	r0, 0x3f	; 63
    23a8:	f8 94       	cli
    23aa:	de bf       	out	0x3e, r29	; 62
    23ac:	0f be       	out	0x3f, r0	; 63
    23ae:	cd bf       	out	0x3d, r28	; 61
    23b0:	9f 83       	std	Y+7, r25	; 0x07
    23b2:	8e 83       	std	Y+6, r24	; 0x06
    23b4:	79 87       	std	Y+9, r23	; 0x09
    23b6:	68 87       	std	Y+8, r22	; 0x08
    23b8:	5b 87       	std	Y+11, r21	; 0x0b
    23ba:	4a 87       	std	Y+10, r20	; 0x0a
    23bc:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    23be:	8e 81       	ldd	r24, Y+6	; 0x06
    23c0:	9f 81       	ldd	r25, Y+7	; 0x07
    23c2:	9b 83       	std	Y+3, r25	; 0x03
    23c4:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    23c6:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    23c8:	ea 81       	ldd	r30, Y+2	; 0x02
    23ca:	fb 81       	ldd	r31, Y+3	; 0x03
    23cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    23ce:	ea 81       	ldd	r30, Y+2	; 0x02
    23d0:	fb 81       	ldd	r31, Y+3	; 0x03
    23d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    23d4:	98 17       	cp	r25, r24
    23d6:	18 f0       	brcs	.+6      	; 0x23de <xQueueGenericSendFromISR+0x42>
    23d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    23da:	82 30       	cpi	r24, 0x02	; 2
    23dc:	61 f5       	brne	.+88     	; 0x2436 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    23de:	ea 81       	ldd	r30, Y+2	; 0x02
    23e0:	fb 81       	ldd	r31, Y+3	; 0x03
    23e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    23e4:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    23e6:	8a 81       	ldd	r24, Y+2	; 0x02
    23e8:	9b 81       	ldd	r25, Y+3	; 0x03
    23ea:	28 85       	ldd	r18, Y+8	; 0x08
    23ec:	39 85       	ldd	r19, Y+9	; 0x09
    23ee:	b9 01       	movw	r22, r18
    23f0:	4c 85       	ldd	r20, Y+12	; 0x0c
    23f2:	0e 94 c8 15 	call	0x2b90	; 0x2b90 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    23f6:	89 81       	ldd	r24, Y+1	; 0x01
    23f8:	8f 3f       	cpi	r24, 0xFF	; 255
    23fa:	a9 f4       	brne	.+42     	; 0x2426 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23fc:	ea 81       	ldd	r30, Y+2	; 0x02
    23fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2400:	81 89       	ldd	r24, Z+17	; 0x11
    2402:	88 23       	and	r24, r24
    2404:	a9 f0       	breq	.+42     	; 0x2430 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2406:	8a 81       	ldd	r24, Y+2	; 0x02
    2408:	9b 81       	ldd	r25, Y+3	; 0x03
    240a:	41 96       	adiw	r24, 0x11	; 17
    240c:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    2410:	88 23       	and	r24, r24
    2412:	71 f0       	breq	.+28     	; 0x2430 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2414:	8a 85       	ldd	r24, Y+10	; 0x0a
    2416:	9b 85       	ldd	r25, Y+11	; 0x0b
    2418:	00 97       	sbiw	r24, 0x00	; 0
    241a:	51 f0       	breq	.+20     	; 0x2430 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    241c:	ea 85       	ldd	r30, Y+10	; 0x0a
    241e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2420:	81 e0       	ldi	r24, 0x01	; 1
    2422:	80 83       	st	Z, r24
    2424:	05 c0       	rjmp	.+10     	; 0x2430 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2426:	89 81       	ldd	r24, Y+1	; 0x01
    2428:	8f 5f       	subi	r24, 0xFF	; 255
    242a:	ea 81       	ldd	r30, Y+2	; 0x02
    242c:	fb 81       	ldd	r31, Y+3	; 0x03
    242e:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2430:	81 e0       	ldi	r24, 0x01	; 1
    2432:	8d 83       	std	Y+5, r24	; 0x05
    2434:	01 c0       	rjmp	.+2      	; 0x2438 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2436:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2438:	8d 81       	ldd	r24, Y+5	; 0x05
}
    243a:	2c 96       	adiw	r28, 0x0c	; 12
    243c:	0f b6       	in	r0, 0x3f	; 63
    243e:	f8 94       	cli
    2440:	de bf       	out	0x3e, r29	; 62
    2442:	0f be       	out	0x3f, r0	; 63
    2444:	cd bf       	out	0x3d, r28	; 61
    2446:	cf 91       	pop	r28
    2448:	df 91       	pop	r29
    244a:	08 95       	ret

0000244c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    244c:	df 93       	push	r29
    244e:	cf 93       	push	r28
    2450:	cd b7       	in	r28, 0x3d	; 61
    2452:	de b7       	in	r29, 0x3e	; 62
    2454:	2a 97       	sbiw	r28, 0x0a	; 10
    2456:	0f b6       	in	r0, 0x3f	; 63
    2458:	f8 94       	cli
    245a:	de bf       	out	0x3e, r29	; 62
    245c:	0f be       	out	0x3f, r0	; 63
    245e:	cd bf       	out	0x3d, r28	; 61
    2460:	98 87       	std	Y+8, r25	; 0x08
    2462:	8f 83       	std	Y+7, r24	; 0x07
    2464:	7a 87       	std	Y+10, r23	; 0x0a
    2466:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2468:	8f 81       	ldd	r24, Y+7	; 0x07
    246a:	98 85       	ldd	r25, Y+8	; 0x08
    246c:	9c 83       	std	Y+4, r25	; 0x04
    246e:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2470:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2472:	eb 81       	ldd	r30, Y+3	; 0x03
    2474:	fc 81       	ldd	r31, Y+4	; 0x04
    2476:	82 8d       	ldd	r24, Z+26	; 0x1a
    2478:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    247a:	eb 81       	ldd	r30, Y+3	; 0x03
    247c:	fc 81       	ldd	r31, Y+4	; 0x04
    247e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2480:	8a 81       	ldd	r24, Y+2	; 0x02
    2482:	89 17       	cp	r24, r25
    2484:	48 f5       	brcc	.+82     	; 0x24d8 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2486:	eb 81       	ldd	r30, Y+3	; 0x03
    2488:	fc 81       	ldd	r31, Y+4	; 0x04
    248a:	86 8d       	ldd	r24, Z+30	; 0x1e
    248c:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    248e:	8a 81       	ldd	r24, Y+2	; 0x02
    2490:	8f 5f       	subi	r24, 0xFF	; 255
    2492:	eb 81       	ldd	r30, Y+3	; 0x03
    2494:	fc 81       	ldd	r31, Y+4	; 0x04
    2496:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2498:	89 81       	ldd	r24, Y+1	; 0x01
    249a:	8f 3f       	cpi	r24, 0xFF	; 255
    249c:	a9 f4       	brne	.+42     	; 0x24c8 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    249e:	eb 81       	ldd	r30, Y+3	; 0x03
    24a0:	fc 81       	ldd	r31, Y+4	; 0x04
    24a2:	81 89       	ldd	r24, Z+17	; 0x11
    24a4:	88 23       	and	r24, r24
    24a6:	a9 f0       	breq	.+42     	; 0x24d2 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24a8:	8b 81       	ldd	r24, Y+3	; 0x03
    24aa:	9c 81       	ldd	r25, Y+4	; 0x04
    24ac:	41 96       	adiw	r24, 0x11	; 17
    24ae:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    24b2:	88 23       	and	r24, r24
    24b4:	71 f0       	breq	.+28     	; 0x24d2 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    24b6:	89 85       	ldd	r24, Y+9	; 0x09
    24b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    24ba:	00 97       	sbiw	r24, 0x00	; 0
    24bc:	51 f0       	breq	.+20     	; 0x24d2 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    24be:	e9 85       	ldd	r30, Y+9	; 0x09
    24c0:	fa 85       	ldd	r31, Y+10	; 0x0a
    24c2:	81 e0       	ldi	r24, 0x01	; 1
    24c4:	80 83       	st	Z, r24
    24c6:	05 c0       	rjmp	.+10     	; 0x24d2 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    24c8:	89 81       	ldd	r24, Y+1	; 0x01
    24ca:	8f 5f       	subi	r24, 0xFF	; 255
    24cc:	eb 81       	ldd	r30, Y+3	; 0x03
    24ce:	fc 81       	ldd	r31, Y+4	; 0x04
    24d0:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    24d2:	81 e0       	ldi	r24, 0x01	; 1
    24d4:	8e 83       	std	Y+6, r24	; 0x06
    24d6:	01 c0       	rjmp	.+2      	; 0x24da <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    24d8:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    24da:	8e 81       	ldd	r24, Y+6	; 0x06
}
    24dc:	2a 96       	adiw	r28, 0x0a	; 10
    24de:	0f b6       	in	r0, 0x3f	; 63
    24e0:	f8 94       	cli
    24e2:	de bf       	out	0x3e, r29	; 62
    24e4:	0f be       	out	0x3f, r0	; 63
    24e6:	cd bf       	out	0x3d, r28	; 61
    24e8:	cf 91       	pop	r28
    24ea:	df 91       	pop	r29
    24ec:	08 95       	ret

000024ee <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    24ee:	df 93       	push	r29
    24f0:	cf 93       	push	r28
    24f2:	cd b7       	in	r28, 0x3d	; 61
    24f4:	de b7       	in	r29, 0x3e	; 62
    24f6:	2e 97       	sbiw	r28, 0x0e	; 14
    24f8:	0f b6       	in	r0, 0x3f	; 63
    24fa:	f8 94       	cli
    24fc:	de bf       	out	0x3e, r29	; 62
    24fe:	0f be       	out	0x3f, r0	; 63
    2500:	cd bf       	out	0x3d, r28	; 61
    2502:	99 87       	std	Y+9, r25	; 0x09
    2504:	88 87       	std	Y+8, r24	; 0x08
    2506:	7b 87       	std	Y+11, r23	; 0x0b
    2508:	6a 87       	std	Y+10, r22	; 0x0a
    250a:	5d 87       	std	Y+13, r21	; 0x0d
    250c:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    250e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2510:	88 85       	ldd	r24, Y+8	; 0x08
    2512:	99 85       	ldd	r25, Y+9	; 0x09
    2514:	9b 83       	std	Y+3, r25	; 0x03
    2516:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2518:	0f b6       	in	r0, 0x3f	; 63
    251a:	f8 94       	cli
    251c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    251e:	ea 81       	ldd	r30, Y+2	; 0x02
    2520:	fb 81       	ldd	r31, Y+3	; 0x03
    2522:	82 8d       	ldd	r24, Z+26	; 0x1a
    2524:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2526:	89 81       	ldd	r24, Y+1	; 0x01
    2528:	88 23       	and	r24, r24
    252a:	f9 f0       	breq	.+62     	; 0x256a <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    252c:	8a 81       	ldd	r24, Y+2	; 0x02
    252e:	9b 81       	ldd	r25, Y+3	; 0x03
    2530:	2a 85       	ldd	r18, Y+10	; 0x0a
    2532:	3b 85       	ldd	r19, Y+11	; 0x0b
    2534:	b9 01       	movw	r22, r18
    2536:	0e 94 80 16 	call	0x2d00	; 0x2d00 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    253a:	89 81       	ldd	r24, Y+1	; 0x01
    253c:	81 50       	subi	r24, 0x01	; 1
    253e:	ea 81       	ldd	r30, Y+2	; 0x02
    2540:	fb 81       	ldd	r31, Y+3	; 0x03
    2542:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2544:	ea 81       	ldd	r30, Y+2	; 0x02
    2546:	fb 81       	ldd	r31, Y+3	; 0x03
    2548:	80 85       	ldd	r24, Z+8	; 0x08
    254a:	88 23       	and	r24, r24
    254c:	49 f0       	breq	.+18     	; 0x2560 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    254e:	8a 81       	ldd	r24, Y+2	; 0x02
    2550:	9b 81       	ldd	r25, Y+3	; 0x03
    2552:	08 96       	adiw	r24, 0x08	; 8
    2554:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    2558:	88 23       	and	r24, r24
    255a:	11 f0       	breq	.+4      	; 0x2560 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    255c:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2560:	0f 90       	pop	r0
    2562:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	8e 87       	std	Y+14, r24	; 0x0e
    2568:	63 c0       	rjmp	.+198    	; 0x2630 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    256a:	8c 85       	ldd	r24, Y+12	; 0x0c
    256c:	9d 85       	ldd	r25, Y+13	; 0x0d
    256e:	00 97       	sbiw	r24, 0x00	; 0
    2570:	21 f4       	brne	.+8      	; 0x257a <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2572:	0f 90       	pop	r0
    2574:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2576:	1e 86       	std	Y+14, r1	; 0x0e
    2578:	5b c0       	rjmp	.+182    	; 0x2630 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    257a:	8c 81       	ldd	r24, Y+4	; 0x04
    257c:	88 23       	and	r24, r24
    257e:	31 f4       	brne	.+12     	; 0x258c <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2580:	ce 01       	movw	r24, r28
    2582:	05 96       	adiw	r24, 0x05	; 5
    2584:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2588:	81 e0       	ldi	r24, 0x01	; 1
    258a:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    258c:	0f 90       	pop	r0
    258e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2590:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2594:	0f b6       	in	r0, 0x3f	; 63
    2596:	f8 94       	cli
    2598:	0f 92       	push	r0
    259a:	ea 81       	ldd	r30, Y+2	; 0x02
    259c:	fb 81       	ldd	r31, Y+3	; 0x03
    259e:	85 8d       	ldd	r24, Z+29	; 0x1d
    25a0:	8f 3f       	cpi	r24, 0xFF	; 255
    25a2:	19 f4       	brne	.+6      	; 0x25aa <xQueueReceive+0xbc>
    25a4:	ea 81       	ldd	r30, Y+2	; 0x02
    25a6:	fb 81       	ldd	r31, Y+3	; 0x03
    25a8:	15 8e       	std	Z+29, r1	; 0x1d
    25aa:	ea 81       	ldd	r30, Y+2	; 0x02
    25ac:	fb 81       	ldd	r31, Y+3	; 0x03
    25ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    25b0:	8f 3f       	cpi	r24, 0xFF	; 255
    25b2:	19 f4       	brne	.+6      	; 0x25ba <xQueueReceive+0xcc>
    25b4:	ea 81       	ldd	r30, Y+2	; 0x02
    25b6:	fb 81       	ldd	r31, Y+3	; 0x03
    25b8:	16 8e       	std	Z+30, r1	; 0x1e
    25ba:	0f 90       	pop	r0
    25bc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    25be:	ce 01       	movw	r24, r28
    25c0:	05 96       	adiw	r24, 0x05	; 5
    25c2:	9e 01       	movw	r18, r28
    25c4:	24 5f       	subi	r18, 0xF4	; 244
    25c6:	3f 4f       	sbci	r19, 0xFF	; 255
    25c8:	b9 01       	movw	r22, r18
    25ca:	0e 94 bd 26 	call	0x4d7a	; 0x4d7a <xTaskCheckForTimeOut>
    25ce:	88 23       	and	r24, r24
    25d0:	09 f5       	brne	.+66     	; 0x2614 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    25d2:	8a 81       	ldd	r24, Y+2	; 0x02
    25d4:	9b 81       	ldd	r25, Y+3	; 0x03
    25d6:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <prvIsQueueEmpty>
    25da:	88 23       	and	r24, r24
    25dc:	a1 f0       	breq	.+40     	; 0x2606 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    25de:	8a 81       	ldd	r24, Y+2	; 0x02
    25e0:	9b 81       	ldd	r25, Y+3	; 0x03
    25e2:	41 96       	adiw	r24, 0x11	; 17
    25e4:	2c 85       	ldd	r18, Y+12	; 0x0c
    25e6:	3d 85       	ldd	r19, Y+13	; 0x0d
    25e8:	b9 01       	movw	r22, r18
    25ea:	0e 94 6c 25 	call	0x4ad8	; 0x4ad8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    25ee:	8a 81       	ldd	r24, Y+2	; 0x02
    25f0:	9b 81       	ldd	r25, Y+3	; 0x03
    25f2:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    25f6:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    25fa:	88 23       	and	r24, r24
    25fc:	09 f0       	breq	.+2      	; 0x2600 <xQueueReceive+0x112>
    25fe:	8c cf       	rjmp	.-232    	; 0x2518 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2600:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
    2604:	89 cf       	rjmp	.-238    	; 0x2518 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2606:	8a 81       	ldd	r24, Y+2	; 0x02
    2608:	9b 81       	ldd	r25, Y+3	; 0x03
    260a:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    260e:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    2612:	82 cf       	rjmp	.-252    	; 0x2518 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    2614:	8a 81       	ldd	r24, Y+2	; 0x02
    2616:	9b 81       	ldd	r25, Y+3	; 0x03
    2618:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    261c:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2620:	8a 81       	ldd	r24, Y+2	; 0x02
    2622:	9b 81       	ldd	r25, Y+3	; 0x03
    2624:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <prvIsQueueEmpty>
    2628:	88 23       	and	r24, r24
    262a:	09 f4       	brne	.+2      	; 0x262e <xQueueReceive+0x140>
    262c:	75 cf       	rjmp	.-278    	; 0x2518 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    262e:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2630:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2632:	2e 96       	adiw	r28, 0x0e	; 14
    2634:	0f b6       	in	r0, 0x3f	; 63
    2636:	f8 94       	cli
    2638:	de bf       	out	0x3e, r29	; 62
    263a:	0f be       	out	0x3f, r0	; 63
    263c:	cd bf       	out	0x3d, r28	; 61
    263e:	cf 91       	pop	r28
    2640:	df 91       	pop	r29
    2642:	08 95       	ret

00002644 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2644:	df 93       	push	r29
    2646:	cf 93       	push	r28
    2648:	cd b7       	in	r28, 0x3d	; 61
    264a:	de b7       	in	r29, 0x3e	; 62
    264c:	2e 97       	sbiw	r28, 0x0e	; 14
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	f8 94       	cli
    2652:	de bf       	out	0x3e, r29	; 62
    2654:	0f be       	out	0x3f, r0	; 63
    2656:	cd bf       	out	0x3d, r28	; 61
    2658:	9b 87       	std	Y+11, r25	; 0x0b
    265a:	8a 87       	std	Y+10, r24	; 0x0a
    265c:	7d 87       	std	Y+13, r23	; 0x0d
    265e:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    2660:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2662:	8a 85       	ldd	r24, Y+10	; 0x0a
    2664:	9b 85       	ldd	r25, Y+11	; 0x0b
    2666:	9d 83       	std	Y+5, r25	; 0x05
    2668:	8c 83       	std	Y+4, r24	; 0x04

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    266a:	1b 82       	std	Y+3, r1	; 0x03
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    266c:	0f b6       	in	r0, 0x3f	; 63
    266e:	f8 94       	cli
    2670:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2672:	ec 81       	ldd	r30, Y+4	; 0x04
    2674:	fd 81       	ldd	r31, Y+5	; 0x05
    2676:	82 8d       	ldd	r24, Z+26	; 0x1a
    2678:	8a 83       	std	Y+2, r24	; 0x02

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    267a:	8a 81       	ldd	r24, Y+2	; 0x02
    267c:	88 23       	and	r24, r24
    267e:	21 f1       	breq	.+72     	; 0x26c8 <xQueueSemaphoreTake+0x84>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2680:	8a 81       	ldd	r24, Y+2	; 0x02
    2682:	81 50       	subi	r24, 0x01	; 1
    2684:	ec 81       	ldd	r30, Y+4	; 0x04
    2686:	fd 81       	ldd	r31, Y+5	; 0x05
    2688:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    268a:	ec 81       	ldd	r30, Y+4	; 0x04
    268c:	fd 81       	ldd	r31, Y+5	; 0x05
    268e:	80 81       	ld	r24, Z
    2690:	91 81       	ldd	r25, Z+1	; 0x01
    2692:	00 97       	sbiw	r24, 0x00	; 0
    2694:	31 f4       	brne	.+12     	; 0x26a2 <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    2696:	0e 94 cd 29 	call	0x539a	; 0x539a <pvTaskIncrementMutexHeldCount>
    269a:	ec 81       	ldd	r30, Y+4	; 0x04
    269c:	fd 81       	ldd	r31, Y+5	; 0x05
    269e:	95 83       	std	Z+5, r25	; 0x05
    26a0:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    26a2:	ec 81       	ldd	r30, Y+4	; 0x04
    26a4:	fd 81       	ldd	r31, Y+5	; 0x05
    26a6:	80 85       	ldd	r24, Z+8	; 0x08
    26a8:	88 23       	and	r24, r24
    26aa:	49 f0       	breq	.+18     	; 0x26be <xQueueSemaphoreTake+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    26ac:	8c 81       	ldd	r24, Y+4	; 0x04
    26ae:	9d 81       	ldd	r25, Y+5	; 0x05
    26b0:	08 96       	adiw	r24, 0x08	; 8
    26b2:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    26b6:	88 23       	and	r24, r24
    26b8:	11 f0       	breq	.+4      	; 0x26be <xQueueSemaphoreTake+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    26ba:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    26be:	0f 90       	pop	r0
    26c0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    26c2:	81 e0       	ldi	r24, 0x01	; 1
    26c4:	8e 87       	std	Y+14, r24	; 0x0e
    26c6:	89 c0       	rjmp	.+274    	; 0x27da <xQueueSemaphoreTake+0x196>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    26c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    26ca:	9d 85       	ldd	r25, Y+13	; 0x0d
    26cc:	00 97       	sbiw	r24, 0x00	; 0
    26ce:	21 f4       	brne	.+8      	; 0x26d8 <xQueueSemaphoreTake+0x94>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    26d0:	0f 90       	pop	r0
    26d2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    26d4:	1e 86       	std	Y+14, r1	; 0x0e
    26d6:	81 c0       	rjmp	.+258    	; 0x27da <xQueueSemaphoreTake+0x196>
				}
				else if( xEntryTimeSet == pdFALSE )
    26d8:	8e 81       	ldd	r24, Y+6	; 0x06
    26da:	88 23       	and	r24, r24
    26dc:	31 f4       	brne	.+12     	; 0x26ea <xQueueSemaphoreTake+0xa6>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    26de:	ce 01       	movw	r24, r28
    26e0:	07 96       	adiw	r24, 0x07	; 7
    26e2:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    26e6:	81 e0       	ldi	r24, 0x01	; 1
    26e8:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    26ea:	0f 90       	pop	r0
    26ec:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    26ee:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26f2:	0f b6       	in	r0, 0x3f	; 63
    26f4:	f8 94       	cli
    26f6:	0f 92       	push	r0
    26f8:	ec 81       	ldd	r30, Y+4	; 0x04
    26fa:	fd 81       	ldd	r31, Y+5	; 0x05
    26fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    26fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2700:	19 f4       	brne	.+6      	; 0x2708 <xQueueSemaphoreTake+0xc4>
    2702:	ec 81       	ldd	r30, Y+4	; 0x04
    2704:	fd 81       	ldd	r31, Y+5	; 0x05
    2706:	15 8e       	std	Z+29, r1	; 0x1d
    2708:	ec 81       	ldd	r30, Y+4	; 0x04
    270a:	fd 81       	ldd	r31, Y+5	; 0x05
    270c:	86 8d       	ldd	r24, Z+30	; 0x1e
    270e:	8f 3f       	cpi	r24, 0xFF	; 255
    2710:	19 f4       	brne	.+6      	; 0x2718 <xQueueSemaphoreTake+0xd4>
    2712:	ec 81       	ldd	r30, Y+4	; 0x04
    2714:	fd 81       	ldd	r31, Y+5	; 0x05
    2716:	16 8e       	std	Z+30, r1	; 0x1e
    2718:	0f 90       	pop	r0
    271a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    271c:	ce 01       	movw	r24, r28
    271e:	07 96       	adiw	r24, 0x07	; 7
    2720:	9e 01       	movw	r18, r28
    2722:	24 5f       	subi	r18, 0xF4	; 244
    2724:	3f 4f       	sbci	r19, 0xFF	; 255
    2726:	b9 01       	movw	r22, r18
    2728:	0e 94 bd 26 	call	0x4d7a	; 0x4d7a <xTaskCheckForTimeOut>
    272c:	88 23       	and	r24, r24
    272e:	99 f5       	brne	.+102    	; 0x2796 <xQueueSemaphoreTake+0x152>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2730:	8c 81       	ldd	r24, Y+4	; 0x04
    2732:	9d 81       	ldd	r25, Y+5	; 0x05
    2734:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <prvIsQueueEmpty>
    2738:	88 23       	and	r24, r24
    273a:	31 f1       	breq	.+76     	; 0x2788 <xQueueSemaphoreTake+0x144>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    273c:	ec 81       	ldd	r30, Y+4	; 0x04
    273e:	fd 81       	ldd	r31, Y+5	; 0x05
    2740:	80 81       	ld	r24, Z
    2742:	91 81       	ldd	r25, Z+1	; 0x01
    2744:	00 97       	sbiw	r24, 0x00	; 0
    2746:	61 f4       	brne	.+24     	; 0x2760 <xQueueSemaphoreTake+0x11c>
					{
						taskENTER_CRITICAL();
    2748:	0f b6       	in	r0, 0x3f	; 63
    274a:	f8 94       	cli
    274c:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    274e:	ec 81       	ldd	r30, Y+4	; 0x04
    2750:	fd 81       	ldd	r31, Y+5	; 0x05
    2752:	84 81       	ldd	r24, Z+4	; 0x04
    2754:	95 81       	ldd	r25, Z+5	; 0x05
    2756:	0e 94 01 28 	call	0x5002	; 0x5002 <xTaskPriorityInherit>
    275a:	8b 83       	std	Y+3, r24	; 0x03
						}
						taskEXIT_CRITICAL();
    275c:	0f 90       	pop	r0
    275e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2760:	8c 81       	ldd	r24, Y+4	; 0x04
    2762:	9d 81       	ldd	r25, Y+5	; 0x05
    2764:	41 96       	adiw	r24, 0x11	; 17
    2766:	2c 85       	ldd	r18, Y+12	; 0x0c
    2768:	3d 85       	ldd	r19, Y+13	; 0x0d
    276a:	b9 01       	movw	r22, r18
    276c:	0e 94 6c 25 	call	0x4ad8	; 0x4ad8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2770:	8c 81       	ldd	r24, Y+4	; 0x04
    2772:	9d 81       	ldd	r25, Y+5	; 0x05
    2774:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2778:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    277c:	88 23       	and	r24, r24
    277e:	09 f0       	breq	.+2      	; 0x2782 <xQueueSemaphoreTake+0x13e>
    2780:	75 cf       	rjmp	.-278    	; 0x266c <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    2782:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
    2786:	72 cf       	rjmp	.-284    	; 0x266c <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2788:	8c 81       	ldd	r24, Y+4	; 0x04
    278a:	9d 81       	ldd	r25, Y+5	; 0x05
    278c:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2790:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    2794:	6b cf       	rjmp	.-298    	; 0x266c <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2796:	8c 81       	ldd	r24, Y+4	; 0x04
    2798:	9d 81       	ldd	r25, Y+5	; 0x05
    279a:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    279e:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    27a2:	8c 81       	ldd	r24, Y+4	; 0x04
    27a4:	9d 81       	ldd	r25, Y+5	; 0x05
    27a6:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <prvIsQueueEmpty>
    27aa:	88 23       	and	r24, r24
    27ac:	09 f4       	brne	.+2      	; 0x27b0 <xQueueSemaphoreTake+0x16c>
    27ae:	5e cf       	rjmp	.-324    	; 0x266c <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    27b0:	8b 81       	ldd	r24, Y+3	; 0x03
    27b2:	88 23       	and	r24, r24
    27b4:	89 f0       	breq	.+34     	; 0x27d8 <xQueueSemaphoreTake+0x194>
					{
						taskENTER_CRITICAL();
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    27bc:	8c 81       	ldd	r24, Y+4	; 0x04
    27be:	9d 81       	ldd	r25, Y+5	; 0x05
    27c0:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <prvGetDisinheritPriorityAfterTimeout>
    27c4:	89 83       	std	Y+1, r24	; 0x01
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    27c6:	ec 81       	ldd	r30, Y+4	; 0x04
    27c8:	fd 81       	ldd	r31, Y+5	; 0x05
    27ca:	84 81       	ldd	r24, Z+4	; 0x04
    27cc:	95 81       	ldd	r25, Z+5	; 0x05
    27ce:	69 81       	ldd	r22, Y+1	; 0x01
    27d0:	0e 94 11 29 	call	0x5222	; 0x5222 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    27d4:	0f 90       	pop	r0
    27d6:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    27d8:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    27da:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    27dc:	2e 96       	adiw	r28, 0x0e	; 14
    27de:	0f b6       	in	r0, 0x3f	; 63
    27e0:	f8 94       	cli
    27e2:	de bf       	out	0x3e, r29	; 62
    27e4:	0f be       	out	0x3f, r0	; 63
    27e6:	cd bf       	out	0x3d, r28	; 61
    27e8:	cf 91       	pop	r28
    27ea:	df 91       	pop	r29
    27ec:	08 95       	ret

000027ee <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    27ee:	df 93       	push	r29
    27f0:	cf 93       	push	r28
    27f2:	cd b7       	in	r28, 0x3d	; 61
    27f4:	de b7       	in	r29, 0x3e	; 62
    27f6:	60 97       	sbiw	r28, 0x10	; 16
    27f8:	0f b6       	in	r0, 0x3f	; 63
    27fa:	f8 94       	cli
    27fc:	de bf       	out	0x3e, r29	; 62
    27fe:	0f be       	out	0x3f, r0	; 63
    2800:	cd bf       	out	0x3d, r28	; 61
    2802:	9b 87       	std	Y+11, r25	; 0x0b
    2804:	8a 87       	std	Y+10, r24	; 0x0a
    2806:	7d 87       	std	Y+13, r23	; 0x0d
    2808:	6c 87       	std	Y+12, r22	; 0x0c
    280a:	5f 87       	std	Y+15, r21	; 0x0f
    280c:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    280e:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2810:	8a 85       	ldd	r24, Y+10	; 0x0a
    2812:	9b 85       	ldd	r25, Y+11	; 0x0b
    2814:	9b 83       	std	Y+3, r25	; 0x03
    2816:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2818:	0f b6       	in	r0, 0x3f	; 63
    281a:	f8 94       	cli
    281c:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    281e:	ea 81       	ldd	r30, Y+2	; 0x02
    2820:	fb 81       	ldd	r31, Y+3	; 0x03
    2822:	82 8d       	ldd	r24, Z+26	; 0x1a
    2824:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2826:	89 81       	ldd	r24, Y+1	; 0x01
    2828:	88 23       	and	r24, r24
    282a:	31 f1       	breq	.+76     	; 0x2878 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    282c:	ea 81       	ldd	r30, Y+2	; 0x02
    282e:	fb 81       	ldd	r31, Y+3	; 0x03
    2830:	86 81       	ldd	r24, Z+6	; 0x06
    2832:	97 81       	ldd	r25, Z+7	; 0x07
    2834:	9d 83       	std	Y+5, r25	; 0x05
    2836:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2838:	8a 81       	ldd	r24, Y+2	; 0x02
    283a:	9b 81       	ldd	r25, Y+3	; 0x03
    283c:	2c 85       	ldd	r18, Y+12	; 0x0c
    283e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2840:	b9 01       	movw	r22, r18
    2842:	0e 94 80 16 	call	0x2d00	; 0x2d00 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2846:	ea 81       	ldd	r30, Y+2	; 0x02
    2848:	fb 81       	ldd	r31, Y+3	; 0x03
    284a:	8c 81       	ldd	r24, Y+4	; 0x04
    284c:	9d 81       	ldd	r25, Y+5	; 0x05
    284e:	97 83       	std	Z+7, r25	; 0x07
    2850:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2852:	ea 81       	ldd	r30, Y+2	; 0x02
    2854:	fb 81       	ldd	r31, Y+3	; 0x03
    2856:	81 89       	ldd	r24, Z+17	; 0x11
    2858:	88 23       	and	r24, r24
    285a:	49 f0       	breq	.+18     	; 0x286e <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    285c:	8a 81       	ldd	r24, Y+2	; 0x02
    285e:	9b 81       	ldd	r25, Y+3	; 0x03
    2860:	41 96       	adiw	r24, 0x11	; 17
    2862:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    2866:	88 23       	and	r24, r24
    2868:	11 f0       	breq	.+4      	; 0x286e <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    286a:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    286e:	0f 90       	pop	r0
    2870:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2872:	81 e0       	ldi	r24, 0x01	; 1
    2874:	88 8b       	std	Y+16, r24	; 0x10
    2876:	63 c0       	rjmp	.+198    	; 0x293e <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2878:	8e 85       	ldd	r24, Y+14	; 0x0e
    287a:	9f 85       	ldd	r25, Y+15	; 0x0f
    287c:	00 97       	sbiw	r24, 0x00	; 0
    287e:	21 f4       	brne	.+8      	; 0x2888 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2880:	0f 90       	pop	r0
    2882:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2884:	18 8a       	std	Y+16, r1	; 0x10
    2886:	5b c0       	rjmp	.+182    	; 0x293e <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    2888:	8e 81       	ldd	r24, Y+6	; 0x06
    288a:	88 23       	and	r24, r24
    288c:	31 f4       	brne	.+12     	; 0x289a <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    288e:	ce 01       	movw	r24, r28
    2890:	07 96       	adiw	r24, 0x07	; 7
    2892:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2896:	81 e0       	ldi	r24, 0x01	; 1
    2898:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    289a:	0f 90       	pop	r0
    289c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    289e:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	f8 94       	cli
    28a6:	0f 92       	push	r0
    28a8:	ea 81       	ldd	r30, Y+2	; 0x02
    28aa:	fb 81       	ldd	r31, Y+3	; 0x03
    28ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    28ae:	8f 3f       	cpi	r24, 0xFF	; 255
    28b0:	19 f4       	brne	.+6      	; 0x28b8 <xQueuePeek+0xca>
    28b2:	ea 81       	ldd	r30, Y+2	; 0x02
    28b4:	fb 81       	ldd	r31, Y+3	; 0x03
    28b6:	15 8e       	std	Z+29, r1	; 0x1d
    28b8:	ea 81       	ldd	r30, Y+2	; 0x02
    28ba:	fb 81       	ldd	r31, Y+3	; 0x03
    28bc:	86 8d       	ldd	r24, Z+30	; 0x1e
    28be:	8f 3f       	cpi	r24, 0xFF	; 255
    28c0:	19 f4       	brne	.+6      	; 0x28c8 <xQueuePeek+0xda>
    28c2:	ea 81       	ldd	r30, Y+2	; 0x02
    28c4:	fb 81       	ldd	r31, Y+3	; 0x03
    28c6:	16 8e       	std	Z+30, r1	; 0x1e
    28c8:	0f 90       	pop	r0
    28ca:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    28cc:	ce 01       	movw	r24, r28
    28ce:	07 96       	adiw	r24, 0x07	; 7
    28d0:	9e 01       	movw	r18, r28
    28d2:	22 5f       	subi	r18, 0xF2	; 242
    28d4:	3f 4f       	sbci	r19, 0xFF	; 255
    28d6:	b9 01       	movw	r22, r18
    28d8:	0e 94 bd 26 	call	0x4d7a	; 0x4d7a <xTaskCheckForTimeOut>
    28dc:	88 23       	and	r24, r24
    28de:	09 f5       	brne	.+66     	; 0x2922 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    28e0:	8a 81       	ldd	r24, Y+2	; 0x02
    28e2:	9b 81       	ldd	r25, Y+3	; 0x03
    28e4:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <prvIsQueueEmpty>
    28e8:	88 23       	and	r24, r24
    28ea:	a1 f0       	breq	.+40     	; 0x2914 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    28ec:	8a 81       	ldd	r24, Y+2	; 0x02
    28ee:	9b 81       	ldd	r25, Y+3	; 0x03
    28f0:	41 96       	adiw	r24, 0x11	; 17
    28f2:	2e 85       	ldd	r18, Y+14	; 0x0e
    28f4:	3f 85       	ldd	r19, Y+15	; 0x0f
    28f6:	b9 01       	movw	r22, r18
    28f8:	0e 94 6c 25 	call	0x4ad8	; 0x4ad8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    28fc:	8a 81       	ldd	r24, Y+2	; 0x02
    28fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2900:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2904:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    2908:	88 23       	and	r24, r24
    290a:	09 f0       	breq	.+2      	; 0x290e <xQueuePeek+0x120>
    290c:	85 cf       	rjmp	.-246    	; 0x2818 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    290e:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
    2912:	82 cf       	rjmp	.-252    	; 0x2818 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2914:	8a 81       	ldd	r24, Y+2	; 0x02
    2916:	9b 81       	ldd	r25, Y+3	; 0x03
    2918:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    291c:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    2920:	7b cf       	rjmp	.-266    	; 0x2818 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2922:	8a 81       	ldd	r24, Y+2	; 0x02
    2924:	9b 81       	ldd	r25, Y+3	; 0x03
    2926:	0e 94 c7 16 	call	0x2d8e	; 0x2d8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    292a:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    292e:	8a 81       	ldd	r24, Y+2	; 0x02
    2930:	9b 81       	ldd	r25, Y+3	; 0x03
    2932:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <prvIsQueueEmpty>
    2936:	88 23       	and	r24, r24
    2938:	09 f4       	brne	.+2      	; 0x293c <xQueuePeek+0x14e>
    293a:	6e cf       	rjmp	.-292    	; 0x2818 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    293c:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    293e:	88 89       	ldd	r24, Y+16	; 0x10
}
    2940:	60 96       	adiw	r28, 0x10	; 16
    2942:	0f b6       	in	r0, 0x3f	; 63
    2944:	f8 94       	cli
    2946:	de bf       	out	0x3e, r29	; 62
    2948:	0f be       	out	0x3f, r0	; 63
    294a:	cd bf       	out	0x3d, r28	; 61
    294c:	cf 91       	pop	r28
    294e:	df 91       	pop	r29
    2950:	08 95       	ret

00002952 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2952:	df 93       	push	r29
    2954:	cf 93       	push	r28
    2956:	cd b7       	in	r28, 0x3d	; 61
    2958:	de b7       	in	r29, 0x3e	; 62
    295a:	2c 97       	sbiw	r28, 0x0c	; 12
    295c:	0f b6       	in	r0, 0x3f	; 63
    295e:	f8 94       	cli
    2960:	de bf       	out	0x3e, r29	; 62
    2962:	0f be       	out	0x3f, r0	; 63
    2964:	cd bf       	out	0x3d, r28	; 61
    2966:	98 87       	std	Y+8, r25	; 0x08
    2968:	8f 83       	std	Y+7, r24	; 0x07
    296a:	7a 87       	std	Y+10, r23	; 0x0a
    296c:	69 87       	std	Y+9, r22	; 0x09
    296e:	5c 87       	std	Y+12, r21	; 0x0c
    2970:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2972:	8f 81       	ldd	r24, Y+7	; 0x07
    2974:	98 85       	ldd	r25, Y+8	; 0x08
    2976:	9c 83       	std	Y+4, r25	; 0x04
    2978:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    297a:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    297c:	eb 81       	ldd	r30, Y+3	; 0x03
    297e:	fc 81       	ldd	r31, Y+4	; 0x04
    2980:	82 8d       	ldd	r24, Z+26	; 0x1a
    2982:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2984:	8a 81       	ldd	r24, Y+2	; 0x02
    2986:	88 23       	and	r24, r24
    2988:	81 f1       	breq	.+96     	; 0x29ea <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    298a:	eb 81       	ldd	r30, Y+3	; 0x03
    298c:	fc 81       	ldd	r31, Y+4	; 0x04
    298e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2990:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2992:	8b 81       	ldd	r24, Y+3	; 0x03
    2994:	9c 81       	ldd	r25, Y+4	; 0x04
    2996:	29 85       	ldd	r18, Y+9	; 0x09
    2998:	3a 85       	ldd	r19, Y+10	; 0x0a
    299a:	b9 01       	movw	r22, r18
    299c:	0e 94 80 16 	call	0x2d00	; 0x2d00 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    29a0:	8a 81       	ldd	r24, Y+2	; 0x02
    29a2:	81 50       	subi	r24, 0x01	; 1
    29a4:	eb 81       	ldd	r30, Y+3	; 0x03
    29a6:	fc 81       	ldd	r31, Y+4	; 0x04
    29a8:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    29aa:	89 81       	ldd	r24, Y+1	; 0x01
    29ac:	8f 3f       	cpi	r24, 0xFF	; 255
    29ae:	a9 f4       	brne	.+42     	; 0x29da <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    29b0:	eb 81       	ldd	r30, Y+3	; 0x03
    29b2:	fc 81       	ldd	r31, Y+4	; 0x04
    29b4:	80 85       	ldd	r24, Z+8	; 0x08
    29b6:	88 23       	and	r24, r24
    29b8:	a9 f0       	breq	.+42     	; 0x29e4 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    29ba:	8b 81       	ldd	r24, Y+3	; 0x03
    29bc:	9c 81       	ldd	r25, Y+4	; 0x04
    29be:	08 96       	adiw	r24, 0x08	; 8
    29c0:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    29c4:	88 23       	and	r24, r24
    29c6:	71 f0       	breq	.+28     	; 0x29e4 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    29c8:	8b 85       	ldd	r24, Y+11	; 0x0b
    29ca:	9c 85       	ldd	r25, Y+12	; 0x0c
    29cc:	00 97       	sbiw	r24, 0x00	; 0
    29ce:	51 f0       	breq	.+20     	; 0x29e4 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    29d0:	eb 85       	ldd	r30, Y+11	; 0x0b
    29d2:	fc 85       	ldd	r31, Y+12	; 0x0c
    29d4:	81 e0       	ldi	r24, 0x01	; 1
    29d6:	80 83       	st	Z, r24
    29d8:	05 c0       	rjmp	.+10     	; 0x29e4 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    29da:	89 81       	ldd	r24, Y+1	; 0x01
    29dc:	8f 5f       	subi	r24, 0xFF	; 255
    29de:	eb 81       	ldd	r30, Y+3	; 0x03
    29e0:	fc 81       	ldd	r31, Y+4	; 0x04
    29e2:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    29e4:	81 e0       	ldi	r24, 0x01	; 1
    29e6:	8e 83       	std	Y+6, r24	; 0x06
    29e8:	01 c0       	rjmp	.+2      	; 0x29ec <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    29ea:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    29ec:	8e 81       	ldd	r24, Y+6	; 0x06
}
    29ee:	2c 96       	adiw	r28, 0x0c	; 12
    29f0:	0f b6       	in	r0, 0x3f	; 63
    29f2:	f8 94       	cli
    29f4:	de bf       	out	0x3e, r29	; 62
    29f6:	0f be       	out	0x3f, r0	; 63
    29f8:	cd bf       	out	0x3d, r28	; 61
    29fa:	cf 91       	pop	r28
    29fc:	df 91       	pop	r29
    29fe:	08 95       	ret

00002a00 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    2a00:	df 93       	push	r29
    2a02:	cf 93       	push	r28
    2a04:	cd b7       	in	r28, 0x3d	; 61
    2a06:	de b7       	in	r29, 0x3e	; 62
    2a08:	2a 97       	sbiw	r28, 0x0a	; 10
    2a0a:	0f b6       	in	r0, 0x3f	; 63
    2a0c:	f8 94       	cli
    2a0e:	de bf       	out	0x3e, r29	; 62
    2a10:	0f be       	out	0x3f, r0	; 63
    2a12:	cd bf       	out	0x3d, r28	; 61
    2a14:	98 87       	std	Y+8, r25	; 0x08
    2a16:	8f 83       	std	Y+7, r24	; 0x07
    2a18:	7a 87       	std	Y+10, r23	; 0x0a
    2a1a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2a1c:	8f 81       	ldd	r24, Y+7	; 0x07
    2a1e:	98 85       	ldd	r25, Y+8	; 0x08
    2a20:	9a 83       	std	Y+2, r25	; 0x02
    2a22:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2a24:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2a26:	e9 81       	ldd	r30, Y+1	; 0x01
    2a28:	fa 81       	ldd	r31, Y+2	; 0x02
    2a2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a2c:	88 23       	and	r24, r24
    2a2e:	b1 f0       	breq	.+44     	; 0x2a5c <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2a30:	e9 81       	ldd	r30, Y+1	; 0x01
    2a32:	fa 81       	ldd	r31, Y+2	; 0x02
    2a34:	86 81       	ldd	r24, Z+6	; 0x06
    2a36:	97 81       	ldd	r25, Z+7	; 0x07
    2a38:	9c 83       	std	Y+4, r25	; 0x04
    2a3a:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2a3c:	89 81       	ldd	r24, Y+1	; 0x01
    2a3e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a40:	29 85       	ldd	r18, Y+9	; 0x09
    2a42:	3a 85       	ldd	r19, Y+10	; 0x0a
    2a44:	b9 01       	movw	r22, r18
    2a46:	0e 94 80 16 	call	0x2d00	; 0x2d00 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2a4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a50:	9c 81       	ldd	r25, Y+4	; 0x04
    2a52:	97 83       	std	Z+7, r25	; 0x07
    2a54:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2a56:	81 e0       	ldi	r24, 0x01	; 1
    2a58:	8e 83       	std	Y+6, r24	; 0x06
    2a5a:	01 c0       	rjmp	.+2      	; 0x2a5e <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2a5c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2a5e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2a60:	2a 96       	adiw	r28, 0x0a	; 10
    2a62:	0f b6       	in	r0, 0x3f	; 63
    2a64:	f8 94       	cli
    2a66:	de bf       	out	0x3e, r29	; 62
    2a68:	0f be       	out	0x3f, r0	; 63
    2a6a:	cd bf       	out	0x3d, r28	; 61
    2a6c:	cf 91       	pop	r28
    2a6e:	df 91       	pop	r29
    2a70:	08 95       	ret

00002a72 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2a72:	df 93       	push	r29
    2a74:	cf 93       	push	r28
    2a76:	00 d0       	rcall	.+0      	; 0x2a78 <uxQueueMessagesWaiting+0x6>
    2a78:	0f 92       	push	r0
    2a7a:	cd b7       	in	r28, 0x3d	; 61
    2a7c:	de b7       	in	r29, 0x3e	; 62
    2a7e:	9b 83       	std	Y+3, r25	; 0x03
    2a80:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2a82:	0f b6       	in	r0, 0x3f	; 63
    2a84:	f8 94       	cli
    2a86:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2a88:	ea 81       	ldd	r30, Y+2	; 0x02
    2a8a:	fb 81       	ldd	r31, Y+3	; 0x03
    2a8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a8e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2a90:	0f 90       	pop	r0
    2a92:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2a94:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2a96:	0f 90       	pop	r0
    2a98:	0f 90       	pop	r0
    2a9a:	0f 90       	pop	r0
    2a9c:	cf 91       	pop	r28
    2a9e:	df 91       	pop	r29
    2aa0:	08 95       	ret

00002aa2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2aa2:	df 93       	push	r29
    2aa4:	cf 93       	push	r28
    2aa6:	00 d0       	rcall	.+0      	; 0x2aa8 <uxQueueSpacesAvailable+0x6>
    2aa8:	00 d0       	rcall	.+0      	; 0x2aaa <uxQueueSpacesAvailable+0x8>
    2aaa:	0f 92       	push	r0
    2aac:	cd b7       	in	r28, 0x3d	; 61
    2aae:	de b7       	in	r29, 0x3e	; 62
    2ab0:	9d 83       	std	Y+5, r25	; 0x05
    2ab2:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2ab4:	8c 81       	ldd	r24, Y+4	; 0x04
    2ab6:	9d 81       	ldd	r25, Y+5	; 0x05
    2ab8:	9a 83       	std	Y+2, r25	; 0x02
    2aba:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2abc:	0f b6       	in	r0, 0x3f	; 63
    2abe:	f8 94       	cli
    2ac0:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2ac2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ac4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ac6:	93 8d       	ldd	r25, Z+27	; 0x1b
    2ac8:	e9 81       	ldd	r30, Y+1	; 0x01
    2aca:	fa 81       	ldd	r31, Y+2	; 0x02
    2acc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ace:	29 2f       	mov	r18, r25
    2ad0:	28 1b       	sub	r18, r24
    2ad2:	82 2f       	mov	r24, r18
    2ad4:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2ad6:	0f 90       	pop	r0
    2ad8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2ada:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2adc:	0f 90       	pop	r0
    2ade:	0f 90       	pop	r0
    2ae0:	0f 90       	pop	r0
    2ae2:	0f 90       	pop	r0
    2ae4:	0f 90       	pop	r0
    2ae6:	cf 91       	pop	r28
    2ae8:	df 91       	pop	r29
    2aea:	08 95       	ret

00002aec <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2aec:	df 93       	push	r29
    2aee:	cf 93       	push	r28
    2af0:	00 d0       	rcall	.+0      	; 0x2af2 <uxQueueMessagesWaitingFromISR+0x6>
    2af2:	00 d0       	rcall	.+0      	; 0x2af4 <uxQueueMessagesWaitingFromISR+0x8>
    2af4:	0f 92       	push	r0
    2af6:	cd b7       	in	r28, 0x3d	; 61
    2af8:	de b7       	in	r29, 0x3e	; 62
    2afa:	9d 83       	std	Y+5, r25	; 0x05
    2afc:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2afe:	8c 81       	ldd	r24, Y+4	; 0x04
    2b00:	9d 81       	ldd	r25, Y+5	; 0x05
    2b02:	9a 83       	std	Y+2, r25	; 0x02
    2b04:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2b06:	e9 81       	ldd	r30, Y+1	; 0x01
    2b08:	fa 81       	ldd	r31, Y+2	; 0x02
    2b0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b0c:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2b0e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2b10:	0f 90       	pop	r0
    2b12:	0f 90       	pop	r0
    2b14:	0f 90       	pop	r0
    2b16:	0f 90       	pop	r0
    2b18:	0f 90       	pop	r0
    2b1a:	cf 91       	pop	r28
    2b1c:	df 91       	pop	r29
    2b1e:	08 95       	ret

00002b20 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2b20:	df 93       	push	r29
    2b22:	cf 93       	push	r28
    2b24:	00 d0       	rcall	.+0      	; 0x2b26 <vQueueDelete+0x6>
    2b26:	00 d0       	rcall	.+0      	; 0x2b28 <vQueueDelete+0x8>
    2b28:	cd b7       	in	r28, 0x3d	; 61
    2b2a:	de b7       	in	r29, 0x3e	; 62
    2b2c:	9c 83       	std	Y+4, r25	; 0x04
    2b2e:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    2b30:	8b 81       	ldd	r24, Y+3	; 0x03
    2b32:	9c 81       	ldd	r25, Y+4	; 0x04
    2b34:	9a 83       	std	Y+2, r25	; 0x02
    2b36:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2b38:	89 81       	ldd	r24, Y+1	; 0x01
    2b3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b3c:	0e 94 f6 09 	call	0x13ec	; 0x13ec <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2b40:	0f 90       	pop	r0
    2b42:	0f 90       	pop	r0
    2b44:	0f 90       	pop	r0
    2b46:	0f 90       	pop	r0
    2b48:	cf 91       	pop	r28
    2b4a:	df 91       	pop	r29
    2b4c:	08 95       	ret

00002b4e <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    2b4e:	df 93       	push	r29
    2b50:	cf 93       	push	r28
    2b52:	00 d0       	rcall	.+0      	; 0x2b54 <prvGetDisinheritPriorityAfterTimeout+0x6>
    2b54:	0f 92       	push	r0
    2b56:	cd b7       	in	r28, 0x3d	; 61
    2b58:	de b7       	in	r29, 0x3e	; 62
    2b5a:	9b 83       	std	Y+3, r25	; 0x03
    2b5c:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    2b5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2b60:	fb 81       	ldd	r31, Y+3	; 0x03
    2b62:	81 89       	ldd	r24, Z+17	; 0x11
    2b64:	88 23       	and	r24, r24
    2b66:	61 f0       	breq	.+24     	; 0x2b80 <prvGetDisinheritPriorityAfterTimeout+0x32>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    2b68:	ea 81       	ldd	r30, Y+2	; 0x02
    2b6a:	fb 81       	ldd	r31, Y+3	; 0x03
    2b6c:	06 88       	ldd	r0, Z+22	; 0x16
    2b6e:	f7 89       	ldd	r31, Z+23	; 0x17
    2b70:	e0 2d       	mov	r30, r0
    2b72:	80 81       	ld	r24, Z
    2b74:	91 81       	ldd	r25, Z+1	; 0x01
    2b76:	98 2f       	mov	r25, r24
    2b78:	87 e0       	ldi	r24, 0x07	; 7
    2b7a:	89 1b       	sub	r24, r25
    2b7c:	89 83       	std	Y+1, r24	; 0x01
    2b7e:	01 c0       	rjmp	.+2      	; 0x2b82 <prvGetDisinheritPriorityAfterTimeout+0x34>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    2b80:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    2b82:	89 81       	ldd	r24, Y+1	; 0x01
	}
    2b84:	0f 90       	pop	r0
    2b86:	0f 90       	pop	r0
    2b88:	0f 90       	pop	r0
    2b8a:	cf 91       	pop	r28
    2b8c:	df 91       	pop	r29
    2b8e:	08 95       	ret

00002b90 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2b90:	df 93       	push	r29
    2b92:	cf 93       	push	r28
    2b94:	cd b7       	in	r28, 0x3d	; 61
    2b96:	de b7       	in	r29, 0x3e	; 62
    2b98:	27 97       	sbiw	r28, 0x07	; 7
    2b9a:	0f b6       	in	r0, 0x3f	; 63
    2b9c:	f8 94       	cli
    2b9e:	de bf       	out	0x3e, r29	; 62
    2ba0:	0f be       	out	0x3f, r0	; 63
    2ba2:	cd bf       	out	0x3d, r28	; 61
    2ba4:	9c 83       	std	Y+4, r25	; 0x04
    2ba6:	8b 83       	std	Y+3, r24	; 0x03
    2ba8:	7e 83       	std	Y+6, r23	; 0x06
    2baa:	6d 83       	std	Y+5, r22	; 0x05
    2bac:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2bae:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2bb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb4:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bb6:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    2bba:	fc 81       	ldd	r31, Y+4	; 0x04
    2bbc:	84 8d       	ldd	r24, Z+28	; 0x1c
    2bbe:	88 23       	and	r24, r24
    2bc0:	99 f4       	brne	.+38     	; 0x2be8 <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2bc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc6:	80 81       	ld	r24, Z
    2bc8:	91 81       	ldd	r25, Z+1	; 0x01
    2bca:	00 97       	sbiw	r24, 0x00	; 0
    2bcc:	09 f0       	breq	.+2      	; 0x2bd0 <prvCopyDataToQueue+0x40>
    2bce:	89 c0       	rjmp	.+274    	; 0x2ce2 <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    2bd0:	eb 81       	ldd	r30, Y+3	; 0x03
    2bd2:	fc 81       	ldd	r31, Y+4	; 0x04
    2bd4:	84 81       	ldd	r24, Z+4	; 0x04
    2bd6:	95 81       	ldd	r25, Z+5	; 0x05
    2bd8:	0e 94 9f 28 	call	0x513e	; 0x513e <xTaskPriorityDisinherit>
    2bdc:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    2bde:	eb 81       	ldd	r30, Y+3	; 0x03
    2be0:	fc 81       	ldd	r31, Y+4	; 0x04
    2be2:	15 82       	std	Z+5, r1	; 0x05
    2be4:	14 82       	std	Z+4, r1	; 0x04
    2be6:	7d c0       	rjmp	.+250    	; 0x2ce2 <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2be8:	8f 81       	ldd	r24, Y+7	; 0x07
    2bea:	88 23       	and	r24, r24
    2bec:	99 f5       	brne	.+102    	; 0x2c54 <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2bee:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf2:	62 81       	ldd	r22, Z+2	; 0x02
    2bf4:	73 81       	ldd	r23, Z+3	; 0x03
    2bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    2bfa:	84 8d       	ldd	r24, Z+28	; 0x1c
    2bfc:	48 2f       	mov	r20, r24
    2bfe:	50 e0       	ldi	r21, 0x00	; 0
    2c00:	2d 81       	ldd	r18, Y+5	; 0x05
    2c02:	3e 81       	ldd	r19, Y+6	; 0x06
    2c04:	cb 01       	movw	r24, r22
    2c06:	b9 01       	movw	r22, r18
    2c08:	0e 94 15 2e 	call	0x5c2a	; 0x5c2a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2c0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c10:	22 81       	ldd	r18, Z+2	; 0x02
    2c12:	33 81       	ldd	r19, Z+3	; 0x03
    2c14:	eb 81       	ldd	r30, Y+3	; 0x03
    2c16:	fc 81       	ldd	r31, Y+4	; 0x04
    2c18:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c1a:	88 2f       	mov	r24, r24
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	82 0f       	add	r24, r18
    2c20:	93 1f       	adc	r25, r19
    2c22:	eb 81       	ldd	r30, Y+3	; 0x03
    2c24:	fc 81       	ldd	r31, Y+4	; 0x04
    2c26:	93 83       	std	Z+3, r25	; 0x03
    2c28:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2c2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c2e:	22 81       	ldd	r18, Z+2	; 0x02
    2c30:	33 81       	ldd	r19, Z+3	; 0x03
    2c32:	eb 81       	ldd	r30, Y+3	; 0x03
    2c34:	fc 81       	ldd	r31, Y+4	; 0x04
    2c36:	84 81       	ldd	r24, Z+4	; 0x04
    2c38:	95 81       	ldd	r25, Z+5	; 0x05
    2c3a:	28 17       	cp	r18, r24
    2c3c:	39 07       	cpc	r19, r25
    2c3e:	08 f4       	brcc	.+2      	; 0x2c42 <prvCopyDataToQueue+0xb2>
    2c40:	50 c0       	rjmp	.+160    	; 0x2ce2 <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2c42:	eb 81       	ldd	r30, Y+3	; 0x03
    2c44:	fc 81       	ldd	r31, Y+4	; 0x04
    2c46:	80 81       	ld	r24, Z
    2c48:	91 81       	ldd	r25, Z+1	; 0x01
    2c4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c4e:	93 83       	std	Z+3, r25	; 0x03
    2c50:	82 83       	std	Z+2, r24	; 0x02
    2c52:	47 c0       	rjmp	.+142    	; 0x2ce2 <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2c54:	eb 81       	ldd	r30, Y+3	; 0x03
    2c56:	fc 81       	ldd	r31, Y+4	; 0x04
    2c58:	66 81       	ldd	r22, Z+6	; 0x06
    2c5a:	77 81       	ldd	r23, Z+7	; 0x07
    2c5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c60:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c62:	48 2f       	mov	r20, r24
    2c64:	50 e0       	ldi	r21, 0x00	; 0
    2c66:	2d 81       	ldd	r18, Y+5	; 0x05
    2c68:	3e 81       	ldd	r19, Y+6	; 0x06
    2c6a:	cb 01       	movw	r24, r22
    2c6c:	b9 01       	movw	r22, r18
    2c6e:	0e 94 15 2e 	call	0x5c2a	; 0x5c2a <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2c72:	eb 81       	ldd	r30, Y+3	; 0x03
    2c74:	fc 81       	ldd	r31, Y+4	; 0x04
    2c76:	26 81       	ldd	r18, Z+6	; 0x06
    2c78:	37 81       	ldd	r19, Z+7	; 0x07
    2c7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c7e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2c80:	88 2f       	mov	r24, r24
    2c82:	90 e0       	ldi	r25, 0x00	; 0
    2c84:	90 95       	com	r25
    2c86:	81 95       	neg	r24
    2c88:	9f 4f       	sbci	r25, 0xFF	; 255
    2c8a:	82 0f       	add	r24, r18
    2c8c:	93 1f       	adc	r25, r19
    2c8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c90:	fc 81       	ldd	r31, Y+4	; 0x04
    2c92:	97 83       	std	Z+7, r25	; 0x07
    2c94:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2c96:	eb 81       	ldd	r30, Y+3	; 0x03
    2c98:	fc 81       	ldd	r31, Y+4	; 0x04
    2c9a:	26 81       	ldd	r18, Z+6	; 0x06
    2c9c:	37 81       	ldd	r19, Z+7	; 0x07
    2c9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2ca0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca2:	80 81       	ld	r24, Z
    2ca4:	91 81       	ldd	r25, Z+1	; 0x01
    2ca6:	28 17       	cp	r18, r24
    2ca8:	39 07       	cpc	r19, r25
    2caa:	90 f4       	brcc	.+36     	; 0x2cd0 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2cac:	eb 81       	ldd	r30, Y+3	; 0x03
    2cae:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb0:	24 81       	ldd	r18, Z+4	; 0x04
    2cb2:	35 81       	ldd	r19, Z+5	; 0x05
    2cb4:	eb 81       	ldd	r30, Y+3	; 0x03
    2cb6:	fc 81       	ldd	r31, Y+4	; 0x04
    2cb8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2cba:	88 2f       	mov	r24, r24
    2cbc:	90 e0       	ldi	r25, 0x00	; 0
    2cbe:	90 95       	com	r25
    2cc0:	81 95       	neg	r24
    2cc2:	9f 4f       	sbci	r25, 0xFF	; 255
    2cc4:	82 0f       	add	r24, r18
    2cc6:	93 1f       	adc	r25, r19
    2cc8:	eb 81       	ldd	r30, Y+3	; 0x03
    2cca:	fc 81       	ldd	r31, Y+4	; 0x04
    2ccc:	97 83       	std	Z+7, r25	; 0x07
    2cce:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2cd0:	8f 81       	ldd	r24, Y+7	; 0x07
    2cd2:	82 30       	cpi	r24, 0x02	; 2
    2cd4:	31 f4       	brne	.+12     	; 0x2ce2 <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2cd6:	89 81       	ldd	r24, Y+1	; 0x01
    2cd8:	88 23       	and	r24, r24
    2cda:	19 f0       	breq	.+6      	; 0x2ce2 <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2cdc:	89 81       	ldd	r24, Y+1	; 0x01
    2cde:	81 50       	subi	r24, 0x01	; 1
    2ce0:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2ce2:	89 81       	ldd	r24, Y+1	; 0x01
    2ce4:	8f 5f       	subi	r24, 0xFF	; 255
    2ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    2cea:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2cec:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2cee:	27 96       	adiw	r28, 0x07	; 7
    2cf0:	0f b6       	in	r0, 0x3f	; 63
    2cf2:	f8 94       	cli
    2cf4:	de bf       	out	0x3e, r29	; 62
    2cf6:	0f be       	out	0x3f, r0	; 63
    2cf8:	cd bf       	out	0x3d, r28	; 61
    2cfa:	cf 91       	pop	r28
    2cfc:	df 91       	pop	r29
    2cfe:	08 95       	ret

00002d00 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    2d00:	df 93       	push	r29
    2d02:	cf 93       	push	r28
    2d04:	00 d0       	rcall	.+0      	; 0x2d06 <prvCopyDataFromQueue+0x6>
    2d06:	00 d0       	rcall	.+0      	; 0x2d08 <prvCopyDataFromQueue+0x8>
    2d08:	cd b7       	in	r28, 0x3d	; 61
    2d0a:	de b7       	in	r29, 0x3e	; 62
    2d0c:	9a 83       	std	Y+2, r25	; 0x02
    2d0e:	89 83       	std	Y+1, r24	; 0x01
    2d10:	7c 83       	std	Y+4, r23	; 0x04
    2d12:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2d14:	e9 81       	ldd	r30, Y+1	; 0x01
    2d16:	fa 81       	ldd	r31, Y+2	; 0x02
    2d18:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d1a:	88 23       	and	r24, r24
    2d1c:	89 f1       	breq	.+98     	; 0x2d80 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2d1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d20:	fa 81       	ldd	r31, Y+2	; 0x02
    2d22:	26 81       	ldd	r18, Z+6	; 0x06
    2d24:	37 81       	ldd	r19, Z+7	; 0x07
    2d26:	e9 81       	ldd	r30, Y+1	; 0x01
    2d28:	fa 81       	ldd	r31, Y+2	; 0x02
    2d2a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d2c:	88 2f       	mov	r24, r24
    2d2e:	90 e0       	ldi	r25, 0x00	; 0
    2d30:	82 0f       	add	r24, r18
    2d32:	93 1f       	adc	r25, r19
    2d34:	e9 81       	ldd	r30, Y+1	; 0x01
    2d36:	fa 81       	ldd	r31, Y+2	; 0x02
    2d38:	97 83       	std	Z+7, r25	; 0x07
    2d3a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2d3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d40:	26 81       	ldd	r18, Z+6	; 0x06
    2d42:	37 81       	ldd	r19, Z+7	; 0x07
    2d44:	e9 81       	ldd	r30, Y+1	; 0x01
    2d46:	fa 81       	ldd	r31, Y+2	; 0x02
    2d48:	84 81       	ldd	r24, Z+4	; 0x04
    2d4a:	95 81       	ldd	r25, Z+5	; 0x05
    2d4c:	28 17       	cp	r18, r24
    2d4e:	39 07       	cpc	r19, r25
    2d50:	40 f0       	brcs	.+16     	; 0x2d62 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2d52:	e9 81       	ldd	r30, Y+1	; 0x01
    2d54:	fa 81       	ldd	r31, Y+2	; 0x02
    2d56:	80 81       	ld	r24, Z
    2d58:	91 81       	ldd	r25, Z+1	; 0x01
    2d5a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d5c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d5e:	97 83       	std	Z+7, r25	; 0x07
    2d60:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2d62:	e9 81       	ldd	r30, Y+1	; 0x01
    2d64:	fa 81       	ldd	r31, Y+2	; 0x02
    2d66:	46 81       	ldd	r20, Z+6	; 0x06
    2d68:	57 81       	ldd	r21, Z+7	; 0x07
    2d6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d70:	28 2f       	mov	r18, r24
    2d72:	30 e0       	ldi	r19, 0x00	; 0
    2d74:	8b 81       	ldd	r24, Y+3	; 0x03
    2d76:	9c 81       	ldd	r25, Y+4	; 0x04
    2d78:	ba 01       	movw	r22, r20
    2d7a:	a9 01       	movw	r20, r18
    2d7c:	0e 94 15 2e 	call	0x5c2a	; 0x5c2a <memcpy>
	}
}
    2d80:	0f 90       	pop	r0
    2d82:	0f 90       	pop	r0
    2d84:	0f 90       	pop	r0
    2d86:	0f 90       	pop	r0
    2d88:	cf 91       	pop	r28
    2d8a:	df 91       	pop	r29
    2d8c:	08 95       	ret

00002d8e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2d8e:	df 93       	push	r29
    2d90:	cf 93       	push	r28
    2d92:	00 d0       	rcall	.+0      	; 0x2d94 <prvUnlockQueue+0x6>
    2d94:	00 d0       	rcall	.+0      	; 0x2d96 <prvUnlockQueue+0x8>
    2d96:	cd b7       	in	r28, 0x3d	; 61
    2d98:	de b7       	in	r29, 0x3e	; 62
    2d9a:	9c 83       	std	Y+4, r25	; 0x04
    2d9c:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2d9e:	0f b6       	in	r0, 0x3f	; 63
    2da0:	f8 94       	cli
    2da2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2da4:	eb 81       	ldd	r30, Y+3	; 0x03
    2da6:	fc 81       	ldd	r31, Y+4	; 0x04
    2da8:	86 8d       	ldd	r24, Z+30	; 0x1e
    2daa:	8a 83       	std	Y+2, r24	; 0x02
    2dac:	11 c0       	rjmp	.+34     	; 0x2dd0 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2dae:	eb 81       	ldd	r30, Y+3	; 0x03
    2db0:	fc 81       	ldd	r31, Y+4	; 0x04
    2db2:	81 89       	ldd	r24, Z+17	; 0x11
    2db4:	88 23       	and	r24, r24
    2db6:	79 f0       	breq	.+30     	; 0x2dd6 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2db8:	8b 81       	ldd	r24, Y+3	; 0x03
    2dba:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbc:	41 96       	adiw	r24, 0x11	; 17
    2dbe:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    2dc2:	88 23       	and	r24, r24
    2dc4:	11 f0       	breq	.+4      	; 0x2dca <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2dc6:	0e 94 2a 27 	call	0x4e54	; 0x4e54 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2dca:	8a 81       	ldd	r24, Y+2	; 0x02
    2dcc:	81 50       	subi	r24, 0x01	; 1
    2dce:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd2:	18 16       	cp	r1, r24
    2dd4:	64 f3       	brlt	.-40     	; 0x2dae <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2dd6:	eb 81       	ldd	r30, Y+3	; 0x03
    2dd8:	fc 81       	ldd	r31, Y+4	; 0x04
    2dda:	8f ef       	ldi	r24, 0xFF	; 255
    2ddc:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2dde:	0f 90       	pop	r0
    2de0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2de2:	0f b6       	in	r0, 0x3f	; 63
    2de4:	f8 94       	cli
    2de6:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2de8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dea:	fc 81       	ldd	r31, Y+4	; 0x04
    2dec:	85 8d       	ldd	r24, Z+29	; 0x1d
    2dee:	89 83       	std	Y+1, r24	; 0x01
    2df0:	11 c0       	rjmp	.+34     	; 0x2e14 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2df2:	eb 81       	ldd	r30, Y+3	; 0x03
    2df4:	fc 81       	ldd	r31, Y+4	; 0x04
    2df6:	80 85       	ldd	r24, Z+8	; 0x08
    2df8:	88 23       	and	r24, r24
    2dfa:	79 f0       	breq	.+30     	; 0x2e1a <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2e00:	08 96       	adiw	r24, 0x08	; 8
    2e02:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <xTaskRemoveFromEventList>
    2e06:	88 23       	and	r24, r24
    2e08:	11 f0       	breq	.+4      	; 0x2e0e <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2e0a:	0e 94 2a 27 	call	0x4e54	; 0x4e54 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2e0e:	89 81       	ldd	r24, Y+1	; 0x01
    2e10:	81 50       	subi	r24, 0x01	; 1
    2e12:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2e14:	89 81       	ldd	r24, Y+1	; 0x01
    2e16:	18 16       	cp	r1, r24
    2e18:	64 f3       	brlt	.-40     	; 0x2df2 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2e1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e1e:	8f ef       	ldi	r24, 0xFF	; 255
    2e20:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2e22:	0f 90       	pop	r0
    2e24:	0f be       	out	0x3f, r0	; 63
}
    2e26:	0f 90       	pop	r0
    2e28:	0f 90       	pop	r0
    2e2a:	0f 90       	pop	r0
    2e2c:	0f 90       	pop	r0
    2e2e:	cf 91       	pop	r28
    2e30:	df 91       	pop	r29
    2e32:	08 95       	ret

00002e34 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2e34:	df 93       	push	r29
    2e36:	cf 93       	push	r28
    2e38:	00 d0       	rcall	.+0      	; 0x2e3a <prvIsQueueEmpty+0x6>
    2e3a:	0f 92       	push	r0
    2e3c:	cd b7       	in	r28, 0x3d	; 61
    2e3e:	de b7       	in	r29, 0x3e	; 62
    2e40:	9b 83       	std	Y+3, r25	; 0x03
    2e42:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2e44:	0f b6       	in	r0, 0x3f	; 63
    2e46:	f8 94       	cli
    2e48:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2e4a:	ea 81       	ldd	r30, Y+2	; 0x02
    2e4c:	fb 81       	ldd	r31, Y+3	; 0x03
    2e4e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e50:	88 23       	and	r24, r24
    2e52:	19 f4       	brne	.+6      	; 0x2e5a <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2e54:	81 e0       	ldi	r24, 0x01	; 1
    2e56:	89 83       	std	Y+1, r24	; 0x01
    2e58:	01 c0       	rjmp	.+2      	; 0x2e5c <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2e5a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2e5c:	0f 90       	pop	r0
    2e5e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2e60:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e62:	0f 90       	pop	r0
    2e64:	0f 90       	pop	r0
    2e66:	0f 90       	pop	r0
    2e68:	cf 91       	pop	r28
    2e6a:	df 91       	pop	r29
    2e6c:	08 95       	ret

00002e6e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2e6e:	df 93       	push	r29
    2e70:	cf 93       	push	r28
    2e72:	00 d0       	rcall	.+0      	; 0x2e74 <xQueueIsQueueEmptyFromISR+0x6>
    2e74:	00 d0       	rcall	.+0      	; 0x2e76 <xQueueIsQueueEmptyFromISR+0x8>
    2e76:	0f 92       	push	r0
    2e78:	cd b7       	in	r28, 0x3d	; 61
    2e7a:	de b7       	in	r29, 0x3e	; 62
    2e7c:	9d 83       	std	Y+5, r25	; 0x05
    2e7e:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2e80:	8c 81       	ldd	r24, Y+4	; 0x04
    2e82:	9d 81       	ldd	r25, Y+5	; 0x05
    2e84:	9a 83       	std	Y+2, r25	; 0x02
    2e86:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2e88:	e9 81       	ldd	r30, Y+1	; 0x01
    2e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e8c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e8e:	88 23       	and	r24, r24
    2e90:	19 f4       	brne	.+6      	; 0x2e98 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2e92:	81 e0       	ldi	r24, 0x01	; 1
    2e94:	8b 83       	std	Y+3, r24	; 0x03
    2e96:	01 c0       	rjmp	.+2      	; 0x2e9a <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2e98:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2e9a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2e9c:	0f 90       	pop	r0
    2e9e:	0f 90       	pop	r0
    2ea0:	0f 90       	pop	r0
    2ea2:	0f 90       	pop	r0
    2ea4:	0f 90       	pop	r0
    2ea6:	cf 91       	pop	r28
    2ea8:	df 91       	pop	r29
    2eaa:	08 95       	ret

00002eac <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2eac:	df 93       	push	r29
    2eae:	cf 93       	push	r28
    2eb0:	00 d0       	rcall	.+0      	; 0x2eb2 <prvIsQueueFull+0x6>
    2eb2:	0f 92       	push	r0
    2eb4:	cd b7       	in	r28, 0x3d	; 61
    2eb6:	de b7       	in	r29, 0x3e	; 62
    2eb8:	9b 83       	std	Y+3, r25	; 0x03
    2eba:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2ebc:	0f b6       	in	r0, 0x3f	; 63
    2ebe:	f8 94       	cli
    2ec0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2ec2:	ea 81       	ldd	r30, Y+2	; 0x02
    2ec4:	fb 81       	ldd	r31, Y+3	; 0x03
    2ec6:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ec8:	ea 81       	ldd	r30, Y+2	; 0x02
    2eca:	fb 81       	ldd	r31, Y+3	; 0x03
    2ecc:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ece:	98 17       	cp	r25, r24
    2ed0:	19 f4       	brne	.+6      	; 0x2ed8 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2ed2:	81 e0       	ldi	r24, 0x01	; 1
    2ed4:	89 83       	std	Y+1, r24	; 0x01
    2ed6:	01 c0       	rjmp	.+2      	; 0x2eda <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2ed8:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2eda:	0f 90       	pop	r0
    2edc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2ede:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ee0:	0f 90       	pop	r0
    2ee2:	0f 90       	pop	r0
    2ee4:	0f 90       	pop	r0
    2ee6:	cf 91       	pop	r28
    2ee8:	df 91       	pop	r29
    2eea:	08 95       	ret

00002eec <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2eec:	df 93       	push	r29
    2eee:	cf 93       	push	r28
    2ef0:	00 d0       	rcall	.+0      	; 0x2ef2 <xQueueIsQueueFullFromISR+0x6>
    2ef2:	00 d0       	rcall	.+0      	; 0x2ef4 <xQueueIsQueueFullFromISR+0x8>
    2ef4:	0f 92       	push	r0
    2ef6:	cd b7       	in	r28, 0x3d	; 61
    2ef8:	de b7       	in	r29, 0x3e	; 62
    2efa:	9d 83       	std	Y+5, r25	; 0x05
    2efc:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2efe:	8c 81       	ldd	r24, Y+4	; 0x04
    2f00:	9d 81       	ldd	r25, Y+5	; 0x05
    2f02:	9a 83       	std	Y+2, r25	; 0x02
    2f04:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2f06:	e9 81       	ldd	r30, Y+1	; 0x01
    2f08:	fa 81       	ldd	r31, Y+2	; 0x02
    2f0a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f10:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f12:	98 17       	cp	r25, r24
    2f14:	19 f4       	brne	.+6      	; 0x2f1c <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2f16:	81 e0       	ldi	r24, 0x01	; 1
    2f18:	8b 83       	std	Y+3, r24	; 0x03
    2f1a:	01 c0       	rjmp	.+2      	; 0x2f1e <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2f1c:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2f1e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2f20:	0f 90       	pop	r0
    2f22:	0f 90       	pop	r0
    2f24:	0f 90       	pop	r0
    2f26:	0f 90       	pop	r0
    2f28:	0f 90       	pop	r0
    2f2a:	cf 91       	pop	r28
    2f2c:	df 91       	pop	r29
    2f2e:	08 95       	ret

00002f30 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2f30:	0f 93       	push	r16
    2f32:	df 93       	push	r29
    2f34:	cf 93       	push	r28
    2f36:	cd b7       	in	r28, 0x3d	; 61
    2f38:	de b7       	in	r29, 0x3e	; 62
    2f3a:	28 97       	sbiw	r28, 0x08	; 8
    2f3c:	0f b6       	in	r0, 0x3f	; 63
    2f3e:	f8 94       	cli
    2f40:	de bf       	out	0x3e, r29	; 62
    2f42:	0f be       	out	0x3f, r0	; 63
    2f44:	cd bf       	out	0x3d, r28	; 61
    2f46:	9d 83       	std	Y+5, r25	; 0x05
    2f48:	8c 83       	std	Y+4, r24	; 0x04
    2f4a:	7f 83       	std	Y+7, r23	; 0x07
    2f4c:	6e 83       	std	Y+6, r22	; 0x06
    2f4e:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2f50:	88 85       	ldd	r24, Y+8	; 0x08
    2f52:	81 30       	cpi	r24, 0x01	; 1
    2f54:	19 f4       	brne	.+6      	; 0x2f5c <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2f56:	81 e0       	ldi	r24, 0x01	; 1
    2f58:	89 83       	std	Y+1, r24	; 0x01
    2f5a:	01 c0       	rjmp	.+2      	; 0x2f5e <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2f5c:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2f5e:	8e 81       	ldd	r24, Y+6	; 0x06
    2f60:	9f 81       	ldd	r25, Y+7	; 0x07
    2f62:	00 97       	sbiw	r24, 0x00	; 0
    2f64:	21 f4       	brne	.+8      	; 0x2f6e <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2f66:	81 e0       	ldi	r24, 0x01	; 1
    2f68:	90 e0       	ldi	r25, 0x00	; 0
    2f6a:	9f 83       	std	Y+7, r25	; 0x07
    2f6c:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2f6e:	8c 81       	ldd	r24, Y+4	; 0x04
    2f70:	9d 81       	ldd	r25, Y+5	; 0x05
    2f72:	01 96       	adiw	r24, 0x01	; 1
    2f74:	9d 83       	std	Y+5, r25	; 0x05
    2f76:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2f78:	8c 81       	ldd	r24, Y+4	; 0x04
    2f7a:	9d 81       	ldd	r25, Y+5	; 0x05
    2f7c:	0f 96       	adiw	r24, 0x0f	; 15
    2f7e:	0e 94 a0 09 	call	0x1340	; 0x1340 <pvPortMalloc>
    2f82:	9b 83       	std	Y+3, r25	; 0x03
    2f84:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2f86:	8a 81       	ldd	r24, Y+2	; 0x02
    2f88:	9b 81       	ldd	r25, Y+3	; 0x03
    2f8a:	00 97       	sbiw	r24, 0x00	; 0
    2f8c:	89 f0       	breq	.+34     	; 0x2fb0 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2f8e:	6a 81       	ldd	r22, Y+2	; 0x02
    2f90:	7b 81       	ldd	r23, Y+3	; 0x03
    2f92:	8a 81       	ldd	r24, Y+2	; 0x02
    2f94:	9b 81       	ldd	r25, Y+3	; 0x03
    2f96:	9c 01       	movw	r18, r24
    2f98:	21 5f       	subi	r18, 0xF1	; 241
    2f9a:	3f 4f       	sbci	r19, 0xFF	; 255
    2f9c:	4c 81       	ldd	r20, Y+4	; 0x04
    2f9e:	5d 81       	ldd	r21, Y+5	; 0x05
    2fa0:	ee 81       	ldd	r30, Y+6	; 0x06
    2fa2:	ff 81       	ldd	r31, Y+7	; 0x07
    2fa4:	cb 01       	movw	r24, r22
    2fa6:	b9 01       	movw	r22, r18
    2fa8:	9f 01       	movw	r18, r30
    2faa:	09 81       	ldd	r16, Y+1	; 0x01
    2fac:	0e 94 f0 1e 	call	0x3de0	; 0x3de0 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2fb0:	8a 81       	ldd	r24, Y+2	; 0x02
    2fb2:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2fb4:	28 96       	adiw	r28, 0x08	; 8
    2fb6:	0f b6       	in	r0, 0x3f	; 63
    2fb8:	f8 94       	cli
    2fba:	de bf       	out	0x3e, r29	; 62
    2fbc:	0f be       	out	0x3f, r0	; 63
    2fbe:	cd bf       	out	0x3d, r28	; 61
    2fc0:	cf 91       	pop	r28
    2fc2:	df 91       	pop	r29
    2fc4:	0f 91       	pop	r16
    2fc6:	08 95       	ret

00002fc8 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2fc8:	df 93       	push	r29
    2fca:	cf 93       	push	r28
    2fcc:	00 d0       	rcall	.+0      	; 0x2fce <vStreamBufferDelete+0x6>
    2fce:	00 d0       	rcall	.+0      	; 0x2fd0 <vStreamBufferDelete+0x8>
    2fd0:	cd b7       	in	r28, 0x3d	; 61
    2fd2:	de b7       	in	r29, 0x3e	; 62
    2fd4:	9c 83       	std	Y+4, r25	; 0x04
    2fd6:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2fd8:	8b 81       	ldd	r24, Y+3	; 0x03
    2fda:	9c 81       	ldd	r25, Y+4	; 0x04
    2fdc:	9a 83       	std	Y+2, r25	; 0x02
    2fde:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2fe0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe4:	86 85       	ldd	r24, Z+14	; 0x0e
    2fe6:	88 2f       	mov	r24, r24
    2fe8:	90 e0       	ldi	r25, 0x00	; 0
    2fea:	82 70       	andi	r24, 0x02	; 2
    2fec:	90 70       	andi	r25, 0x00	; 0
    2fee:	00 97       	sbiw	r24, 0x00	; 0
    2ff0:	29 f4       	brne	.+10     	; 0x2ffc <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2ff2:	89 81       	ldd	r24, Y+1	; 0x01
    2ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff6:	0e 94 f6 09 	call	0x13ec	; 0x13ec <vPortFree>
    2ffa:	08 c0       	rjmp	.+16     	; 0x300c <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2ffc:	89 81       	ldd	r24, Y+1	; 0x01
    2ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    3000:	60 e0       	ldi	r22, 0x00	; 0
    3002:	70 e0       	ldi	r23, 0x00	; 0
    3004:	4f e0       	ldi	r20, 0x0F	; 15
    3006:	50 e0       	ldi	r21, 0x00	; 0
    3008:	0e 94 1e 2e 	call	0x5c3c	; 0x5c3c <memset>
	}
}
    300c:	0f 90       	pop	r0
    300e:	0f 90       	pop	r0
    3010:	0f 90       	pop	r0
    3012:	0f 90       	pop	r0
    3014:	cf 91       	pop	r28
    3016:	df 91       	pop	r29
    3018:	08 95       	ret

0000301a <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    301a:	0f 93       	push	r16
    301c:	df 93       	push	r29
    301e:	cf 93       	push	r28
    3020:	00 d0       	rcall	.+0      	; 0x3022 <xStreamBufferReset+0x8>
    3022:	00 d0       	rcall	.+0      	; 0x3024 <xStreamBufferReset+0xa>
    3024:	0f 92       	push	r0
    3026:	cd b7       	in	r28, 0x3d	; 61
    3028:	de b7       	in	r29, 0x3e	; 62
    302a:	9d 83       	std	Y+5, r25	; 0x05
    302c:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    302e:	8c 81       	ldd	r24, Y+4	; 0x04
    3030:	9d 81       	ldd	r25, Y+5	; 0x05
    3032:	9b 83       	std	Y+3, r25	; 0x03
    3034:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    3036:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    3038:	0f b6       	in	r0, 0x3f	; 63
    303a:	f8 94       	cli
    303c:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    303e:	ea 81       	ldd	r30, Y+2	; 0x02
    3040:	fb 81       	ldd	r31, Y+3	; 0x03
    3042:	80 85       	ldd	r24, Z+8	; 0x08
    3044:	91 85       	ldd	r25, Z+9	; 0x09
    3046:	00 97       	sbiw	r24, 0x00	; 0
    3048:	f1 f4       	brne	.+60     	; 0x3086 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    304a:	ea 81       	ldd	r30, Y+2	; 0x02
    304c:	fb 81       	ldd	r31, Y+3	; 0x03
    304e:	82 85       	ldd	r24, Z+10	; 0x0a
    3050:	93 85       	ldd	r25, Z+11	; 0x0b
    3052:	00 97       	sbiw	r24, 0x00	; 0
    3054:	c1 f4       	brne	.+48     	; 0x3086 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3056:	ea 81       	ldd	r30, Y+2	; 0x02
    3058:	fb 81       	ldd	r31, Y+3	; 0x03
    305a:	24 85       	ldd	r18, Z+12	; 0x0c
    305c:	35 85       	ldd	r19, Z+13	; 0x0d
    305e:	ea 81       	ldd	r30, Y+2	; 0x02
    3060:	fb 81       	ldd	r31, Y+3	; 0x03
    3062:	44 81       	ldd	r20, Z+4	; 0x04
    3064:	55 81       	ldd	r21, Z+5	; 0x05
    3066:	ea 81       	ldd	r30, Y+2	; 0x02
    3068:	fb 81       	ldd	r31, Y+3	; 0x03
    306a:	a6 81       	ldd	r26, Z+6	; 0x06
    306c:	b7 81       	ldd	r27, Z+7	; 0x07
    306e:	ea 81       	ldd	r30, Y+2	; 0x02
    3070:	fb 81       	ldd	r31, Y+3	; 0x03
    3072:	e6 85       	ldd	r30, Z+14	; 0x0e
    3074:	8a 81       	ldd	r24, Y+2	; 0x02
    3076:	9b 81       	ldd	r25, Y+3	; 0x03
    3078:	b9 01       	movw	r22, r18
    307a:	9d 01       	movw	r18, r26
    307c:	0e 2f       	mov	r16, r30
    307e:	0e 94 f0 1e 	call	0x3de0	; 0x3de0 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    3082:	81 e0       	ldi	r24, 0x01	; 1
    3084:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    3086:	0f 90       	pop	r0
    3088:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    308a:	89 81       	ldd	r24, Y+1	; 0x01
}
    308c:	0f 90       	pop	r0
    308e:	0f 90       	pop	r0
    3090:	0f 90       	pop	r0
    3092:	0f 90       	pop	r0
    3094:	0f 90       	pop	r0
    3096:	cf 91       	pop	r28
    3098:	df 91       	pop	r29
    309a:	0f 91       	pop	r16
    309c:	08 95       	ret

0000309e <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    309e:	df 93       	push	r29
    30a0:	cf 93       	push	r28
    30a2:	cd b7       	in	r28, 0x3d	; 61
    30a4:	de b7       	in	r29, 0x3e	; 62
    30a6:	27 97       	sbiw	r28, 0x07	; 7
    30a8:	0f b6       	in	r0, 0x3f	; 63
    30aa:	f8 94       	cli
    30ac:	de bf       	out	0x3e, r29	; 62
    30ae:	0f be       	out	0x3f, r0	; 63
    30b0:	cd bf       	out	0x3d, r28	; 61
    30b2:	9d 83       	std	Y+5, r25	; 0x05
    30b4:	8c 83       	std	Y+4, r24	; 0x04
    30b6:	7f 83       	std	Y+7, r23	; 0x07
    30b8:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    30ba:	8c 81       	ldd	r24, Y+4	; 0x04
    30bc:	9d 81       	ldd	r25, Y+5	; 0x05
    30be:	9b 83       	std	Y+3, r25	; 0x03
    30c0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    30c2:	8e 81       	ldd	r24, Y+6	; 0x06
    30c4:	9f 81       	ldd	r25, Y+7	; 0x07
    30c6:	00 97       	sbiw	r24, 0x00	; 0
    30c8:	21 f4       	brne	.+8      	; 0x30d2 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    30ca:	81 e0       	ldi	r24, 0x01	; 1
    30cc:	90 e0       	ldi	r25, 0x00	; 0
    30ce:	9f 83       	std	Y+7, r25	; 0x07
    30d0:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    30d2:	ea 81       	ldd	r30, Y+2	; 0x02
    30d4:	fb 81       	ldd	r31, Y+3	; 0x03
    30d6:	24 81       	ldd	r18, Z+4	; 0x04
    30d8:	35 81       	ldd	r19, Z+5	; 0x05
    30da:	8e 81       	ldd	r24, Y+6	; 0x06
    30dc:	9f 81       	ldd	r25, Y+7	; 0x07
    30de:	28 17       	cp	r18, r24
    30e0:	39 07       	cpc	r19, r25
    30e2:	48 f0       	brcs	.+18     	; 0x30f6 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    30e4:	ea 81       	ldd	r30, Y+2	; 0x02
    30e6:	fb 81       	ldd	r31, Y+3	; 0x03
    30e8:	8e 81       	ldd	r24, Y+6	; 0x06
    30ea:	9f 81       	ldd	r25, Y+7	; 0x07
    30ec:	97 83       	std	Z+7, r25	; 0x07
    30ee:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    30f0:	81 e0       	ldi	r24, 0x01	; 1
    30f2:	89 83       	std	Y+1, r24	; 0x01
    30f4:	01 c0       	rjmp	.+2      	; 0x30f8 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    30f6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    30f8:	89 81       	ldd	r24, Y+1	; 0x01
}
    30fa:	27 96       	adiw	r28, 0x07	; 7
    30fc:	0f b6       	in	r0, 0x3f	; 63
    30fe:	f8 94       	cli
    3100:	de bf       	out	0x3e, r29	; 62
    3102:	0f be       	out	0x3f, r0	; 63
    3104:	cd bf       	out	0x3d, r28	; 61
    3106:	cf 91       	pop	r28
    3108:	df 91       	pop	r29
    310a:	08 95       	ret

0000310c <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    310c:	df 93       	push	r29
    310e:	cf 93       	push	r28
    3110:	00 d0       	rcall	.+0      	; 0x3112 <xStreamBufferSpacesAvailable+0x6>
    3112:	00 d0       	rcall	.+0      	; 0x3114 <xStreamBufferSpacesAvailable+0x8>
    3114:	00 d0       	rcall	.+0      	; 0x3116 <xStreamBufferSpacesAvailable+0xa>
    3116:	cd b7       	in	r28, 0x3d	; 61
    3118:	de b7       	in	r29, 0x3e	; 62
    311a:	9e 83       	std	Y+6, r25	; 0x06
    311c:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    311e:	8d 81       	ldd	r24, Y+5	; 0x05
    3120:	9e 81       	ldd	r25, Y+6	; 0x06
    3122:	9c 83       	std	Y+4, r25	; 0x04
    3124:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    3126:	eb 81       	ldd	r30, Y+3	; 0x03
    3128:	fc 81       	ldd	r31, Y+4	; 0x04
    312a:	24 81       	ldd	r18, Z+4	; 0x04
    312c:	35 81       	ldd	r19, Z+5	; 0x05
    312e:	eb 81       	ldd	r30, Y+3	; 0x03
    3130:	fc 81       	ldd	r31, Y+4	; 0x04
    3132:	80 81       	ld	r24, Z
    3134:	91 81       	ldd	r25, Z+1	; 0x01
    3136:	82 0f       	add	r24, r18
    3138:	93 1f       	adc	r25, r19
    313a:	9a 83       	std	Y+2, r25	; 0x02
    313c:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    313e:	eb 81       	ldd	r30, Y+3	; 0x03
    3140:	fc 81       	ldd	r31, Y+4	; 0x04
    3142:	22 81       	ldd	r18, Z+2	; 0x02
    3144:	33 81       	ldd	r19, Z+3	; 0x03
    3146:	89 81       	ldd	r24, Y+1	; 0x01
    3148:	9a 81       	ldd	r25, Y+2	; 0x02
    314a:	82 1b       	sub	r24, r18
    314c:	93 0b       	sbc	r25, r19
    314e:	9a 83       	std	Y+2, r25	; 0x02
    3150:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    3152:	89 81       	ldd	r24, Y+1	; 0x01
    3154:	9a 81       	ldd	r25, Y+2	; 0x02
    3156:	01 97       	sbiw	r24, 0x01	; 1
    3158:	9a 83       	std	Y+2, r25	; 0x02
    315a:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    315c:	eb 81       	ldd	r30, Y+3	; 0x03
    315e:	fc 81       	ldd	r31, Y+4	; 0x04
    3160:	24 81       	ldd	r18, Z+4	; 0x04
    3162:	35 81       	ldd	r19, Z+5	; 0x05
    3164:	89 81       	ldd	r24, Y+1	; 0x01
    3166:	9a 81       	ldd	r25, Y+2	; 0x02
    3168:	82 17       	cp	r24, r18
    316a:	93 07       	cpc	r25, r19
    316c:	50 f0       	brcs	.+20     	; 0x3182 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    316e:	eb 81       	ldd	r30, Y+3	; 0x03
    3170:	fc 81       	ldd	r31, Y+4	; 0x04
    3172:	24 81       	ldd	r18, Z+4	; 0x04
    3174:	35 81       	ldd	r19, Z+5	; 0x05
    3176:	89 81       	ldd	r24, Y+1	; 0x01
    3178:	9a 81       	ldd	r25, Y+2	; 0x02
    317a:	82 1b       	sub	r24, r18
    317c:	93 0b       	sbc	r25, r19
    317e:	9a 83       	std	Y+2, r25	; 0x02
    3180:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    3182:	89 81       	ldd	r24, Y+1	; 0x01
    3184:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3186:	26 96       	adiw	r28, 0x06	; 6
    3188:	0f b6       	in	r0, 0x3f	; 63
    318a:	f8 94       	cli
    318c:	de bf       	out	0x3e, r29	; 62
    318e:	0f be       	out	0x3f, r0	; 63
    3190:	cd bf       	out	0x3d, r28	; 61
    3192:	cf 91       	pop	r28
    3194:	df 91       	pop	r29
    3196:	08 95       	ret

00003198 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    3198:	df 93       	push	r29
    319a:	cf 93       	push	r28
    319c:	00 d0       	rcall	.+0      	; 0x319e <xStreamBufferBytesAvailable+0x6>
    319e:	00 d0       	rcall	.+0      	; 0x31a0 <xStreamBufferBytesAvailable+0x8>
    31a0:	00 d0       	rcall	.+0      	; 0x31a2 <xStreamBufferBytesAvailable+0xa>
    31a2:	cd b7       	in	r28, 0x3d	; 61
    31a4:	de b7       	in	r29, 0x3e	; 62
    31a6:	9e 83       	std	Y+6, r25	; 0x06
    31a8:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    31aa:	8d 81       	ldd	r24, Y+5	; 0x05
    31ac:	9e 81       	ldd	r25, Y+6	; 0x06
    31ae:	9c 83       	std	Y+4, r25	; 0x04
    31b0:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    31b2:	8b 81       	ldd	r24, Y+3	; 0x03
    31b4:	9c 81       	ldd	r25, Y+4	; 0x04
    31b6:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <prvBytesInBuffer>
    31ba:	9a 83       	std	Y+2, r25	; 0x02
    31bc:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    31be:	89 81       	ldd	r24, Y+1	; 0x01
    31c0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    31c2:	26 96       	adiw	r28, 0x06	; 6
    31c4:	0f b6       	in	r0, 0x3f	; 63
    31c6:	f8 94       	cli
    31c8:	de bf       	out	0x3e, r29	; 62
    31ca:	0f be       	out	0x3f, r0	; 63
    31cc:	cd bf       	out	0x3d, r28	; 61
    31ce:	cf 91       	pop	r28
    31d0:	df 91       	pop	r29
    31d2:	08 95       	ret

000031d4 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    31d4:	ef 92       	push	r14
    31d6:	ff 92       	push	r15
    31d8:	0f 93       	push	r16
    31da:	1f 93       	push	r17
    31dc:	df 93       	push	r29
    31de:	cf 93       	push	r28
    31e0:	cd b7       	in	r28, 0x3d	; 61
    31e2:	de b7       	in	r29, 0x3e	; 62
    31e4:	63 97       	sbiw	r28, 0x13	; 19
    31e6:	0f b6       	in	r0, 0x3f	; 63
    31e8:	f8 94       	cli
    31ea:	de bf       	out	0x3e, r29	; 62
    31ec:	0f be       	out	0x3f, r0	; 63
    31ee:	cd bf       	out	0x3d, r28	; 61
    31f0:	9d 87       	std	Y+13, r25	; 0x0d
    31f2:	8c 87       	std	Y+12, r24	; 0x0c
    31f4:	7f 87       	std	Y+15, r23	; 0x0f
    31f6:	6e 87       	std	Y+14, r22	; 0x0e
    31f8:	59 8b       	std	Y+17, r21	; 0x11
    31fa:	48 8b       	std	Y+16, r20	; 0x10
    31fc:	3b 8b       	std	Y+19, r19	; 0x13
    31fe:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3200:	8c 85       	ldd	r24, Y+12	; 0x0c
    3202:	9d 85       	ldd	r25, Y+13	; 0x0d
    3204:	98 87       	std	Y+8, r25	; 0x08
    3206:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    3208:	1c 82       	std	Y+4, r1	; 0x04
    320a:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    320c:	88 89       	ldd	r24, Y+16	; 0x10
    320e:	99 89       	ldd	r25, Y+17	; 0x11
    3210:	9a 83       	std	Y+2, r25	; 0x02
    3212:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3214:	ef 81       	ldd	r30, Y+7	; 0x07
    3216:	f8 85       	ldd	r31, Y+8	; 0x08
    3218:	86 85       	ldd	r24, Z+14	; 0x0e
    321a:	88 2f       	mov	r24, r24
    321c:	90 e0       	ldi	r25, 0x00	; 0
    321e:	81 70       	andi	r24, 0x01	; 1
    3220:	90 70       	andi	r25, 0x00	; 0
    3222:	88 23       	and	r24, r24
    3224:	29 f0       	breq	.+10     	; 0x3230 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3226:	89 81       	ldd	r24, Y+1	; 0x01
    3228:	9a 81       	ldd	r25, Y+2	; 0x02
    322a:	02 96       	adiw	r24, 0x02	; 2
    322c:	9a 83       	std	Y+2, r25	; 0x02
    322e:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    3230:	8a 89       	ldd	r24, Y+18	; 0x12
    3232:	9b 89       	ldd	r25, Y+19	; 0x13
    3234:	00 97       	sbiw	r24, 0x00	; 0
    3236:	09 f4       	brne	.+2      	; 0x323a <xStreamBufferSend+0x66>
    3238:	40 c0       	rjmp	.+128    	; 0x32ba <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    323a:	ce 01       	movw	r24, r28
    323c:	09 96       	adiw	r24, 0x09	; 9
    323e:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    3242:	0f b6       	in	r0, 0x3f	; 63
    3244:	f8 94       	cli
    3246:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    3248:	8f 81       	ldd	r24, Y+7	; 0x07
    324a:	98 85       	ldd	r25, Y+8	; 0x08
    324c:	0e 94 86 18 	call	0x310c	; 0x310c <xStreamBufferSpacesAvailable>
    3250:	9c 83       	std	Y+4, r25	; 0x04
    3252:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    3254:	2b 81       	ldd	r18, Y+3	; 0x03
    3256:	3c 81       	ldd	r19, Y+4	; 0x04
    3258:	89 81       	ldd	r24, Y+1	; 0x01
    325a:	9a 81       	ldd	r25, Y+2	; 0x02
    325c:	28 17       	cp	r18, r24
    325e:	39 07       	cpc	r19, r25
    3260:	50 f5       	brcc	.+84     	; 0x32b6 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    3262:	80 e0       	ldi	r24, 0x00	; 0
    3264:	90 e0       	ldi	r25, 0x00	; 0
    3266:	0e 94 53 2d 	call	0x5aa6	; 0x5aa6 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    326a:	0e 94 ef 27 	call	0x4fde	; 0x4fde <xTaskGetCurrentTaskHandle>
    326e:	ef 81       	ldd	r30, Y+7	; 0x07
    3270:	f8 85       	ldd	r31, Y+8	; 0x08
    3272:	93 87       	std	Z+11, r25	; 0x0b
    3274:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    3276:	0f 90       	pop	r0
    3278:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    327a:	ea 89       	ldd	r30, Y+18	; 0x12
    327c:	fb 89       	ldd	r31, Y+19	; 0x13
    327e:	60 e0       	ldi	r22, 0x00	; 0
    3280:	70 e0       	ldi	r23, 0x00	; 0
    3282:	80 e0       	ldi	r24, 0x00	; 0
    3284:	90 e0       	ldi	r25, 0x00	; 0
    3286:	20 e0       	ldi	r18, 0x00	; 0
    3288:	30 e0       	ldi	r19, 0x00	; 0
    328a:	40 e0       	ldi	r20, 0x00	; 0
    328c:	50 e0       	ldi	r21, 0x00	; 0
    328e:	00 e0       	ldi	r16, 0x00	; 0
    3290:	10 e0       	ldi	r17, 0x00	; 0
    3292:	7f 01       	movw	r14, r30
    3294:	0e 94 5c 2a 	call	0x54b8	; 0x54b8 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    3298:	ef 81       	ldd	r30, Y+7	; 0x07
    329a:	f8 85       	ldd	r31, Y+8	; 0x08
    329c:	13 86       	std	Z+11, r1	; 0x0b
    329e:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    32a0:	ce 01       	movw	r24, r28
    32a2:	09 96       	adiw	r24, 0x09	; 9
    32a4:	9e 01       	movw	r18, r28
    32a6:	2e 5e       	subi	r18, 0xEE	; 238
    32a8:	3f 4f       	sbci	r19, 0xFF	; 255
    32aa:	b9 01       	movw	r22, r18
    32ac:	0e 94 bd 26 	call	0x4d7a	; 0x4d7a <xTaskCheckForTimeOut>
    32b0:	88 23       	and	r24, r24
    32b2:	39 f2       	breq	.-114    	; 0x3242 <xStreamBufferSend+0x6e>
    32b4:	02 c0       	rjmp	.+4      	; 0x32ba <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    32b6:	0f 90       	pop	r0
    32b8:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    32ba:	8b 81       	ldd	r24, Y+3	; 0x03
    32bc:	9c 81       	ldd	r25, Y+4	; 0x04
    32be:	00 97       	sbiw	r24, 0x00	; 0
    32c0:	31 f4       	brne	.+12     	; 0x32ce <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    32c2:	8f 81       	ldd	r24, Y+7	; 0x07
    32c4:	98 85       	ldd	r25, Y+8	; 0x08
    32c6:	0e 94 86 18 	call	0x310c	; 0x310c <xStreamBufferSpacesAvailable>
    32ca:	9c 83       	std	Y+4, r25	; 0x04
    32cc:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    32ce:	8f 81       	ldd	r24, Y+7	; 0x07
    32d0:	98 85       	ldd	r25, Y+8	; 0x08
    32d2:	2e 85       	ldd	r18, Y+14	; 0x0e
    32d4:	3f 85       	ldd	r19, Y+15	; 0x0f
    32d6:	48 89       	ldd	r20, Y+16	; 0x10
    32d8:	59 89       	ldd	r21, Y+17	; 0x11
    32da:	eb 81       	ldd	r30, Y+3	; 0x03
    32dc:	fc 81       	ldd	r31, Y+4	; 0x04
    32de:	a9 81       	ldd	r26, Y+1	; 0x01
    32e0:	ba 81       	ldd	r27, Y+2	; 0x02
    32e2:	b9 01       	movw	r22, r18
    32e4:	9f 01       	movw	r18, r30
    32e6:	8d 01       	movw	r16, r26
    32e8:	0e 94 2f 1a 	call	0x345e	; 0x345e <prvWriteMessageToBuffer>
    32ec:	9e 83       	std	Y+6, r25	; 0x06
    32ee:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    32f0:	8d 81       	ldd	r24, Y+5	; 0x05
    32f2:	9e 81       	ldd	r25, Y+6	; 0x06
    32f4:	00 97       	sbiw	r24, 0x00	; 0
    32f6:	39 f1       	breq	.+78     	; 0x3346 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    32f8:	8f 81       	ldd	r24, Y+7	; 0x07
    32fa:	98 85       	ldd	r25, Y+8	; 0x08
    32fc:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <prvBytesInBuffer>
    3300:	9c 01       	movw	r18, r24
    3302:	ef 81       	ldd	r30, Y+7	; 0x07
    3304:	f8 85       	ldd	r31, Y+8	; 0x08
    3306:	86 81       	ldd	r24, Z+6	; 0x06
    3308:	97 81       	ldd	r25, Z+7	; 0x07
    330a:	28 17       	cp	r18, r24
    330c:	39 07       	cpc	r19, r25
    330e:	d8 f0       	brcs	.+54     	; 0x3346 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    3310:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
    3314:	ef 81       	ldd	r30, Y+7	; 0x07
    3316:	f8 85       	ldd	r31, Y+8	; 0x08
    3318:	80 85       	ldd	r24, Z+8	; 0x08
    331a:	91 85       	ldd	r25, Z+9	; 0x09
    331c:	00 97       	sbiw	r24, 0x00	; 0
    331e:	89 f0       	breq	.+34     	; 0x3342 <xStreamBufferSend+0x16e>
    3320:	ef 81       	ldd	r30, Y+7	; 0x07
    3322:	f8 85       	ldd	r31, Y+8	; 0x08
    3324:	80 85       	ldd	r24, Z+8	; 0x08
    3326:	91 85       	ldd	r25, Z+9	; 0x09
    3328:	40 e0       	ldi	r20, 0x00	; 0
    332a:	50 e0       	ldi	r21, 0x00	; 0
    332c:	60 e0       	ldi	r22, 0x00	; 0
    332e:	70 e0       	ldi	r23, 0x00	; 0
    3330:	20 e0       	ldi	r18, 0x00	; 0
    3332:	00 e0       	ldi	r16, 0x00	; 0
    3334:	10 e0       	ldi	r17, 0x00	; 0
    3336:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <xTaskGenericNotify>
    333a:	ef 81       	ldd	r30, Y+7	; 0x07
    333c:	f8 85       	ldd	r31, Y+8	; 0x08
    333e:	11 86       	std	Z+9, r1	; 0x09
    3340:	10 86       	std	Z+8, r1	; 0x08
    3342:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    3346:	8d 81       	ldd	r24, Y+5	; 0x05
    3348:	9e 81       	ldd	r25, Y+6	; 0x06
}
    334a:	63 96       	adiw	r28, 0x13	; 19
    334c:	0f b6       	in	r0, 0x3f	; 63
    334e:	f8 94       	cli
    3350:	de bf       	out	0x3e, r29	; 62
    3352:	0f be       	out	0x3f, r0	; 63
    3354:	cd bf       	out	0x3d, r28	; 61
    3356:	cf 91       	pop	r28
    3358:	df 91       	pop	r29
    335a:	1f 91       	pop	r17
    335c:	0f 91       	pop	r16
    335e:	ff 90       	pop	r15
    3360:	ef 90       	pop	r14
    3362:	08 95       	ret

00003364 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    3364:	ef 92       	push	r14
    3366:	ff 92       	push	r15
    3368:	0f 93       	push	r16
    336a:	1f 93       	push	r17
    336c:	df 93       	push	r29
    336e:	cf 93       	push	r28
    3370:	cd b7       	in	r28, 0x3d	; 61
    3372:	de b7       	in	r29, 0x3e	; 62
    3374:	61 97       	sbiw	r28, 0x11	; 17
    3376:	0f b6       	in	r0, 0x3f	; 63
    3378:	f8 94       	cli
    337a:	de bf       	out	0x3e, r29	; 62
    337c:	0f be       	out	0x3f, r0	; 63
    337e:	cd bf       	out	0x3d, r28	; 61
    3380:	9b 87       	std	Y+11, r25	; 0x0b
    3382:	8a 87       	std	Y+10, r24	; 0x0a
    3384:	7d 87       	std	Y+13, r23	; 0x0d
    3386:	6c 87       	std	Y+12, r22	; 0x0c
    3388:	5f 87       	std	Y+15, r21	; 0x0f
    338a:	4e 87       	std	Y+14, r20	; 0x0e
    338c:	39 8b       	std	Y+17, r19	; 0x11
    338e:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3390:	8a 85       	ldd	r24, Y+10	; 0x0a
    3392:	9b 85       	ldd	r25, Y+11	; 0x0b
    3394:	99 87       	std	Y+9, r25	; 0x09
    3396:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    3398:	8e 85       	ldd	r24, Y+14	; 0x0e
    339a:	9f 85       	ldd	r25, Y+15	; 0x0f
    339c:	9b 83       	std	Y+3, r25	; 0x03
    339e:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    33a0:	e8 85       	ldd	r30, Y+8	; 0x08
    33a2:	f9 85       	ldd	r31, Y+9	; 0x09
    33a4:	86 85       	ldd	r24, Z+14	; 0x0e
    33a6:	88 2f       	mov	r24, r24
    33a8:	90 e0       	ldi	r25, 0x00	; 0
    33aa:	81 70       	andi	r24, 0x01	; 1
    33ac:	90 70       	andi	r25, 0x00	; 0
    33ae:	88 23       	and	r24, r24
    33b0:	29 f0       	breq	.+10     	; 0x33bc <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    33b2:	8a 81       	ldd	r24, Y+2	; 0x02
    33b4:	9b 81       	ldd	r25, Y+3	; 0x03
    33b6:	02 96       	adiw	r24, 0x02	; 2
    33b8:	9b 83       	std	Y+3, r25	; 0x03
    33ba:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    33bc:	88 85       	ldd	r24, Y+8	; 0x08
    33be:	99 85       	ldd	r25, Y+9	; 0x09
    33c0:	0e 94 86 18 	call	0x310c	; 0x310c <xStreamBufferSpacesAvailable>
    33c4:	9d 83       	std	Y+5, r25	; 0x05
    33c6:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    33c8:	88 85       	ldd	r24, Y+8	; 0x08
    33ca:	99 85       	ldd	r25, Y+9	; 0x09
    33cc:	2c 85       	ldd	r18, Y+12	; 0x0c
    33ce:	3d 85       	ldd	r19, Y+13	; 0x0d
    33d0:	4e 85       	ldd	r20, Y+14	; 0x0e
    33d2:	5f 85       	ldd	r21, Y+15	; 0x0f
    33d4:	ec 81       	ldd	r30, Y+4	; 0x04
    33d6:	fd 81       	ldd	r31, Y+5	; 0x05
    33d8:	aa 81       	ldd	r26, Y+2	; 0x02
    33da:	bb 81       	ldd	r27, Y+3	; 0x03
    33dc:	b9 01       	movw	r22, r18
    33de:	9f 01       	movw	r18, r30
    33e0:	8d 01       	movw	r16, r26
    33e2:	0e 94 2f 1a 	call	0x345e	; 0x345e <prvWriteMessageToBuffer>
    33e6:	9f 83       	std	Y+7, r25	; 0x07
    33e8:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    33ea:	8e 81       	ldd	r24, Y+6	; 0x06
    33ec:	9f 81       	ldd	r25, Y+7	; 0x07
    33ee:	00 97       	sbiw	r24, 0x00	; 0
    33f0:	39 f1       	breq	.+78     	; 0x3440 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    33f2:	88 85       	ldd	r24, Y+8	; 0x08
    33f4:	99 85       	ldd	r25, Y+9	; 0x09
    33f6:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <prvBytesInBuffer>
    33fa:	9c 01       	movw	r18, r24
    33fc:	e8 85       	ldd	r30, Y+8	; 0x08
    33fe:	f9 85       	ldd	r31, Y+9	; 0x09
    3400:	86 81       	ldd	r24, Z+6	; 0x06
    3402:	97 81       	ldd	r25, Z+7	; 0x07
    3404:	28 17       	cp	r18, r24
    3406:	39 07       	cpc	r19, r25
    3408:	d8 f0       	brcs	.+54     	; 0x3440 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    340a:	19 82       	std	Y+1, r1	; 0x01
    340c:	e8 85       	ldd	r30, Y+8	; 0x08
    340e:	f9 85       	ldd	r31, Y+9	; 0x09
    3410:	80 85       	ldd	r24, Z+8	; 0x08
    3412:	91 85       	ldd	r25, Z+9	; 0x09
    3414:	00 97       	sbiw	r24, 0x00	; 0
    3416:	a1 f0       	breq	.+40     	; 0x3440 <xStreamBufferSendFromISR+0xdc>
    3418:	e8 85       	ldd	r30, Y+8	; 0x08
    341a:	f9 85       	ldd	r31, Y+9	; 0x09
    341c:	80 85       	ldd	r24, Z+8	; 0x08
    341e:	91 85       	ldd	r25, Z+9	; 0x09
    3420:	e8 89       	ldd	r30, Y+16	; 0x10
    3422:	f9 89       	ldd	r31, Y+17	; 0x11
    3424:	40 e0       	ldi	r20, 0x00	; 0
    3426:	50 e0       	ldi	r21, 0x00	; 0
    3428:	60 e0       	ldi	r22, 0x00	; 0
    342a:	70 e0       	ldi	r23, 0x00	; 0
    342c:	20 e0       	ldi	r18, 0x00	; 0
    342e:	00 e0       	ldi	r16, 0x00	; 0
    3430:	10 e0       	ldi	r17, 0x00	; 0
    3432:	7f 01       	movw	r14, r30
    3434:	0e 94 d5 2b 	call	0x57aa	; 0x57aa <xTaskGenericNotifyFromISR>
    3438:	e8 85       	ldd	r30, Y+8	; 0x08
    343a:	f9 85       	ldd	r31, Y+9	; 0x09
    343c:	11 86       	std	Z+9, r1	; 0x09
    343e:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    3440:	8e 81       	ldd	r24, Y+6	; 0x06
    3442:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3444:	61 96       	adiw	r28, 0x11	; 17
    3446:	0f b6       	in	r0, 0x3f	; 63
    3448:	f8 94       	cli
    344a:	de bf       	out	0x3e, r29	; 62
    344c:	0f be       	out	0x3f, r0	; 63
    344e:	cd bf       	out	0x3d, r28	; 61
    3450:	cf 91       	pop	r28
    3452:	df 91       	pop	r29
    3454:	1f 91       	pop	r17
    3456:	0f 91       	pop	r16
    3458:	ff 90       	pop	r15
    345a:	ef 90       	pop	r14
    345c:	08 95       	ret

0000345e <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    345e:	0f 93       	push	r16
    3460:	1f 93       	push	r17
    3462:	df 93       	push	r29
    3464:	cf 93       	push	r28
    3466:	cd b7       	in	r28, 0x3d	; 61
    3468:	de b7       	in	r29, 0x3e	; 62
    346a:	61 97       	sbiw	r28, 0x11	; 17
    346c:	0f b6       	in	r0, 0x3f	; 63
    346e:	f8 94       	cli
    3470:	de bf       	out	0x3e, r29	; 62
    3472:	0f be       	out	0x3f, r0	; 63
    3474:	cd bf       	out	0x3d, r28	; 61
    3476:	9d 83       	std	Y+5, r25	; 0x05
    3478:	8c 83       	std	Y+4, r24	; 0x04
    347a:	7f 83       	std	Y+7, r23	; 0x07
    347c:	6e 83       	std	Y+6, r22	; 0x06
    347e:	59 87       	std	Y+9, r21	; 0x09
    3480:	48 87       	std	Y+8, r20	; 0x08
    3482:	3b 87       	std	Y+11, r19	; 0x0b
    3484:	2a 87       	std	Y+10, r18	; 0x0a
    3486:	1d 87       	std	Y+13, r17	; 0x0d
    3488:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    348a:	8a 85       	ldd	r24, Y+10	; 0x0a
    348c:	9b 85       	ldd	r25, Y+11	; 0x0b
    348e:	00 97       	sbiw	r24, 0x00	; 0
    3490:	11 f4       	brne	.+4      	; 0x3496 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    3492:	1b 82       	std	Y+3, r1	; 0x03
    3494:	38 c0       	rjmp	.+112    	; 0x3506 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    3496:	ec 81       	ldd	r30, Y+4	; 0x04
    3498:	fd 81       	ldd	r31, Y+5	; 0x05
    349a:	86 85       	ldd	r24, Z+14	; 0x0e
    349c:	88 2f       	mov	r24, r24
    349e:	90 e0       	ldi	r25, 0x00	; 0
    34a0:	81 70       	andi	r24, 0x01	; 1
    34a2:	90 70       	andi	r25, 0x00	; 0
    34a4:	00 97       	sbiw	r24, 0x00	; 0
    34a6:	d1 f4       	brne	.+52     	; 0x34dc <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    34a8:	81 e0       	ldi	r24, 0x01	; 1
    34aa:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    34ac:	28 85       	ldd	r18, Y+8	; 0x08
    34ae:	39 85       	ldd	r19, Y+9	; 0x09
    34b0:	39 8b       	std	Y+17, r19	; 0x11
    34b2:	28 8b       	std	Y+16, r18	; 0x10
    34b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    34b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    34b8:	9f 87       	std	Y+15, r25	; 0x0f
    34ba:	8e 87       	std	Y+14, r24	; 0x0e
    34bc:	2e 85       	ldd	r18, Y+14	; 0x0e
    34be:	3f 85       	ldd	r19, Y+15	; 0x0f
    34c0:	88 89       	ldd	r24, Y+16	; 0x10
    34c2:	99 89       	ldd	r25, Y+17	; 0x11
    34c4:	82 17       	cp	r24, r18
    34c6:	93 07       	cpc	r25, r19
    34c8:	20 f4       	brcc	.+8      	; 0x34d2 <prvWriteMessageToBuffer+0x74>
    34ca:	28 89       	ldd	r18, Y+16	; 0x10
    34cc:	39 89       	ldd	r19, Y+17	; 0x11
    34ce:	3f 87       	std	Y+15, r19	; 0x0f
    34d0:	2e 87       	std	Y+14, r18	; 0x0e
    34d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    34d4:	9f 85       	ldd	r25, Y+15	; 0x0f
    34d6:	99 87       	std	Y+9, r25	; 0x09
    34d8:	88 87       	std	Y+8, r24	; 0x08
    34da:	15 c0       	rjmp	.+42     	; 0x3506 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    34dc:	2a 85       	ldd	r18, Y+10	; 0x0a
    34de:	3b 85       	ldd	r19, Y+11	; 0x0b
    34e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    34e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    34e4:	28 17       	cp	r18, r24
    34e6:	39 07       	cpc	r19, r25
    34e8:	68 f0       	brcs	.+26     	; 0x3504 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    34ea:	81 e0       	ldi	r24, 0x01	; 1
    34ec:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    34ee:	9e 01       	movw	r18, r28
    34f0:	28 5f       	subi	r18, 0xF8	; 248
    34f2:	3f 4f       	sbci	r19, 0xFF	; 255
    34f4:	8c 81       	ldd	r24, Y+4	; 0x04
    34f6:	9d 81       	ldd	r25, Y+5	; 0x05
    34f8:	b9 01       	movw	r22, r18
    34fa:	42 e0       	ldi	r20, 0x02	; 2
    34fc:	50 e0       	ldi	r21, 0x00	; 0
    34fe:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <prvWriteBytesToBuffer>
    3502:	01 c0       	rjmp	.+2      	; 0x3506 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    3504:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    3506:	8b 81       	ldd	r24, Y+3	; 0x03
    3508:	88 23       	and	r24, r24
    350a:	61 f0       	breq	.+24     	; 0x3524 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    350c:	2e 81       	ldd	r18, Y+6	; 0x06
    350e:	3f 81       	ldd	r19, Y+7	; 0x07
    3510:	48 85       	ldd	r20, Y+8	; 0x08
    3512:	59 85       	ldd	r21, Y+9	; 0x09
    3514:	8c 81       	ldd	r24, Y+4	; 0x04
    3516:	9d 81       	ldd	r25, Y+5	; 0x05
    3518:	b9 01       	movw	r22, r18
    351a:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <prvWriteBytesToBuffer>
    351e:	9a 83       	std	Y+2, r25	; 0x02
    3520:	89 83       	std	Y+1, r24	; 0x01
    3522:	02 c0       	rjmp	.+4      	; 0x3528 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    3524:	1a 82       	std	Y+2, r1	; 0x02
    3526:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3528:	89 81       	ldd	r24, Y+1	; 0x01
    352a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    352c:	61 96       	adiw	r28, 0x11	; 17
    352e:	0f b6       	in	r0, 0x3f	; 63
    3530:	f8 94       	cli
    3532:	de bf       	out	0x3e, r29	; 62
    3534:	0f be       	out	0x3f, r0	; 63
    3536:	cd bf       	out	0x3d, r28	; 61
    3538:	cf 91       	pop	r28
    353a:	df 91       	pop	r29
    353c:	1f 91       	pop	r17
    353e:	0f 91       	pop	r16
    3540:	08 95       	ret

00003542 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3542:	ef 92       	push	r14
    3544:	ff 92       	push	r15
    3546:	0f 93       	push	r16
    3548:	1f 93       	push	r17
    354a:	df 93       	push	r29
    354c:	cf 93       	push	r28
    354e:	cd b7       	in	r28, 0x3d	; 61
    3550:	de b7       	in	r29, 0x3e	; 62
    3552:	60 97       	sbiw	r28, 0x10	; 16
    3554:	0f b6       	in	r0, 0x3f	; 63
    3556:	f8 94       	cli
    3558:	de bf       	out	0x3e, r29	; 62
    355a:	0f be       	out	0x3f, r0	; 63
    355c:	cd bf       	out	0x3d, r28	; 61
    355e:	9a 87       	std	Y+10, r25	; 0x0a
    3560:	89 87       	std	Y+9, r24	; 0x09
    3562:	7c 87       	std	Y+12, r23	; 0x0c
    3564:	6b 87       	std	Y+11, r22	; 0x0b
    3566:	5e 87       	std	Y+14, r21	; 0x0e
    3568:	4d 87       	std	Y+13, r20	; 0x0d
    356a:	38 8b       	std	Y+16, r19	; 0x10
    356c:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    356e:	89 85       	ldd	r24, Y+9	; 0x09
    3570:	9a 85       	ldd	r25, Y+10	; 0x0a
    3572:	98 87       	std	Y+8, r25	; 0x08
    3574:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3576:	1e 82       	std	Y+6, r1	; 0x06
    3578:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    357a:	ef 81       	ldd	r30, Y+7	; 0x07
    357c:	f8 85       	ldd	r31, Y+8	; 0x08
    357e:	86 85       	ldd	r24, Z+14	; 0x0e
    3580:	88 2f       	mov	r24, r24
    3582:	90 e0       	ldi	r25, 0x00	; 0
    3584:	81 70       	andi	r24, 0x01	; 1
    3586:	90 70       	andi	r25, 0x00	; 0
    3588:	88 23       	and	r24, r24
    358a:	29 f0       	breq	.+10     	; 0x3596 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    358c:	82 e0       	ldi	r24, 0x02	; 2
    358e:	90 e0       	ldi	r25, 0x00	; 0
    3590:	9a 83       	std	Y+2, r25	; 0x02
    3592:	89 83       	std	Y+1, r24	; 0x01
    3594:	02 c0       	rjmp	.+4      	; 0x359a <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3596:	1a 82       	std	Y+2, r1	; 0x02
    3598:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    359a:	8f 85       	ldd	r24, Y+15	; 0x0f
    359c:	98 89       	ldd	r25, Y+16	; 0x10
    359e:	00 97       	sbiw	r24, 0x00	; 0
    35a0:	09 f4       	brne	.+2      	; 0x35a4 <xStreamBufferReceive+0x62>
    35a2:	3d c0       	rjmp	.+122    	; 0x361e <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    35a4:	0f b6       	in	r0, 0x3f	; 63
    35a6:	f8 94       	cli
    35a8:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    35aa:	8f 81       	ldd	r24, Y+7	; 0x07
    35ac:	98 85       	ldd	r25, Y+8	; 0x08
    35ae:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <prvBytesInBuffer>
    35b2:	9c 83       	std	Y+4, r25	; 0x04
    35b4:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    35b6:	2b 81       	ldd	r18, Y+3	; 0x03
    35b8:	3c 81       	ldd	r19, Y+4	; 0x04
    35ba:	89 81       	ldd	r24, Y+1	; 0x01
    35bc:	9a 81       	ldd	r25, Y+2	; 0x02
    35be:	82 17       	cp	r24, r18
    35c0:	93 07       	cpc	r25, r19
    35c2:	50 f0       	brcs	.+20     	; 0x35d8 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    35c4:	80 e0       	ldi	r24, 0x00	; 0
    35c6:	90 e0       	ldi	r25, 0x00	; 0
    35c8:	0e 94 53 2d 	call	0x5aa6	; 0x5aa6 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    35cc:	0e 94 ef 27 	call	0x4fde	; 0x4fde <xTaskGetCurrentTaskHandle>
    35d0:	ef 81       	ldd	r30, Y+7	; 0x07
    35d2:	f8 85       	ldd	r31, Y+8	; 0x08
    35d4:	91 87       	std	Z+9, r25	; 0x09
    35d6:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    35d8:	0f 90       	pop	r0
    35da:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    35dc:	2b 81       	ldd	r18, Y+3	; 0x03
    35de:	3c 81       	ldd	r19, Y+4	; 0x04
    35e0:	89 81       	ldd	r24, Y+1	; 0x01
    35e2:	9a 81       	ldd	r25, Y+2	; 0x02
    35e4:	82 17       	cp	r24, r18
    35e6:	93 07       	cpc	r25, r19
    35e8:	00 f1       	brcs	.+64     	; 0x362a <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    35ea:	ef 85       	ldd	r30, Y+15	; 0x0f
    35ec:	f8 89       	ldd	r31, Y+16	; 0x10
    35ee:	60 e0       	ldi	r22, 0x00	; 0
    35f0:	70 e0       	ldi	r23, 0x00	; 0
    35f2:	80 e0       	ldi	r24, 0x00	; 0
    35f4:	90 e0       	ldi	r25, 0x00	; 0
    35f6:	20 e0       	ldi	r18, 0x00	; 0
    35f8:	30 e0       	ldi	r19, 0x00	; 0
    35fa:	40 e0       	ldi	r20, 0x00	; 0
    35fc:	50 e0       	ldi	r21, 0x00	; 0
    35fe:	00 e0       	ldi	r16, 0x00	; 0
    3600:	10 e0       	ldi	r17, 0x00	; 0
    3602:	7f 01       	movw	r14, r30
    3604:	0e 94 5c 2a 	call	0x54b8	; 0x54b8 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    3608:	ef 81       	ldd	r30, Y+7	; 0x07
    360a:	f8 85       	ldd	r31, Y+8	; 0x08
    360c:	11 86       	std	Z+9, r1	; 0x09
    360e:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3610:	8f 81       	ldd	r24, Y+7	; 0x07
    3612:	98 85       	ldd	r25, Y+8	; 0x08
    3614:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <prvBytesInBuffer>
    3618:	9c 83       	std	Y+4, r25	; 0x04
    361a:	8b 83       	std	Y+3, r24	; 0x03
    361c:	06 c0       	rjmp	.+12     	; 0x362a <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    361e:	8f 81       	ldd	r24, Y+7	; 0x07
    3620:	98 85       	ldd	r25, Y+8	; 0x08
    3622:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <prvBytesInBuffer>
    3626:	9c 83       	std	Y+4, r25	; 0x04
    3628:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    362a:	2b 81       	ldd	r18, Y+3	; 0x03
    362c:	3c 81       	ldd	r19, Y+4	; 0x04
    362e:	89 81       	ldd	r24, Y+1	; 0x01
    3630:	9a 81       	ldd	r25, Y+2	; 0x02
    3632:	82 17       	cp	r24, r18
    3634:	93 07       	cpc	r25, r19
    3636:	80 f5       	brcc	.+96     	; 0x3698 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3638:	8f 81       	ldd	r24, Y+7	; 0x07
    363a:	98 85       	ldd	r25, Y+8	; 0x08
    363c:	2b 85       	ldd	r18, Y+11	; 0x0b
    363e:	3c 85       	ldd	r19, Y+12	; 0x0c
    3640:	4d 85       	ldd	r20, Y+13	; 0x0d
    3642:	5e 85       	ldd	r21, Y+14	; 0x0e
    3644:	eb 81       	ldd	r30, Y+3	; 0x03
    3646:	fc 81       	ldd	r31, Y+4	; 0x04
    3648:	a9 81       	ldd	r26, Y+1	; 0x01
    364a:	ba 81       	ldd	r27, Y+2	; 0x02
    364c:	b9 01       	movw	r22, r18
    364e:	9f 01       	movw	r18, r30
    3650:	8d 01       	movw	r16, r26
    3652:	0e 94 25 1c 	call	0x384a	; 0x384a <prvReadMessageFromBuffer>
    3656:	9e 83       	std	Y+6, r25	; 0x06
    3658:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    365a:	8d 81       	ldd	r24, Y+5	; 0x05
    365c:	9e 81       	ldd	r25, Y+6	; 0x06
    365e:	00 97       	sbiw	r24, 0x00	; 0
    3660:	d9 f0       	breq	.+54     	; 0x3698 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3662:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
    3666:	ef 81       	ldd	r30, Y+7	; 0x07
    3668:	f8 85       	ldd	r31, Y+8	; 0x08
    366a:	82 85       	ldd	r24, Z+10	; 0x0a
    366c:	93 85       	ldd	r25, Z+11	; 0x0b
    366e:	00 97       	sbiw	r24, 0x00	; 0
    3670:	89 f0       	breq	.+34     	; 0x3694 <xStreamBufferReceive+0x152>
    3672:	ef 81       	ldd	r30, Y+7	; 0x07
    3674:	f8 85       	ldd	r31, Y+8	; 0x08
    3676:	82 85       	ldd	r24, Z+10	; 0x0a
    3678:	93 85       	ldd	r25, Z+11	; 0x0b
    367a:	40 e0       	ldi	r20, 0x00	; 0
    367c:	50 e0       	ldi	r21, 0x00	; 0
    367e:	60 e0       	ldi	r22, 0x00	; 0
    3680:	70 e0       	ldi	r23, 0x00	; 0
    3682:	20 e0       	ldi	r18, 0x00	; 0
    3684:	00 e0       	ldi	r16, 0x00	; 0
    3686:	10 e0       	ldi	r17, 0x00	; 0
    3688:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <xTaskGenericNotify>
    368c:	ef 81       	ldd	r30, Y+7	; 0x07
    368e:	f8 85       	ldd	r31, Y+8	; 0x08
    3690:	13 86       	std	Z+11, r1	; 0x0b
    3692:	12 86       	std	Z+10, r1	; 0x0a
    3694:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    3698:	8d 81       	ldd	r24, Y+5	; 0x05
    369a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    369c:	60 96       	adiw	r28, 0x10	; 16
    369e:	0f b6       	in	r0, 0x3f	; 63
    36a0:	f8 94       	cli
    36a2:	de bf       	out	0x3e, r29	; 62
    36a4:	0f be       	out	0x3f, r0	; 63
    36a6:	cd bf       	out	0x3d, r28	; 61
    36a8:	cf 91       	pop	r28
    36aa:	df 91       	pop	r29
    36ac:	1f 91       	pop	r17
    36ae:	0f 91       	pop	r16
    36b0:	ff 90       	pop	r15
    36b2:	ef 90       	pop	r14
    36b4:	08 95       	ret

000036b6 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    36b6:	df 93       	push	r29
    36b8:	cf 93       	push	r28
    36ba:	cd b7       	in	r28, 0x3d	; 61
    36bc:	de b7       	in	r29, 0x3e	; 62
    36be:	2c 97       	sbiw	r28, 0x0c	; 12
    36c0:	0f b6       	in	r0, 0x3f	; 63
    36c2:	f8 94       	cli
    36c4:	de bf       	out	0x3e, r29	; 62
    36c6:	0f be       	out	0x3f, r0	; 63
    36c8:	cd bf       	out	0x3d, r28	; 61
    36ca:	9c 87       	std	Y+12, r25	; 0x0c
    36cc:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    36ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    36d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    36d2:	98 87       	std	Y+8, r25	; 0x08
    36d4:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    36d6:	ef 81       	ldd	r30, Y+7	; 0x07
    36d8:	f8 85       	ldd	r31, Y+8	; 0x08
    36da:	86 85       	ldd	r24, Z+14	; 0x0e
    36dc:	88 2f       	mov	r24, r24
    36de:	90 e0       	ldi	r25, 0x00	; 0
    36e0:	81 70       	andi	r24, 0x01	; 1
    36e2:	90 70       	andi	r25, 0x00	; 0
    36e4:	88 23       	and	r24, r24
    36e6:	61 f1       	breq	.+88     	; 0x3740 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    36e8:	8f 81       	ldd	r24, Y+7	; 0x07
    36ea:	98 85       	ldd	r25, Y+8	; 0x08
    36ec:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <prvBytesInBuffer>
    36f0:	9c 83       	std	Y+4, r25	; 0x04
    36f2:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    36f4:	8b 81       	ldd	r24, Y+3	; 0x03
    36f6:	9c 81       	ldd	r25, Y+4	; 0x04
    36f8:	83 30       	cpi	r24, 0x03	; 3
    36fa:	91 05       	cpc	r25, r1
    36fc:	f0 f0       	brcs	.+60     	; 0x373a <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    36fe:	ef 81       	ldd	r30, Y+7	; 0x07
    3700:	f8 85       	ldd	r31, Y+8	; 0x08
    3702:	80 81       	ld	r24, Z
    3704:	91 81       	ldd	r25, Z+1	; 0x01
    3706:	9a 83       	std	Y+2, r25	; 0x02
    3708:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    370a:	9e 01       	movw	r18, r28
    370c:	27 5f       	subi	r18, 0xF7	; 247
    370e:	3f 4f       	sbci	r19, 0xFF	; 255
    3710:	8f 81       	ldd	r24, Y+7	; 0x07
    3712:	98 85       	ldd	r25, Y+8	; 0x08
    3714:	eb 81       	ldd	r30, Y+3	; 0x03
    3716:	fc 81       	ldd	r31, Y+4	; 0x04
    3718:	b9 01       	movw	r22, r18
    371a:	42 e0       	ldi	r20, 0x02	; 2
    371c:	50 e0       	ldi	r21, 0x00	; 0
    371e:	9f 01       	movw	r18, r30
    3720:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    3724:	89 85       	ldd	r24, Y+9	; 0x09
    3726:	9a 85       	ldd	r25, Y+10	; 0x0a
    3728:	9e 83       	std	Y+6, r25	; 0x06
    372a:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    372c:	ef 81       	ldd	r30, Y+7	; 0x07
    372e:	f8 85       	ldd	r31, Y+8	; 0x08
    3730:	89 81       	ldd	r24, Y+1	; 0x01
    3732:	9a 81       	ldd	r25, Y+2	; 0x02
    3734:	91 83       	std	Z+1, r25	; 0x01
    3736:	80 83       	st	Z, r24
    3738:	05 c0       	rjmp	.+10     	; 0x3744 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    373a:	1e 82       	std	Y+6, r1	; 0x06
    373c:	1d 82       	std	Y+5, r1	; 0x05
    373e:	02 c0       	rjmp	.+4      	; 0x3744 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    3740:	1e 82       	std	Y+6, r1	; 0x06
    3742:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3744:	8d 81       	ldd	r24, Y+5	; 0x05
    3746:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3748:	2c 96       	adiw	r28, 0x0c	; 12
    374a:	0f b6       	in	r0, 0x3f	; 63
    374c:	f8 94       	cli
    374e:	de bf       	out	0x3e, r29	; 62
    3750:	0f be       	out	0x3f, r0	; 63
    3752:	cd bf       	out	0x3d, r28	; 61
    3754:	cf 91       	pop	r28
    3756:	df 91       	pop	r29
    3758:	08 95       	ret

0000375a <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    375a:	ef 92       	push	r14
    375c:	ff 92       	push	r15
    375e:	0f 93       	push	r16
    3760:	1f 93       	push	r17
    3762:	df 93       	push	r29
    3764:	cf 93       	push	r28
    3766:	cd b7       	in	r28, 0x3d	; 61
    3768:	de b7       	in	r29, 0x3e	; 62
    376a:	61 97       	sbiw	r28, 0x11	; 17
    376c:	0f b6       	in	r0, 0x3f	; 63
    376e:	f8 94       	cli
    3770:	de bf       	out	0x3e, r29	; 62
    3772:	0f be       	out	0x3f, r0	; 63
    3774:	cd bf       	out	0x3d, r28	; 61
    3776:	9b 87       	std	Y+11, r25	; 0x0b
    3778:	8a 87       	std	Y+10, r24	; 0x0a
    377a:	7d 87       	std	Y+13, r23	; 0x0d
    377c:	6c 87       	std	Y+12, r22	; 0x0c
    377e:	5f 87       	std	Y+15, r21	; 0x0f
    3780:	4e 87       	std	Y+14, r20	; 0x0e
    3782:	39 8b       	std	Y+17, r19	; 0x11
    3784:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3786:	8a 85       	ldd	r24, Y+10	; 0x0a
    3788:	9b 85       	ldd	r25, Y+11	; 0x0b
    378a:	99 87       	std	Y+9, r25	; 0x09
    378c:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    378e:	1f 82       	std	Y+7, r1	; 0x07
    3790:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3792:	e8 85       	ldd	r30, Y+8	; 0x08
    3794:	f9 85       	ldd	r31, Y+9	; 0x09
    3796:	86 85       	ldd	r24, Z+14	; 0x0e
    3798:	88 2f       	mov	r24, r24
    379a:	90 e0       	ldi	r25, 0x00	; 0
    379c:	81 70       	andi	r24, 0x01	; 1
    379e:	90 70       	andi	r25, 0x00	; 0
    37a0:	88 23       	and	r24, r24
    37a2:	29 f0       	breq	.+10     	; 0x37ae <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    37a4:	82 e0       	ldi	r24, 0x02	; 2
    37a6:	90 e0       	ldi	r25, 0x00	; 0
    37a8:	9b 83       	std	Y+3, r25	; 0x03
    37aa:	8a 83       	std	Y+2, r24	; 0x02
    37ac:	02 c0       	rjmp	.+4      	; 0x37b2 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    37ae:	1b 82       	std	Y+3, r1	; 0x03
    37b0:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    37b2:	88 85       	ldd	r24, Y+8	; 0x08
    37b4:	99 85       	ldd	r25, Y+9	; 0x09
    37b6:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <prvBytesInBuffer>
    37ba:	9d 83       	std	Y+5, r25	; 0x05
    37bc:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    37be:	2c 81       	ldd	r18, Y+4	; 0x04
    37c0:	3d 81       	ldd	r19, Y+5	; 0x05
    37c2:	8a 81       	ldd	r24, Y+2	; 0x02
    37c4:	9b 81       	ldd	r25, Y+3	; 0x03
    37c6:	82 17       	cp	r24, r18
    37c8:	93 07       	cpc	r25, r19
    37ca:	80 f5       	brcc	.+96     	; 0x382c <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    37cc:	88 85       	ldd	r24, Y+8	; 0x08
    37ce:	99 85       	ldd	r25, Y+9	; 0x09
    37d0:	2c 85       	ldd	r18, Y+12	; 0x0c
    37d2:	3d 85       	ldd	r19, Y+13	; 0x0d
    37d4:	4e 85       	ldd	r20, Y+14	; 0x0e
    37d6:	5f 85       	ldd	r21, Y+15	; 0x0f
    37d8:	ec 81       	ldd	r30, Y+4	; 0x04
    37da:	fd 81       	ldd	r31, Y+5	; 0x05
    37dc:	aa 81       	ldd	r26, Y+2	; 0x02
    37de:	bb 81       	ldd	r27, Y+3	; 0x03
    37e0:	b9 01       	movw	r22, r18
    37e2:	9f 01       	movw	r18, r30
    37e4:	8d 01       	movw	r16, r26
    37e6:	0e 94 25 1c 	call	0x384a	; 0x384a <prvReadMessageFromBuffer>
    37ea:	9f 83       	std	Y+7, r25	; 0x07
    37ec:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    37ee:	8e 81       	ldd	r24, Y+6	; 0x06
    37f0:	9f 81       	ldd	r25, Y+7	; 0x07
    37f2:	00 97       	sbiw	r24, 0x00	; 0
    37f4:	d9 f0       	breq	.+54     	; 0x382c <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    37f6:	19 82       	std	Y+1, r1	; 0x01
    37f8:	e8 85       	ldd	r30, Y+8	; 0x08
    37fa:	f9 85       	ldd	r31, Y+9	; 0x09
    37fc:	82 85       	ldd	r24, Z+10	; 0x0a
    37fe:	93 85       	ldd	r25, Z+11	; 0x0b
    3800:	00 97       	sbiw	r24, 0x00	; 0
    3802:	a1 f0       	breq	.+40     	; 0x382c <xStreamBufferReceiveFromISR+0xd2>
    3804:	e8 85       	ldd	r30, Y+8	; 0x08
    3806:	f9 85       	ldd	r31, Y+9	; 0x09
    3808:	82 85       	ldd	r24, Z+10	; 0x0a
    380a:	93 85       	ldd	r25, Z+11	; 0x0b
    380c:	e8 89       	ldd	r30, Y+16	; 0x10
    380e:	f9 89       	ldd	r31, Y+17	; 0x11
    3810:	40 e0       	ldi	r20, 0x00	; 0
    3812:	50 e0       	ldi	r21, 0x00	; 0
    3814:	60 e0       	ldi	r22, 0x00	; 0
    3816:	70 e0       	ldi	r23, 0x00	; 0
    3818:	20 e0       	ldi	r18, 0x00	; 0
    381a:	00 e0       	ldi	r16, 0x00	; 0
    381c:	10 e0       	ldi	r17, 0x00	; 0
    381e:	7f 01       	movw	r14, r30
    3820:	0e 94 d5 2b 	call	0x57aa	; 0x57aa <xTaskGenericNotifyFromISR>
    3824:	e8 85       	ldd	r30, Y+8	; 0x08
    3826:	f9 85       	ldd	r31, Y+9	; 0x09
    3828:	13 86       	std	Z+11, r1	; 0x0b
    382a:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    382c:	8e 81       	ldd	r24, Y+6	; 0x06
    382e:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3830:	61 96       	adiw	r28, 0x11	; 17
    3832:	0f b6       	in	r0, 0x3f	; 63
    3834:	f8 94       	cli
    3836:	de bf       	out	0x3e, r29	; 62
    3838:	0f be       	out	0x3f, r0	; 63
    383a:	cd bf       	out	0x3d, r28	; 61
    383c:	cf 91       	pop	r28
    383e:	df 91       	pop	r29
    3840:	1f 91       	pop	r17
    3842:	0f 91       	pop	r16
    3844:	ff 90       	pop	r15
    3846:	ef 90       	pop	r14
    3848:	08 95       	ret

0000384a <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    384a:	0f 93       	push	r16
    384c:	1f 93       	push	r17
    384e:	df 93       	push	r29
    3850:	cf 93       	push	r28
    3852:	cd b7       	in	r28, 0x3d	; 61
    3854:	de b7       	in	r29, 0x3e	; 62
    3856:	62 97       	sbiw	r28, 0x12	; 18
    3858:	0f b6       	in	r0, 0x3f	; 63
    385a:	f8 94       	cli
    385c:	de bf       	out	0x3e, r29	; 62
    385e:	0f be       	out	0x3f, r0	; 63
    3860:	cd bf       	out	0x3d, r28	; 61
    3862:	9a 87       	std	Y+10, r25	; 0x0a
    3864:	89 87       	std	Y+9, r24	; 0x09
    3866:	7c 87       	std	Y+12, r23	; 0x0c
    3868:	6b 87       	std	Y+11, r22	; 0x0b
    386a:	5e 87       	std	Y+14, r21	; 0x0e
    386c:	4d 87       	std	Y+13, r20	; 0x0d
    386e:	38 8b       	std	Y+16, r19	; 0x10
    3870:	2f 87       	std	Y+15, r18	; 0x0f
    3872:	1a 8b       	std	Y+18, r17	; 0x12
    3874:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    3876:	89 89       	ldd	r24, Y+17	; 0x11
    3878:	9a 89       	ldd	r25, Y+18	; 0x12
    387a:	00 97       	sbiw	r24, 0x00	; 0
    387c:	91 f1       	breq	.+100    	; 0x38e2 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    387e:	e9 85       	ldd	r30, Y+9	; 0x09
    3880:	fa 85       	ldd	r31, Y+10	; 0x0a
    3882:	80 81       	ld	r24, Z
    3884:	91 81       	ldd	r25, Z+1	; 0x01
    3886:	9e 83       	std	Y+6, r25	; 0x06
    3888:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    388a:	ae 01       	movw	r20, r28
    388c:	49 5f       	subi	r20, 0xF9	; 249
    388e:	5f 4f       	sbci	r21, 0xFF	; 255
    3890:	89 85       	ldd	r24, Y+9	; 0x09
    3892:	9a 85       	ldd	r25, Y+10	; 0x0a
    3894:	29 89       	ldd	r18, Y+17	; 0x11
    3896:	3a 89       	ldd	r19, Y+18	; 0x12
    3898:	ef 85       	ldd	r30, Y+15	; 0x0f
    389a:	f8 89       	ldd	r31, Y+16	; 0x10
    389c:	ba 01       	movw	r22, r20
    389e:	a9 01       	movw	r20, r18
    38a0:	9f 01       	movw	r18, r30
    38a2:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    38a6:	8f 81       	ldd	r24, Y+7	; 0x07
    38a8:	98 85       	ldd	r25, Y+8	; 0x08
    38aa:	9a 83       	std	Y+2, r25	; 0x02
    38ac:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    38ae:	2f 85       	ldd	r18, Y+15	; 0x0f
    38b0:	38 89       	ldd	r19, Y+16	; 0x10
    38b2:	89 89       	ldd	r24, Y+17	; 0x11
    38b4:	9a 89       	ldd	r25, Y+18	; 0x12
    38b6:	a9 01       	movw	r20, r18
    38b8:	48 1b       	sub	r20, r24
    38ba:	59 0b       	sbc	r21, r25
    38bc:	ca 01       	movw	r24, r20
    38be:	98 8b       	std	Y+16, r25	; 0x10
    38c0:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    38c2:	29 81       	ldd	r18, Y+1	; 0x01
    38c4:	3a 81       	ldd	r19, Y+2	; 0x02
    38c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    38c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    38ca:	82 17       	cp	r24, r18
    38cc:	93 07       	cpc	r25, r19
    38ce:	68 f4       	brcc	.+26     	; 0x38ea <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    38d0:	e9 85       	ldd	r30, Y+9	; 0x09
    38d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    38d4:	8d 81       	ldd	r24, Y+5	; 0x05
    38d6:	9e 81       	ldd	r25, Y+6	; 0x06
    38d8:	91 83       	std	Z+1, r25	; 0x01
    38da:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    38dc:	1a 82       	std	Y+2, r1	; 0x02
    38de:	19 82       	std	Y+1, r1	; 0x01
    38e0:	04 c0       	rjmp	.+8      	; 0x38ea <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    38e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    38e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    38e6:	9a 83       	std	Y+2, r25	; 0x02
    38e8:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    38ea:	4b 85       	ldd	r20, Y+11	; 0x0b
    38ec:	5c 85       	ldd	r21, Y+12	; 0x0c
    38ee:	89 85       	ldd	r24, Y+9	; 0x09
    38f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    38f2:	29 81       	ldd	r18, Y+1	; 0x01
    38f4:	3a 81       	ldd	r19, Y+2	; 0x02
    38f6:	ef 85       	ldd	r30, Y+15	; 0x0f
    38f8:	f8 89       	ldd	r31, Y+16	; 0x10
    38fa:	ba 01       	movw	r22, r20
    38fc:	a9 01       	movw	r20, r18
    38fe:	9f 01       	movw	r18, r30
    3900:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <prvReadBytesFromBuffer>
    3904:	9c 83       	std	Y+4, r25	; 0x04
    3906:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    3908:	8b 81       	ldd	r24, Y+3	; 0x03
    390a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    390c:	62 96       	adiw	r28, 0x12	; 18
    390e:	0f b6       	in	r0, 0x3f	; 63
    3910:	f8 94       	cli
    3912:	de bf       	out	0x3e, r29	; 62
    3914:	0f be       	out	0x3f, r0	; 63
    3916:	cd bf       	out	0x3d, r28	; 61
    3918:	cf 91       	pop	r28
    391a:	df 91       	pop	r29
    391c:	1f 91       	pop	r17
    391e:	0f 91       	pop	r16
    3920:	08 95       	ret

00003922 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    3922:	df 93       	push	r29
    3924:	cf 93       	push	r28
    3926:	cd b7       	in	r28, 0x3d	; 61
    3928:	de b7       	in	r29, 0x3e	; 62
    392a:	27 97       	sbiw	r28, 0x07	; 7
    392c:	0f b6       	in	r0, 0x3f	; 63
    392e:	f8 94       	cli
    3930:	de bf       	out	0x3e, r29	; 62
    3932:	0f be       	out	0x3f, r0	; 63
    3934:	cd bf       	out	0x3d, r28	; 61
    3936:	9f 83       	std	Y+7, r25	; 0x07
    3938:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    393a:	8e 81       	ldd	r24, Y+6	; 0x06
    393c:	9f 81       	ldd	r25, Y+7	; 0x07
    393e:	9d 83       	std	Y+5, r25	; 0x05
    3940:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    3942:	ec 81       	ldd	r30, Y+4	; 0x04
    3944:	fd 81       	ldd	r31, Y+5	; 0x05
    3946:	80 81       	ld	r24, Z
    3948:	91 81       	ldd	r25, Z+1	; 0x01
    394a:	9a 83       	std	Y+2, r25	; 0x02
    394c:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    394e:	ec 81       	ldd	r30, Y+4	; 0x04
    3950:	fd 81       	ldd	r31, Y+5	; 0x05
    3952:	22 81       	ldd	r18, Z+2	; 0x02
    3954:	33 81       	ldd	r19, Z+3	; 0x03
    3956:	89 81       	ldd	r24, Y+1	; 0x01
    3958:	9a 81       	ldd	r25, Y+2	; 0x02
    395a:	28 17       	cp	r18, r24
    395c:	39 07       	cpc	r19, r25
    395e:	19 f4       	brne	.+6      	; 0x3966 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    3960:	81 e0       	ldi	r24, 0x01	; 1
    3962:	8b 83       	std	Y+3, r24	; 0x03
    3964:	01 c0       	rjmp	.+2      	; 0x3968 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    3966:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    3968:	8b 81       	ldd	r24, Y+3	; 0x03
}
    396a:	27 96       	adiw	r28, 0x07	; 7
    396c:	0f b6       	in	r0, 0x3f	; 63
    396e:	f8 94       	cli
    3970:	de bf       	out	0x3e, r29	; 62
    3972:	0f be       	out	0x3f, r0	; 63
    3974:	cd bf       	out	0x3d, r28	; 61
    3976:	cf 91       	pop	r28
    3978:	df 91       	pop	r29
    397a:	08 95       	ret

0000397c <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    397c:	df 93       	push	r29
    397e:	cf 93       	push	r28
    3980:	cd b7       	in	r28, 0x3d	; 61
    3982:	de b7       	in	r29, 0x3e	; 62
    3984:	27 97       	sbiw	r28, 0x07	; 7
    3986:	0f b6       	in	r0, 0x3f	; 63
    3988:	f8 94       	cli
    398a:	de bf       	out	0x3e, r29	; 62
    398c:	0f be       	out	0x3f, r0	; 63
    398e:	cd bf       	out	0x3d, r28	; 61
    3990:	9f 83       	std	Y+7, r25	; 0x07
    3992:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3994:	8e 81       	ldd	r24, Y+6	; 0x06
    3996:	9f 81       	ldd	r25, Y+7	; 0x07
    3998:	9a 83       	std	Y+2, r25	; 0x02
    399a:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    399c:	e9 81       	ldd	r30, Y+1	; 0x01
    399e:	fa 81       	ldd	r31, Y+2	; 0x02
    39a0:	86 85       	ldd	r24, Z+14	; 0x0e
    39a2:	88 2f       	mov	r24, r24
    39a4:	90 e0       	ldi	r25, 0x00	; 0
    39a6:	81 70       	andi	r24, 0x01	; 1
    39a8:	90 70       	andi	r25, 0x00	; 0
    39aa:	88 23       	and	r24, r24
    39ac:	29 f0       	breq	.+10     	; 0x39b8 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    39ae:	82 e0       	ldi	r24, 0x02	; 2
    39b0:	90 e0       	ldi	r25, 0x00	; 0
    39b2:	9c 83       	std	Y+4, r25	; 0x04
    39b4:	8b 83       	std	Y+3, r24	; 0x03
    39b6:	02 c0       	rjmp	.+4      	; 0x39bc <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    39b8:	1c 82       	std	Y+4, r1	; 0x04
    39ba:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    39bc:	8e 81       	ldd	r24, Y+6	; 0x06
    39be:	9f 81       	ldd	r25, Y+7	; 0x07
    39c0:	0e 94 86 18 	call	0x310c	; 0x310c <xStreamBufferSpacesAvailable>
    39c4:	9c 01       	movw	r18, r24
    39c6:	8b 81       	ldd	r24, Y+3	; 0x03
    39c8:	9c 81       	ldd	r25, Y+4	; 0x04
    39ca:	82 17       	cp	r24, r18
    39cc:	93 07       	cpc	r25, r19
    39ce:	18 f0       	brcs	.+6      	; 0x39d6 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    39d0:	81 e0       	ldi	r24, 0x01	; 1
    39d2:	8d 83       	std	Y+5, r24	; 0x05
    39d4:	01 c0       	rjmp	.+2      	; 0x39d8 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    39d6:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    39d8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    39da:	27 96       	adiw	r28, 0x07	; 7
    39dc:	0f b6       	in	r0, 0x3f	; 63
    39de:	f8 94       	cli
    39e0:	de bf       	out	0x3e, r29	; 62
    39e2:	0f be       	out	0x3f, r0	; 63
    39e4:	cd bf       	out	0x3d, r28	; 61
    39e6:	cf 91       	pop	r28
    39e8:	df 91       	pop	r29
    39ea:	08 95       	ret

000039ec <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    39ec:	ef 92       	push	r14
    39ee:	ff 92       	push	r15
    39f0:	0f 93       	push	r16
    39f2:	1f 93       	push	r17
    39f4:	df 93       	push	r29
    39f6:	cf 93       	push	r28
    39f8:	cd b7       	in	r28, 0x3d	; 61
    39fa:	de b7       	in	r29, 0x3e	; 62
    39fc:	28 97       	sbiw	r28, 0x08	; 8
    39fe:	0f b6       	in	r0, 0x3f	; 63
    3a00:	f8 94       	cli
    3a02:	de bf       	out	0x3e, r29	; 62
    3a04:	0f be       	out	0x3f, r0	; 63
    3a06:	cd bf       	out	0x3d, r28	; 61
    3a08:	9e 83       	std	Y+6, r25	; 0x06
    3a0a:	8d 83       	std	Y+5, r24	; 0x05
    3a0c:	78 87       	std	Y+8, r23	; 0x08
    3a0e:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3a10:	8d 81       	ldd	r24, Y+5	; 0x05
    3a12:	9e 81       	ldd	r25, Y+6	; 0x06
    3a14:	9c 83       	std	Y+4, r25	; 0x04
    3a16:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3a18:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    3a1a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a1c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a1e:	80 85       	ldd	r24, Z+8	; 0x08
    3a20:	91 85       	ldd	r25, Z+9	; 0x09
    3a22:	00 97       	sbiw	r24, 0x00	; 0
    3a24:	b9 f0       	breq	.+46     	; 0x3a54 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    3a26:	eb 81       	ldd	r30, Y+3	; 0x03
    3a28:	fc 81       	ldd	r31, Y+4	; 0x04
    3a2a:	80 85       	ldd	r24, Z+8	; 0x08
    3a2c:	91 85       	ldd	r25, Z+9	; 0x09
    3a2e:	ef 81       	ldd	r30, Y+7	; 0x07
    3a30:	f8 85       	ldd	r31, Y+8	; 0x08
    3a32:	40 e0       	ldi	r20, 0x00	; 0
    3a34:	50 e0       	ldi	r21, 0x00	; 0
    3a36:	60 e0       	ldi	r22, 0x00	; 0
    3a38:	70 e0       	ldi	r23, 0x00	; 0
    3a3a:	20 e0       	ldi	r18, 0x00	; 0
    3a3c:	00 e0       	ldi	r16, 0x00	; 0
    3a3e:	10 e0       	ldi	r17, 0x00	; 0
    3a40:	7f 01       	movw	r14, r30
    3a42:	0e 94 d5 2b 	call	0x57aa	; 0x57aa <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    3a46:	eb 81       	ldd	r30, Y+3	; 0x03
    3a48:	fc 81       	ldd	r31, Y+4	; 0x04
    3a4a:	11 86       	std	Z+9, r1	; 0x09
    3a4c:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    3a4e:	81 e0       	ldi	r24, 0x01	; 1
    3a50:	8a 83       	std	Y+2, r24	; 0x02
    3a52:	01 c0       	rjmp	.+2      	; 0x3a56 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3a54:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3a56:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3a58:	28 96       	adiw	r28, 0x08	; 8
    3a5a:	0f b6       	in	r0, 0x3f	; 63
    3a5c:	f8 94       	cli
    3a5e:	de bf       	out	0x3e, r29	; 62
    3a60:	0f be       	out	0x3f, r0	; 63
    3a62:	cd bf       	out	0x3d, r28	; 61
    3a64:	cf 91       	pop	r28
    3a66:	df 91       	pop	r29
    3a68:	1f 91       	pop	r17
    3a6a:	0f 91       	pop	r16
    3a6c:	ff 90       	pop	r15
    3a6e:	ef 90       	pop	r14
    3a70:	08 95       	ret

00003a72 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3a72:	ef 92       	push	r14
    3a74:	ff 92       	push	r15
    3a76:	0f 93       	push	r16
    3a78:	1f 93       	push	r17
    3a7a:	df 93       	push	r29
    3a7c:	cf 93       	push	r28
    3a7e:	cd b7       	in	r28, 0x3d	; 61
    3a80:	de b7       	in	r29, 0x3e	; 62
    3a82:	28 97       	sbiw	r28, 0x08	; 8
    3a84:	0f b6       	in	r0, 0x3f	; 63
    3a86:	f8 94       	cli
    3a88:	de bf       	out	0x3e, r29	; 62
    3a8a:	0f be       	out	0x3f, r0	; 63
    3a8c:	cd bf       	out	0x3d, r28	; 61
    3a8e:	9e 83       	std	Y+6, r25	; 0x06
    3a90:	8d 83       	std	Y+5, r24	; 0x05
    3a92:	78 87       	std	Y+8, r23	; 0x08
    3a94:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3a96:	8d 81       	ldd	r24, Y+5	; 0x05
    3a98:	9e 81       	ldd	r25, Y+6	; 0x06
    3a9a:	9c 83       	std	Y+4, r25	; 0x04
    3a9c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3a9e:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    3aa0:	eb 81       	ldd	r30, Y+3	; 0x03
    3aa2:	fc 81       	ldd	r31, Y+4	; 0x04
    3aa4:	82 85       	ldd	r24, Z+10	; 0x0a
    3aa6:	93 85       	ldd	r25, Z+11	; 0x0b
    3aa8:	00 97       	sbiw	r24, 0x00	; 0
    3aaa:	b9 f0       	breq	.+46     	; 0x3ada <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    3aac:	eb 81       	ldd	r30, Y+3	; 0x03
    3aae:	fc 81       	ldd	r31, Y+4	; 0x04
    3ab0:	82 85       	ldd	r24, Z+10	; 0x0a
    3ab2:	93 85       	ldd	r25, Z+11	; 0x0b
    3ab4:	ef 81       	ldd	r30, Y+7	; 0x07
    3ab6:	f8 85       	ldd	r31, Y+8	; 0x08
    3ab8:	40 e0       	ldi	r20, 0x00	; 0
    3aba:	50 e0       	ldi	r21, 0x00	; 0
    3abc:	60 e0       	ldi	r22, 0x00	; 0
    3abe:	70 e0       	ldi	r23, 0x00	; 0
    3ac0:	20 e0       	ldi	r18, 0x00	; 0
    3ac2:	00 e0       	ldi	r16, 0x00	; 0
    3ac4:	10 e0       	ldi	r17, 0x00	; 0
    3ac6:	7f 01       	movw	r14, r30
    3ac8:	0e 94 d5 2b 	call	0x57aa	; 0x57aa <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    3acc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ace:	fc 81       	ldd	r31, Y+4	; 0x04
    3ad0:	13 86       	std	Z+11, r1	; 0x0b
    3ad2:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    3ad4:	81 e0       	ldi	r24, 0x01	; 1
    3ad6:	8a 83       	std	Y+2, r24	; 0x02
    3ad8:	01 c0       	rjmp	.+2      	; 0x3adc <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3ada:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3adc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3ade:	28 96       	adiw	r28, 0x08	; 8
    3ae0:	0f b6       	in	r0, 0x3f	; 63
    3ae2:	f8 94       	cli
    3ae4:	de bf       	out	0x3e, r29	; 62
    3ae6:	0f be       	out	0x3f, r0	; 63
    3ae8:	cd bf       	out	0x3d, r28	; 61
    3aea:	cf 91       	pop	r28
    3aec:	df 91       	pop	r29
    3aee:	1f 91       	pop	r17
    3af0:	0f 91       	pop	r16
    3af2:	ff 90       	pop	r15
    3af4:	ef 90       	pop	r14
    3af6:	08 95       	ret

00003af8 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    3af8:	df 93       	push	r29
    3afa:	cf 93       	push	r28
    3afc:	cd b7       	in	r28, 0x3d	; 61
    3afe:	de b7       	in	r29, 0x3e	; 62
    3b00:	2e 97       	sbiw	r28, 0x0e	; 14
    3b02:	0f b6       	in	r0, 0x3f	; 63
    3b04:	f8 94       	cli
    3b06:	de bf       	out	0x3e, r29	; 62
    3b08:	0f be       	out	0x3f, r0	; 63
    3b0a:	cd bf       	out	0x3d, r28	; 61
    3b0c:	9e 83       	std	Y+6, r25	; 0x06
    3b0e:	8d 83       	std	Y+5, r24	; 0x05
    3b10:	78 87       	std	Y+8, r23	; 0x08
    3b12:	6f 83       	std	Y+7, r22	; 0x07
    3b14:	5a 87       	std	Y+10, r21	; 0x0a
    3b16:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    3b18:	ed 81       	ldd	r30, Y+5	; 0x05
    3b1a:	fe 81       	ldd	r31, Y+6	; 0x06
    3b1c:	82 81       	ldd	r24, Z+2	; 0x02
    3b1e:	93 81       	ldd	r25, Z+3	; 0x03
    3b20:	9c 83       	std	Y+4, r25	; 0x04
    3b22:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    3b24:	ed 81       	ldd	r30, Y+5	; 0x05
    3b26:	fe 81       	ldd	r31, Y+6	; 0x06
    3b28:	24 81       	ldd	r18, Z+4	; 0x04
    3b2a:	35 81       	ldd	r19, Z+5	; 0x05
    3b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3b30:	a9 01       	movw	r20, r18
    3b32:	48 1b       	sub	r20, r24
    3b34:	59 0b       	sbc	r21, r25
    3b36:	ca 01       	movw	r24, r20
    3b38:	29 85       	ldd	r18, Y+9	; 0x09
    3b3a:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b3c:	3e 87       	std	Y+14, r19	; 0x0e
    3b3e:	2d 87       	std	Y+13, r18	; 0x0d
    3b40:	9c 87       	std	Y+12, r25	; 0x0c
    3b42:	8b 87       	std	Y+11, r24	; 0x0b
    3b44:	4b 85       	ldd	r20, Y+11	; 0x0b
    3b46:	5c 85       	ldd	r21, Y+12	; 0x0c
    3b48:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b4a:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b4c:	84 17       	cp	r24, r20
    3b4e:	95 07       	cpc	r25, r21
    3b50:	20 f4       	brcc	.+8      	; 0x3b5a <prvWriteBytesToBuffer+0x62>
    3b52:	2d 85       	ldd	r18, Y+13	; 0x0d
    3b54:	3e 85       	ldd	r19, Y+14	; 0x0e
    3b56:	3c 87       	std	Y+12, r19	; 0x0c
    3b58:	2b 87       	std	Y+11, r18	; 0x0b
    3b5a:	4b 85       	ldd	r20, Y+11	; 0x0b
    3b5c:	5c 85       	ldd	r21, Y+12	; 0x0c
    3b5e:	5a 83       	std	Y+2, r21	; 0x02
    3b60:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3b62:	ed 81       	ldd	r30, Y+5	; 0x05
    3b64:	fe 81       	ldd	r31, Y+6	; 0x06
    3b66:	24 85       	ldd	r18, Z+12	; 0x0c
    3b68:	35 85       	ldd	r19, Z+13	; 0x0d
    3b6a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b6c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b6e:	82 0f       	add	r24, r18
    3b70:	93 1f       	adc	r25, r19
    3b72:	2f 81       	ldd	r18, Y+7	; 0x07
    3b74:	38 85       	ldd	r19, Y+8	; 0x08
    3b76:	49 81       	ldd	r20, Y+1	; 0x01
    3b78:	5a 81       	ldd	r21, Y+2	; 0x02
    3b7a:	b9 01       	movw	r22, r18
    3b7c:	0e 94 15 2e 	call	0x5c2a	; 0x5c2a <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    3b80:	29 85       	ldd	r18, Y+9	; 0x09
    3b82:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b84:	89 81       	ldd	r24, Y+1	; 0x01
    3b86:	9a 81       	ldd	r25, Y+2	; 0x02
    3b88:	82 17       	cp	r24, r18
    3b8a:	93 07       	cpc	r25, r19
    3b8c:	b0 f4       	brcc	.+44     	; 0x3bba <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3b8e:	ed 81       	ldd	r30, Y+5	; 0x05
    3b90:	fe 81       	ldd	r31, Y+6	; 0x06
    3b92:	64 85       	ldd	r22, Z+12	; 0x0c
    3b94:	75 85       	ldd	r23, Z+13	; 0x0d
    3b96:	2f 81       	ldd	r18, Y+7	; 0x07
    3b98:	38 85       	ldd	r19, Y+8	; 0x08
    3b9a:	89 81       	ldd	r24, Y+1	; 0x01
    3b9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b9e:	a9 01       	movw	r20, r18
    3ba0:	48 0f       	add	r20, r24
    3ba2:	59 1f       	adc	r21, r25
    3ba4:	29 85       	ldd	r18, Y+9	; 0x09
    3ba6:	3a 85       	ldd	r19, Y+10	; 0x0a
    3ba8:	89 81       	ldd	r24, Y+1	; 0x01
    3baa:	9a 81       	ldd	r25, Y+2	; 0x02
    3bac:	28 1b       	sub	r18, r24
    3bae:	39 0b       	sbc	r19, r25
    3bb0:	cb 01       	movw	r24, r22
    3bb2:	ba 01       	movw	r22, r20
    3bb4:	a9 01       	movw	r20, r18
    3bb6:	0e 94 15 2e 	call	0x5c2a	; 0x5c2a <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    3bba:	2b 81       	ldd	r18, Y+3	; 0x03
    3bbc:	3c 81       	ldd	r19, Y+4	; 0x04
    3bbe:	89 85       	ldd	r24, Y+9	; 0x09
    3bc0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3bc2:	82 0f       	add	r24, r18
    3bc4:	93 1f       	adc	r25, r19
    3bc6:	9c 83       	std	Y+4, r25	; 0x04
    3bc8:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    3bca:	ed 81       	ldd	r30, Y+5	; 0x05
    3bcc:	fe 81       	ldd	r31, Y+6	; 0x06
    3bce:	24 81       	ldd	r18, Z+4	; 0x04
    3bd0:	35 81       	ldd	r19, Z+5	; 0x05
    3bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd4:	9c 81       	ldd	r25, Y+4	; 0x04
    3bd6:	82 17       	cp	r24, r18
    3bd8:	93 07       	cpc	r25, r19
    3bda:	50 f0       	brcs	.+20     	; 0x3bf0 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    3bdc:	ed 81       	ldd	r30, Y+5	; 0x05
    3bde:	fe 81       	ldd	r31, Y+6	; 0x06
    3be0:	24 81       	ldd	r18, Z+4	; 0x04
    3be2:	35 81       	ldd	r19, Z+5	; 0x05
    3be4:	8b 81       	ldd	r24, Y+3	; 0x03
    3be6:	9c 81       	ldd	r25, Y+4	; 0x04
    3be8:	82 1b       	sub	r24, r18
    3bea:	93 0b       	sbc	r25, r19
    3bec:	9c 83       	std	Y+4, r25	; 0x04
    3bee:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    3bf0:	ed 81       	ldd	r30, Y+5	; 0x05
    3bf2:	fe 81       	ldd	r31, Y+6	; 0x06
    3bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    3bf8:	93 83       	std	Z+3, r25	; 0x03
    3bfa:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    3bfc:	89 85       	ldd	r24, Y+9	; 0x09
    3bfe:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    3c00:	2e 96       	adiw	r28, 0x0e	; 14
    3c02:	0f b6       	in	r0, 0x3f	; 63
    3c04:	f8 94       	cli
    3c06:	de bf       	out	0x3e, r29	; 62
    3c08:	0f be       	out	0x3f, r0	; 63
    3c0a:	cd bf       	out	0x3d, r28	; 61
    3c0c:	cf 91       	pop	r28
    3c0e:	df 91       	pop	r29
    3c10:	08 95       	ret

00003c12 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    3c12:	df 93       	push	r29
    3c14:	cf 93       	push	r28
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
    3c1a:	66 97       	sbiw	r28, 0x16	; 22
    3c1c:	0f b6       	in	r0, 0x3f	; 63
    3c1e:	f8 94       	cli
    3c20:	de bf       	out	0x3e, r29	; 62
    3c22:	0f be       	out	0x3f, r0	; 63
    3c24:	cd bf       	out	0x3d, r28	; 61
    3c26:	98 87       	std	Y+8, r25	; 0x08
    3c28:	8f 83       	std	Y+7, r24	; 0x07
    3c2a:	7a 87       	std	Y+10, r23	; 0x0a
    3c2c:	69 87       	std	Y+9, r22	; 0x09
    3c2e:	5c 87       	std	Y+12, r21	; 0x0c
    3c30:	4b 87       	std	Y+11, r20	; 0x0b
    3c32:	3e 87       	std	Y+14, r19	; 0x0e
    3c34:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    3c36:	2d 85       	ldd	r18, Y+13	; 0x0d
    3c38:	3e 85       	ldd	r19, Y+14	; 0x0e
    3c3a:	3a 8b       	std	Y+18, r19	; 0x12
    3c3c:	29 8b       	std	Y+17, r18	; 0x11
    3c3e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3c40:	5c 85       	ldd	r21, Y+12	; 0x0c
    3c42:	58 8b       	std	Y+16, r21	; 0x10
    3c44:	4f 87       	std	Y+15, r20	; 0x0f
    3c46:	8f 85       	ldd	r24, Y+15	; 0x0f
    3c48:	98 89       	ldd	r25, Y+16	; 0x10
    3c4a:	29 89       	ldd	r18, Y+17	; 0x11
    3c4c:	3a 89       	ldd	r19, Y+18	; 0x12
    3c4e:	28 17       	cp	r18, r24
    3c50:	39 07       	cpc	r19, r25
    3c52:	20 f4       	brcc	.+8      	; 0x3c5c <prvReadBytesFromBuffer+0x4a>
    3c54:	49 89       	ldd	r20, Y+17	; 0x11
    3c56:	5a 89       	ldd	r21, Y+18	; 0x12
    3c58:	58 8b       	std	Y+16, r21	; 0x10
    3c5a:	4f 87       	std	Y+15, r20	; 0x0f
    3c5c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3c5e:	98 89       	ldd	r25, Y+16	; 0x10
    3c60:	9e 83       	std	Y+6, r25	; 0x06
    3c62:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    3c64:	8d 81       	ldd	r24, Y+5	; 0x05
    3c66:	9e 81       	ldd	r25, Y+6	; 0x06
    3c68:	00 97       	sbiw	r24, 0x00	; 0
    3c6a:	09 f4       	brne	.+2      	; 0x3c6e <prvReadBytesFromBuffer+0x5c>
    3c6c:	74 c0       	rjmp	.+232    	; 0x3d56 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    3c6e:	ef 81       	ldd	r30, Y+7	; 0x07
    3c70:	f8 85       	ldd	r31, Y+8	; 0x08
    3c72:	80 81       	ld	r24, Z
    3c74:	91 81       	ldd	r25, Z+1	; 0x01
    3c76:	9a 83       	std	Y+2, r25	; 0x02
    3c78:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    3c7a:	ef 81       	ldd	r30, Y+7	; 0x07
    3c7c:	f8 85       	ldd	r31, Y+8	; 0x08
    3c7e:	24 81       	ldd	r18, Z+4	; 0x04
    3c80:	35 81       	ldd	r19, Z+5	; 0x05
    3c82:	89 81       	ldd	r24, Y+1	; 0x01
    3c84:	9a 81       	ldd	r25, Y+2	; 0x02
    3c86:	a9 01       	movw	r20, r18
    3c88:	48 1b       	sub	r20, r24
    3c8a:	59 0b       	sbc	r21, r25
    3c8c:	ca 01       	movw	r24, r20
    3c8e:	2d 81       	ldd	r18, Y+5	; 0x05
    3c90:	3e 81       	ldd	r19, Y+6	; 0x06
    3c92:	3e 8b       	std	Y+22, r19	; 0x16
    3c94:	2d 8b       	std	Y+21, r18	; 0x15
    3c96:	9c 8b       	std	Y+20, r25	; 0x14
    3c98:	8b 8b       	std	Y+19, r24	; 0x13
    3c9a:	4b 89       	ldd	r20, Y+19	; 0x13
    3c9c:	5c 89       	ldd	r21, Y+20	; 0x14
    3c9e:	8d 89       	ldd	r24, Y+21	; 0x15
    3ca0:	9e 89       	ldd	r25, Y+22	; 0x16
    3ca2:	84 17       	cp	r24, r20
    3ca4:	95 07       	cpc	r25, r21
    3ca6:	20 f4       	brcc	.+8      	; 0x3cb0 <prvReadBytesFromBuffer+0x9e>
    3ca8:	2d 89       	ldd	r18, Y+21	; 0x15
    3caa:	3e 89       	ldd	r19, Y+22	; 0x16
    3cac:	3c 8b       	std	Y+20, r19	; 0x14
    3cae:	2b 8b       	std	Y+19, r18	; 0x13
    3cb0:	4b 89       	ldd	r20, Y+19	; 0x13
    3cb2:	5c 89       	ldd	r21, Y+20	; 0x14
    3cb4:	5c 83       	std	Y+4, r21	; 0x04
    3cb6:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3cb8:	ef 81       	ldd	r30, Y+7	; 0x07
    3cba:	f8 85       	ldd	r31, Y+8	; 0x08
    3cbc:	24 85       	ldd	r18, Z+12	; 0x0c
    3cbe:	35 85       	ldd	r19, Z+13	; 0x0d
    3cc0:	89 81       	ldd	r24, Y+1	; 0x01
    3cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    3cc4:	a9 01       	movw	r20, r18
    3cc6:	48 0f       	add	r20, r24
    3cc8:	59 1f       	adc	r21, r25
    3cca:	89 85       	ldd	r24, Y+9	; 0x09
    3ccc:	9a 85       	ldd	r25, Y+10	; 0x0a
    3cce:	2b 81       	ldd	r18, Y+3	; 0x03
    3cd0:	3c 81       	ldd	r19, Y+4	; 0x04
    3cd2:	ba 01       	movw	r22, r20
    3cd4:	a9 01       	movw	r20, r18
    3cd6:	0e 94 15 2e 	call	0x5c2a	; 0x5c2a <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    3cda:	2d 81       	ldd	r18, Y+5	; 0x05
    3cdc:	3e 81       	ldd	r19, Y+6	; 0x06
    3cde:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce2:	82 17       	cp	r24, r18
    3ce4:	93 07       	cpc	r25, r19
    3ce6:	b0 f4       	brcc	.+44     	; 0x3d14 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3ce8:	29 85       	ldd	r18, Y+9	; 0x09
    3cea:	3a 85       	ldd	r19, Y+10	; 0x0a
    3cec:	8b 81       	ldd	r24, Y+3	; 0x03
    3cee:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf0:	b9 01       	movw	r22, r18
    3cf2:	68 0f       	add	r22, r24
    3cf4:	79 1f       	adc	r23, r25
    3cf6:	ef 81       	ldd	r30, Y+7	; 0x07
    3cf8:	f8 85       	ldd	r31, Y+8	; 0x08
    3cfa:	44 85       	ldd	r20, Z+12	; 0x0c
    3cfc:	55 85       	ldd	r21, Z+13	; 0x0d
    3cfe:	2d 81       	ldd	r18, Y+5	; 0x05
    3d00:	3e 81       	ldd	r19, Y+6	; 0x06
    3d02:	8b 81       	ldd	r24, Y+3	; 0x03
    3d04:	9c 81       	ldd	r25, Y+4	; 0x04
    3d06:	28 1b       	sub	r18, r24
    3d08:	39 0b       	sbc	r19, r25
    3d0a:	cb 01       	movw	r24, r22
    3d0c:	ba 01       	movw	r22, r20
    3d0e:	a9 01       	movw	r20, r18
    3d10:	0e 94 15 2e 	call	0x5c2a	; 0x5c2a <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    3d14:	29 81       	ldd	r18, Y+1	; 0x01
    3d16:	3a 81       	ldd	r19, Y+2	; 0x02
    3d18:	8d 81       	ldd	r24, Y+5	; 0x05
    3d1a:	9e 81       	ldd	r25, Y+6	; 0x06
    3d1c:	82 0f       	add	r24, r18
    3d1e:	93 1f       	adc	r25, r19
    3d20:	9a 83       	std	Y+2, r25	; 0x02
    3d22:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    3d24:	ef 81       	ldd	r30, Y+7	; 0x07
    3d26:	f8 85       	ldd	r31, Y+8	; 0x08
    3d28:	24 81       	ldd	r18, Z+4	; 0x04
    3d2a:	35 81       	ldd	r19, Z+5	; 0x05
    3d2c:	89 81       	ldd	r24, Y+1	; 0x01
    3d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d30:	82 17       	cp	r24, r18
    3d32:	93 07       	cpc	r25, r19
    3d34:	50 f0       	brcs	.+20     	; 0x3d4a <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    3d36:	ef 81       	ldd	r30, Y+7	; 0x07
    3d38:	f8 85       	ldd	r31, Y+8	; 0x08
    3d3a:	24 81       	ldd	r18, Z+4	; 0x04
    3d3c:	35 81       	ldd	r19, Z+5	; 0x05
    3d3e:	89 81       	ldd	r24, Y+1	; 0x01
    3d40:	9a 81       	ldd	r25, Y+2	; 0x02
    3d42:	82 1b       	sub	r24, r18
    3d44:	93 0b       	sbc	r25, r19
    3d46:	9a 83       	std	Y+2, r25	; 0x02
    3d48:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    3d4a:	ef 81       	ldd	r30, Y+7	; 0x07
    3d4c:	f8 85       	ldd	r31, Y+8	; 0x08
    3d4e:	89 81       	ldd	r24, Y+1	; 0x01
    3d50:	9a 81       	ldd	r25, Y+2	; 0x02
    3d52:	91 83       	std	Z+1, r25	; 0x01
    3d54:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3d56:	8d 81       	ldd	r24, Y+5	; 0x05
    3d58:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3d5a:	66 96       	adiw	r28, 0x16	; 22
    3d5c:	0f b6       	in	r0, 0x3f	; 63
    3d5e:	f8 94       	cli
    3d60:	de bf       	out	0x3e, r29	; 62
    3d62:	0f be       	out	0x3f, r0	; 63
    3d64:	cd bf       	out	0x3d, r28	; 61
    3d66:	cf 91       	pop	r28
    3d68:	df 91       	pop	r29
    3d6a:	08 95       	ret

00003d6c <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3d6c:	df 93       	push	r29
    3d6e:	cf 93       	push	r28
    3d70:	00 d0       	rcall	.+0      	; 0x3d72 <prvBytesInBuffer+0x6>
    3d72:	00 d0       	rcall	.+0      	; 0x3d74 <prvBytesInBuffer+0x8>
    3d74:	cd b7       	in	r28, 0x3d	; 61
    3d76:	de b7       	in	r29, 0x3e	; 62
    3d78:	9c 83       	std	Y+4, r25	; 0x04
    3d7a:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3d7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d80:	24 81       	ldd	r18, Z+4	; 0x04
    3d82:	35 81       	ldd	r19, Z+5	; 0x05
    3d84:	eb 81       	ldd	r30, Y+3	; 0x03
    3d86:	fc 81       	ldd	r31, Y+4	; 0x04
    3d88:	82 81       	ldd	r24, Z+2	; 0x02
    3d8a:	93 81       	ldd	r25, Z+3	; 0x03
    3d8c:	82 0f       	add	r24, r18
    3d8e:	93 1f       	adc	r25, r19
    3d90:	9a 83       	std	Y+2, r25	; 0x02
    3d92:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3d94:	eb 81       	ldd	r30, Y+3	; 0x03
    3d96:	fc 81       	ldd	r31, Y+4	; 0x04
    3d98:	20 81       	ld	r18, Z
    3d9a:	31 81       	ldd	r19, Z+1	; 0x01
    3d9c:	89 81       	ldd	r24, Y+1	; 0x01
    3d9e:	9a 81       	ldd	r25, Y+2	; 0x02
    3da0:	82 1b       	sub	r24, r18
    3da2:	93 0b       	sbc	r25, r19
    3da4:	9a 83       	std	Y+2, r25	; 0x02
    3da6:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    3da8:	eb 81       	ldd	r30, Y+3	; 0x03
    3daa:	fc 81       	ldd	r31, Y+4	; 0x04
    3dac:	24 81       	ldd	r18, Z+4	; 0x04
    3dae:	35 81       	ldd	r19, Z+5	; 0x05
    3db0:	89 81       	ldd	r24, Y+1	; 0x01
    3db2:	9a 81       	ldd	r25, Y+2	; 0x02
    3db4:	82 17       	cp	r24, r18
    3db6:	93 07       	cpc	r25, r19
    3db8:	50 f0       	brcs	.+20     	; 0x3dce <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    3dba:	eb 81       	ldd	r30, Y+3	; 0x03
    3dbc:	fc 81       	ldd	r31, Y+4	; 0x04
    3dbe:	24 81       	ldd	r18, Z+4	; 0x04
    3dc0:	35 81       	ldd	r19, Z+5	; 0x05
    3dc2:	89 81       	ldd	r24, Y+1	; 0x01
    3dc4:	9a 81       	ldd	r25, Y+2	; 0x02
    3dc6:	82 1b       	sub	r24, r18
    3dc8:	93 0b       	sbc	r25, r19
    3dca:	9a 83       	std	Y+2, r25	; 0x02
    3dcc:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3dce:	89 81       	ldd	r24, Y+1	; 0x01
    3dd0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3dd2:	0f 90       	pop	r0
    3dd4:	0f 90       	pop	r0
    3dd6:	0f 90       	pop	r0
    3dd8:	0f 90       	pop	r0
    3dda:	cf 91       	pop	r28
    3ddc:	df 91       	pop	r29
    3dde:	08 95       	ret

00003de0 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    3de0:	0f 93       	push	r16
    3de2:	df 93       	push	r29
    3de4:	cf 93       	push	r28
    3de6:	cd b7       	in	r28, 0x3d	; 61
    3de8:	de b7       	in	r29, 0x3e	; 62
    3dea:	29 97       	sbiw	r28, 0x09	; 9
    3dec:	0f b6       	in	r0, 0x3f	; 63
    3dee:	f8 94       	cli
    3df0:	de bf       	out	0x3e, r29	; 62
    3df2:	0f be       	out	0x3f, r0	; 63
    3df4:	cd bf       	out	0x3d, r28	; 61
    3df6:	9a 83       	std	Y+2, r25	; 0x02
    3df8:	89 83       	std	Y+1, r24	; 0x01
    3dfa:	7c 83       	std	Y+4, r23	; 0x04
    3dfc:	6b 83       	std	Y+3, r22	; 0x03
    3dfe:	5e 83       	std	Y+6, r21	; 0x06
    3e00:	4d 83       	std	Y+5, r20	; 0x05
    3e02:	38 87       	std	Y+8, r19	; 0x08
    3e04:	2f 83       	std	Y+7, r18	; 0x07
    3e06:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3e08:	89 81       	ldd	r24, Y+1	; 0x01
    3e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e0c:	60 e0       	ldi	r22, 0x00	; 0
    3e0e:	70 e0       	ldi	r23, 0x00	; 0
    3e10:	4f e0       	ldi	r20, 0x0F	; 15
    3e12:	50 e0       	ldi	r21, 0x00	; 0
    3e14:	0e 94 1e 2e 	call	0x5c3c	; 0x5c3c <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    3e18:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e1c:	8b 81       	ldd	r24, Y+3	; 0x03
    3e1e:	9c 81       	ldd	r25, Y+4	; 0x04
    3e20:	95 87       	std	Z+13, r25	; 0x0d
    3e22:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    3e24:	e9 81       	ldd	r30, Y+1	; 0x01
    3e26:	fa 81       	ldd	r31, Y+2	; 0x02
    3e28:	8d 81       	ldd	r24, Y+5	; 0x05
    3e2a:	9e 81       	ldd	r25, Y+6	; 0x06
    3e2c:	95 83       	std	Z+5, r25	; 0x05
    3e2e:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3e30:	e9 81       	ldd	r30, Y+1	; 0x01
    3e32:	fa 81       	ldd	r31, Y+2	; 0x02
    3e34:	8f 81       	ldd	r24, Y+7	; 0x07
    3e36:	98 85       	ldd	r25, Y+8	; 0x08
    3e38:	97 83       	std	Z+7, r25	; 0x07
    3e3a:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3e3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e40:	89 85       	ldd	r24, Y+9	; 0x09
    3e42:	86 87       	std	Z+14, r24	; 0x0e
}
    3e44:	29 96       	adiw	r28, 0x09	; 9
    3e46:	0f b6       	in	r0, 0x3f	; 63
    3e48:	f8 94       	cli
    3e4a:	de bf       	out	0x3e, r29	; 62
    3e4c:	0f be       	out	0x3f, r0	; 63
    3e4e:	cd bf       	out	0x3d, r28	; 61
    3e50:	cf 91       	pop	r28
    3e52:	df 91       	pop	r29
    3e54:	0f 91       	pop	r16
    3e56:	08 95       	ret

00003e58 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3e58:	8f 92       	push	r8
    3e5a:	9f 92       	push	r9
    3e5c:	af 92       	push	r10
    3e5e:	bf 92       	push	r11
    3e60:	cf 92       	push	r12
    3e62:	df 92       	push	r13
    3e64:	ef 92       	push	r14
    3e66:	ff 92       	push	r15
    3e68:	0f 93       	push	r16
    3e6a:	1f 93       	push	r17
    3e6c:	df 93       	push	r29
    3e6e:	cf 93       	push	r28
    3e70:	cd b7       	in	r28, 0x3d	; 61
    3e72:	de b7       	in	r29, 0x3e	; 62
    3e74:	60 97       	sbiw	r28, 0x10	; 16
    3e76:	0f b6       	in	r0, 0x3f	; 63
    3e78:	f8 94       	cli
    3e7a:	de bf       	out	0x3e, r29	; 62
    3e7c:	0f be       	out	0x3f, r0	; 63
    3e7e:	cd bf       	out	0x3d, r28	; 61
    3e80:	9f 83       	std	Y+7, r25	; 0x07
    3e82:	8e 83       	std	Y+6, r24	; 0x06
    3e84:	79 87       	std	Y+9, r23	; 0x09
    3e86:	68 87       	std	Y+8, r22	; 0x08
    3e88:	5b 87       	std	Y+11, r21	; 0x0b
    3e8a:	4a 87       	std	Y+10, r20	; 0x0a
    3e8c:	3d 87       	std	Y+13, r19	; 0x0d
    3e8e:	2c 87       	std	Y+12, r18	; 0x0c
    3e90:	0e 87       	std	Y+14, r16	; 0x0e
    3e92:	f8 8a       	std	Y+16, r15	; 0x10
    3e94:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3e96:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e98:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e9a:	0e 94 a0 09 	call	0x1340	; 0x1340 <pvPortMalloc>
    3e9e:	9a 83       	std	Y+2, r25	; 0x02
    3ea0:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3ea2:	89 81       	ldd	r24, Y+1	; 0x01
    3ea4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea6:	00 97       	sbiw	r24, 0x00	; 0
    3ea8:	b1 f0       	breq	.+44     	; 0x3ed6 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3eaa:	84 e3       	ldi	r24, 0x34	; 52
    3eac:	90 e0       	ldi	r25, 0x00	; 0
    3eae:	0e 94 a0 09 	call	0x1340	; 0x1340 <pvPortMalloc>
    3eb2:	9d 83       	std	Y+5, r25	; 0x05
    3eb4:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3eb6:	8c 81       	ldd	r24, Y+4	; 0x04
    3eb8:	9d 81       	ldd	r25, Y+5	; 0x05
    3eba:	00 97       	sbiw	r24, 0x00	; 0
    3ebc:	39 f0       	breq	.+14     	; 0x3ecc <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3ebe:	ec 81       	ldd	r30, Y+4	; 0x04
    3ec0:	fd 81       	ldd	r31, Y+5	; 0x05
    3ec2:	89 81       	ldd	r24, Y+1	; 0x01
    3ec4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ec6:	90 8f       	std	Z+24, r25	; 0x18
    3ec8:	87 8b       	std	Z+23, r24	; 0x17
    3eca:	07 c0       	rjmp	.+14     	; 0x3eda <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3ecc:	89 81       	ldd	r24, Y+1	; 0x01
    3ece:	9a 81       	ldd	r25, Y+2	; 0x02
    3ed0:	0e 94 f6 09 	call	0x13ec	; 0x13ec <vPortFree>
    3ed4:	02 c0       	rjmp	.+4      	; 0x3eda <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3ed6:	1d 82       	std	Y+5, r1	; 0x05
    3ed8:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3eda:	8c 81       	ldd	r24, Y+4	; 0x04
    3edc:	9d 81       	ldd	r25, Y+5	; 0x05
    3ede:	00 97       	sbiw	r24, 0x00	; 0
    3ee0:	e9 f0       	breq	.+58     	; 0x3f1c <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3ee2:	8a 85       	ldd	r24, Y+10	; 0x0a
    3ee4:	9b 85       	ldd	r25, Y+11	; 0x0b
    3ee6:	9c 01       	movw	r18, r24
    3ee8:	40 e0       	ldi	r20, 0x00	; 0
    3eea:	50 e0       	ldi	r21, 0x00	; 0
    3eec:	8e 81       	ldd	r24, Y+6	; 0x06
    3eee:	9f 81       	ldd	r25, Y+7	; 0x07
    3ef0:	68 85       	ldd	r22, Y+8	; 0x08
    3ef2:	79 85       	ldd	r23, Y+9	; 0x09
    3ef4:	ec 85       	ldd	r30, Y+12	; 0x0c
    3ef6:	fd 85       	ldd	r31, Y+13	; 0x0d
    3ef8:	af 85       	ldd	r26, Y+15	; 0x0f
    3efa:	b8 89       	ldd	r27, Y+16	; 0x10
    3efc:	ac 80       	ldd	r10, Y+4	; 0x04
    3efe:	bd 80       	ldd	r11, Y+5	; 0x05
    3f00:	8f 01       	movw	r16, r30
    3f02:	ee 84       	ldd	r14, Y+14	; 0x0e
    3f04:	6d 01       	movw	r12, r26
    3f06:	88 24       	eor	r8, r8
    3f08:	99 24       	eor	r9, r9
    3f0a:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3f0e:	8c 81       	ldd	r24, Y+4	; 0x04
    3f10:	9d 81       	ldd	r25, Y+5	; 0x05
    3f12:	0e 94 67 20 	call	0x40ce	; 0x40ce <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3f16:	81 e0       	ldi	r24, 0x01	; 1
    3f18:	8b 83       	std	Y+3, r24	; 0x03
    3f1a:	02 c0       	rjmp	.+4      	; 0x3f20 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3f1c:	8f ef       	ldi	r24, 0xFF	; 255
    3f1e:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3f20:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3f22:	60 96       	adiw	r28, 0x10	; 16
    3f24:	0f b6       	in	r0, 0x3f	; 63
    3f26:	f8 94       	cli
    3f28:	de bf       	out	0x3e, r29	; 62
    3f2a:	0f be       	out	0x3f, r0	; 63
    3f2c:	cd bf       	out	0x3d, r28	; 61
    3f2e:	cf 91       	pop	r28
    3f30:	df 91       	pop	r29
    3f32:	1f 91       	pop	r17
    3f34:	0f 91       	pop	r16
    3f36:	ff 90       	pop	r15
    3f38:	ef 90       	pop	r14
    3f3a:	df 90       	pop	r13
    3f3c:	cf 90       	pop	r12
    3f3e:	bf 90       	pop	r11
    3f40:	af 90       	pop	r10
    3f42:	9f 90       	pop	r9
    3f44:	8f 90       	pop	r8
    3f46:	08 95       	ret

00003f48 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3f48:	8f 92       	push	r8
    3f4a:	9f 92       	push	r9
    3f4c:	af 92       	push	r10
    3f4e:	bf 92       	push	r11
    3f50:	cf 92       	push	r12
    3f52:	df 92       	push	r13
    3f54:	ef 92       	push	r14
    3f56:	0f 93       	push	r16
    3f58:	1f 93       	push	r17
    3f5a:	df 93       	push	r29
    3f5c:	cf 93       	push	r28
    3f5e:	cd b7       	in	r28, 0x3d	; 61
    3f60:	de b7       	in	r29, 0x3e	; 62
    3f62:	64 97       	sbiw	r28, 0x14	; 20
    3f64:	0f b6       	in	r0, 0x3f	; 63
    3f66:	f8 94       	cli
    3f68:	de bf       	out	0x3e, r29	; 62
    3f6a:	0f be       	out	0x3f, r0	; 63
    3f6c:	cd bf       	out	0x3d, r28	; 61
    3f6e:	9d 83       	std	Y+5, r25	; 0x05
    3f70:	8c 83       	std	Y+4, r24	; 0x04
    3f72:	7f 83       	std	Y+7, r23	; 0x07
    3f74:	6e 83       	std	Y+6, r22	; 0x06
    3f76:	28 87       	std	Y+8, r18	; 0x08
    3f78:	39 87       	std	Y+9, r19	; 0x09
    3f7a:	4a 87       	std	Y+10, r20	; 0x0a
    3f7c:	5b 87       	std	Y+11, r21	; 0x0b
    3f7e:	1d 87       	std	Y+13, r17	; 0x0d
    3f80:	0c 87       	std	Y+12, r16	; 0x0c
    3f82:	ee 86       	std	Y+14, r14	; 0x0e
    3f84:	d8 8a       	std	Y+16, r13	; 0x10
    3f86:	cf 86       	std	Y+15, r12	; 0x0f
    3f88:	ba 8a       	std	Y+18, r11	; 0x12
    3f8a:	a9 8a       	std	Y+17, r10	; 0x11
    3f8c:	9c 8a       	std	Y+20, r9	; 0x14
    3f8e:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3f90:	e9 89       	ldd	r30, Y+17	; 0x11
    3f92:	fa 89       	ldd	r31, Y+18	; 0x12
    3f94:	27 89       	ldd	r18, Z+23	; 0x17
    3f96:	30 8d       	ldd	r19, Z+24	; 0x18
    3f98:	88 85       	ldd	r24, Y+8	; 0x08
    3f9a:	99 85       	ldd	r25, Y+9	; 0x09
    3f9c:	01 97       	sbiw	r24, 0x01	; 1
    3f9e:	82 0f       	add	r24, r18
    3fa0:	93 1f       	adc	r25, r19
    3fa2:	9b 83       	std	Y+3, r25	; 0x03
    3fa4:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3fa6:	8e 81       	ldd	r24, Y+6	; 0x06
    3fa8:	9f 81       	ldd	r25, Y+7	; 0x07
    3faa:	00 97       	sbiw	r24, 0x00	; 0
    3fac:	51 f1       	breq	.+84     	; 0x4002 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3fae:	19 82       	std	Y+1, r1	; 0x01
    3fb0:	21 c0       	rjmp	.+66     	; 0x3ff4 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3fb2:	89 81       	ldd	r24, Y+1	; 0x01
    3fb4:	48 2f       	mov	r20, r24
    3fb6:	50 e0       	ldi	r21, 0x00	; 0
    3fb8:	89 81       	ldd	r24, Y+1	; 0x01
    3fba:	28 2f       	mov	r18, r24
    3fbc:	30 e0       	ldi	r19, 0x00	; 0
    3fbe:	8e 81       	ldd	r24, Y+6	; 0x06
    3fc0:	9f 81       	ldd	r25, Y+7	; 0x07
    3fc2:	fc 01       	movw	r30, r24
    3fc4:	e2 0f       	add	r30, r18
    3fc6:	f3 1f       	adc	r31, r19
    3fc8:	20 81       	ld	r18, Z
    3fca:	89 89       	ldd	r24, Y+17	; 0x11
    3fcc:	9a 89       	ldd	r25, Y+18	; 0x12
    3fce:	84 0f       	add	r24, r20
    3fd0:	95 1f       	adc	r25, r21
    3fd2:	fc 01       	movw	r30, r24
    3fd4:	79 96       	adiw	r30, 0x19	; 25
    3fd6:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3fd8:	89 81       	ldd	r24, Y+1	; 0x01
    3fda:	28 2f       	mov	r18, r24
    3fdc:	30 e0       	ldi	r19, 0x00	; 0
    3fde:	8e 81       	ldd	r24, Y+6	; 0x06
    3fe0:	9f 81       	ldd	r25, Y+7	; 0x07
    3fe2:	fc 01       	movw	r30, r24
    3fe4:	e2 0f       	add	r30, r18
    3fe6:	f3 1f       	adc	r31, r19
    3fe8:	80 81       	ld	r24, Z
    3fea:	88 23       	and	r24, r24
    3fec:	31 f0       	breq	.+12     	; 0x3ffa <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3fee:	89 81       	ldd	r24, Y+1	; 0x01
    3ff0:	8f 5f       	subi	r24, 0xFF	; 255
    3ff2:	89 83       	std	Y+1, r24	; 0x01
    3ff4:	89 81       	ldd	r24, Y+1	; 0x01
    3ff6:	84 31       	cpi	r24, 0x14	; 20
    3ff8:	e0 f2       	brcs	.-72     	; 0x3fb2 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3ffa:	e9 89       	ldd	r30, Y+17	; 0x11
    3ffc:	fa 89       	ldd	r31, Y+18	; 0x12
    3ffe:	14 a6       	std	Z+44, r1	; 0x2c
    4000:	03 c0       	rjmp	.+6      	; 0x4008 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4002:	e9 89       	ldd	r30, Y+17	; 0x11
    4004:	fa 89       	ldd	r31, Y+18	; 0x12
    4006:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4008:	8e 85       	ldd	r24, Y+14	; 0x0e
    400a:	87 30       	cpi	r24, 0x07	; 7
    400c:	10 f0       	brcs	.+4      	; 0x4012 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    400e:	86 e0       	ldi	r24, 0x06	; 6
    4010:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4012:	e9 89       	ldd	r30, Y+17	; 0x11
    4014:	fa 89       	ldd	r31, Y+18	; 0x12
    4016:	8e 85       	ldd	r24, Y+14	; 0x0e
    4018:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    401a:	e9 89       	ldd	r30, Y+17	; 0x11
    401c:	fa 89       	ldd	r31, Y+18	; 0x12
    401e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4020:	85 a7       	std	Z+45, r24	; 0x2d
		pxNewTCB->uxMutexesHeld = 0;
    4022:	e9 89       	ldd	r30, Y+17	; 0x11
    4024:	fa 89       	ldd	r31, Y+18	; 0x12
    4026:	16 a6       	std	Z+46, r1	; 0x2e
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4028:	89 89       	ldd	r24, Y+17	; 0x11
    402a:	9a 89       	ldd	r25, Y+18	; 0x12
    402c:	02 96       	adiw	r24, 0x02	; 2
    402e:	0e 94 cf 0b 	call	0x179e	; 0x179e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4032:	89 89       	ldd	r24, Y+17	; 0x11
    4034:	9a 89       	ldd	r25, Y+18	; 0x12
    4036:	0c 96       	adiw	r24, 0x0c	; 12
    4038:	0e 94 cf 0b 	call	0x179e	; 0x179e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    403c:	e9 89       	ldd	r30, Y+17	; 0x11
    403e:	fa 89       	ldd	r31, Y+18	; 0x12
    4040:	89 89       	ldd	r24, Y+17	; 0x11
    4042:	9a 89       	ldd	r25, Y+18	; 0x12
    4044:	91 87       	std	Z+9, r25	; 0x09
    4046:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4048:	8e 85       	ldd	r24, Y+14	; 0x0e
    404a:	28 2f       	mov	r18, r24
    404c:	30 e0       	ldi	r19, 0x00	; 0
    404e:	87 e0       	ldi	r24, 0x07	; 7
    4050:	90 e0       	ldi	r25, 0x00	; 0
    4052:	82 1b       	sub	r24, r18
    4054:	93 0b       	sbc	r25, r19
    4056:	e9 89       	ldd	r30, Y+17	; 0x11
    4058:	fa 89       	ldd	r31, Y+18	; 0x12
    405a:	95 87       	std	Z+13, r25	; 0x0d
    405c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    405e:	e9 89       	ldd	r30, Y+17	; 0x11
    4060:	fa 89       	ldd	r31, Y+18	; 0x12
    4062:	89 89       	ldd	r24, Y+17	; 0x11
    4064:	9a 89       	ldd	r25, Y+18	; 0x12
    4066:	93 8b       	std	Z+19, r25	; 0x13
    4068:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    406a:	e9 89       	ldd	r30, Y+17	; 0x11
    406c:	fa 89       	ldd	r31, Y+18	; 0x12
    406e:	17 a6       	std	Z+47, r1	; 0x2f
    4070:	10 aa       	std	Z+48, r1	; 0x30
    4072:	11 aa       	std	Z+49, r1	; 0x31
    4074:	12 aa       	std	Z+50, r1	; 0x32
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4076:	e9 89       	ldd	r30, Y+17	; 0x11
    4078:	fa 89       	ldd	r31, Y+18	; 0x12
    407a:	13 aa       	std	Z+51, r1	; 0x33
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    407c:	8a 81       	ldd	r24, Y+2	; 0x02
    407e:	9b 81       	ldd	r25, Y+3	; 0x03
    4080:	2c 81       	ldd	r18, Y+4	; 0x04
    4082:	3d 81       	ldd	r19, Y+5	; 0x05
    4084:	4c 85       	ldd	r20, Y+12	; 0x0c
    4086:	5d 85       	ldd	r21, Y+13	; 0x0d
    4088:	b9 01       	movw	r22, r18
    408a:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <pxPortInitialiseStack>
    408e:	e9 89       	ldd	r30, Y+17	; 0x11
    4090:	fa 89       	ldd	r31, Y+18	; 0x12
    4092:	91 83       	std	Z+1, r25	; 0x01
    4094:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    4096:	8f 85       	ldd	r24, Y+15	; 0x0f
    4098:	98 89       	ldd	r25, Y+16	; 0x10
    409a:	00 97       	sbiw	r24, 0x00	; 0
    409c:	31 f0       	breq	.+12     	; 0x40aa <prvInitialiseNewTask+0x162>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    409e:	ef 85       	ldd	r30, Y+15	; 0x0f
    40a0:	f8 89       	ldd	r31, Y+16	; 0x10
    40a2:	89 89       	ldd	r24, Y+17	; 0x11
    40a4:	9a 89       	ldd	r25, Y+18	; 0x12
    40a6:	91 83       	std	Z+1, r25	; 0x01
    40a8:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    40aa:	64 96       	adiw	r28, 0x14	; 20
    40ac:	0f b6       	in	r0, 0x3f	; 63
    40ae:	f8 94       	cli
    40b0:	de bf       	out	0x3e, r29	; 62
    40b2:	0f be       	out	0x3f, r0	; 63
    40b4:	cd bf       	out	0x3d, r28	; 61
    40b6:	cf 91       	pop	r28
    40b8:	df 91       	pop	r29
    40ba:	1f 91       	pop	r17
    40bc:	0f 91       	pop	r16
    40be:	ef 90       	pop	r14
    40c0:	df 90       	pop	r13
    40c2:	cf 90       	pop	r12
    40c4:	bf 90       	pop	r11
    40c6:	af 90       	pop	r10
    40c8:	9f 90       	pop	r9
    40ca:	8f 90       	pop	r8
    40cc:	08 95       	ret

000040ce <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    40ce:	df 93       	push	r29
    40d0:	cf 93       	push	r28
    40d2:	00 d0       	rcall	.+0      	; 0x40d4 <prvAddNewTaskToReadyList+0x6>
    40d4:	cd b7       	in	r28, 0x3d	; 61
    40d6:	de b7       	in	r29, 0x3e	; 62
    40d8:	9a 83       	std	Y+2, r25	; 0x02
    40da:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    40dc:	0f b6       	in	r0, 0x3f	; 63
    40de:	f8 94       	cli
    40e0:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    40e2:	80 91 d1 06 	lds	r24, 0x06D1
    40e6:	8f 5f       	subi	r24, 0xFF	; 255
    40e8:	80 93 d1 06 	sts	0x06D1, r24
		if( pxCurrentTCB == NULL )
    40ec:	80 91 ce 06 	lds	r24, 0x06CE
    40f0:	90 91 cf 06 	lds	r25, 0x06CF
    40f4:	00 97       	sbiw	r24, 0x00	; 0
    40f6:	69 f4       	brne	.+26     	; 0x4112 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    40f8:	89 81       	ldd	r24, Y+1	; 0x01
    40fa:	9a 81       	ldd	r25, Y+2	; 0x02
    40fc:	90 93 cf 06 	sts	0x06CF, r25
    4100:	80 93 ce 06 	sts	0x06CE, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4104:	80 91 d1 06 	lds	r24, 0x06D1
    4108:	81 30       	cpi	r24, 0x01	; 1
    410a:	b9 f4       	brne	.+46     	; 0x413a <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    410c:	0e 94 3e 27 	call	0x4e7c	; 0x4e7c <prvInitialiseTaskLists>
    4110:	14 c0       	rjmp	.+40     	; 0x413a <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4112:	80 91 d5 06 	lds	r24, 0x06D5
    4116:	88 23       	and	r24, r24
    4118:	81 f4       	brne	.+32     	; 0x413a <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    411a:	e0 91 ce 06 	lds	r30, 0x06CE
    411e:	f0 91 cf 06 	lds	r31, 0x06CF
    4122:	96 89       	ldd	r25, Z+22	; 0x16
    4124:	e9 81       	ldd	r30, Y+1	; 0x01
    4126:	fa 81       	ldd	r31, Y+2	; 0x02
    4128:	86 89       	ldd	r24, Z+22	; 0x16
    412a:	89 17       	cp	r24, r25
    412c:	30 f0       	brcs	.+12     	; 0x413a <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    412e:	89 81       	ldd	r24, Y+1	; 0x01
    4130:	9a 81       	ldd	r25, Y+2	; 0x02
    4132:	90 93 cf 06 	sts	0x06CF, r25
    4136:	80 93 ce 06 	sts	0x06CE, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    413a:	80 91 d9 06 	lds	r24, 0x06D9
    413e:	8f 5f       	subi	r24, 0xFF	; 255
    4140:	80 93 d9 06 	sts	0x06D9, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4144:	e9 81       	ldd	r30, Y+1	; 0x01
    4146:	fa 81       	ldd	r31, Y+2	; 0x02
    4148:	96 89       	ldd	r25, Z+22	; 0x16
    414a:	80 91 d4 06 	lds	r24, 0x06D4
    414e:	89 17       	cp	r24, r25
    4150:	28 f4       	brcc	.+10     	; 0x415c <prvAddNewTaskToReadyList+0x8e>
    4152:	e9 81       	ldd	r30, Y+1	; 0x01
    4154:	fa 81       	ldd	r31, Y+2	; 0x02
    4156:	86 89       	ldd	r24, Z+22	; 0x16
    4158:	80 93 d4 06 	sts	0x06D4, r24
    415c:	e9 81       	ldd	r30, Y+1	; 0x01
    415e:	fa 81       	ldd	r31, Y+2	; 0x02
    4160:	86 89       	ldd	r24, Z+22	; 0x16
    4162:	28 2f       	mov	r18, r24
    4164:	30 e0       	ldi	r19, 0x00	; 0
    4166:	c9 01       	movw	r24, r18
    4168:	88 0f       	add	r24, r24
    416a:	99 1f       	adc	r25, r25
    416c:	88 0f       	add	r24, r24
    416e:	99 1f       	adc	r25, r25
    4170:	88 0f       	add	r24, r24
    4172:	99 1f       	adc	r25, r25
    4174:	82 0f       	add	r24, r18
    4176:	93 1f       	adc	r25, r19
    4178:	ac 01       	movw	r20, r24
    417a:	41 52       	subi	r20, 0x21	; 33
    417c:	59 4f       	sbci	r21, 0xF9	; 249
    417e:	89 81       	ldd	r24, Y+1	; 0x01
    4180:	9a 81       	ldd	r25, Y+2	; 0x02
    4182:	9c 01       	movw	r18, r24
    4184:	2e 5f       	subi	r18, 0xFE	; 254
    4186:	3f 4f       	sbci	r19, 0xFF	; 255
    4188:	ca 01       	movw	r24, r20
    418a:	b9 01       	movw	r22, r18
    418c:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4190:	0f 90       	pop	r0
    4192:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4194:	80 91 d5 06 	lds	r24, 0x06D5
    4198:	88 23       	and	r24, r24
    419a:	61 f0       	breq	.+24     	; 0x41b4 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    419c:	e0 91 ce 06 	lds	r30, 0x06CE
    41a0:	f0 91 cf 06 	lds	r31, 0x06CF
    41a4:	96 89       	ldd	r25, Z+22	; 0x16
    41a6:	e9 81       	ldd	r30, Y+1	; 0x01
    41a8:	fa 81       	ldd	r31, Y+2	; 0x02
    41aa:	86 89       	ldd	r24, Z+22	; 0x16
    41ac:	98 17       	cp	r25, r24
    41ae:	10 f4       	brcc	.+4      	; 0x41b4 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    41b0:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    41b4:	0f 90       	pop	r0
    41b6:	0f 90       	pop	r0
    41b8:	cf 91       	pop	r28
    41ba:	df 91       	pop	r29
    41bc:	08 95       	ret

000041be <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    41be:	df 93       	push	r29
    41c0:	cf 93       	push	r28
    41c2:	00 d0       	rcall	.+0      	; 0x41c4 <vTaskDelete+0x6>
    41c4:	00 d0       	rcall	.+0      	; 0x41c6 <vTaskDelete+0x8>
    41c6:	00 d0       	rcall	.+0      	; 0x41c8 <vTaskDelete+0xa>
    41c8:	cd b7       	in	r28, 0x3d	; 61
    41ca:	de b7       	in	r29, 0x3e	; 62
    41cc:	9c 83       	std	Y+4, r25	; 0x04
    41ce:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    41d0:	0f b6       	in	r0, 0x3f	; 63
    41d2:	f8 94       	cli
    41d4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    41d6:	8b 81       	ldd	r24, Y+3	; 0x03
    41d8:	9c 81       	ldd	r25, Y+4	; 0x04
    41da:	00 97       	sbiw	r24, 0x00	; 0
    41dc:	39 f4       	brne	.+14     	; 0x41ec <vTaskDelete+0x2e>
    41de:	80 91 ce 06 	lds	r24, 0x06CE
    41e2:	90 91 cf 06 	lds	r25, 0x06CF
    41e6:	9e 83       	std	Y+6, r25	; 0x06
    41e8:	8d 83       	std	Y+5, r24	; 0x05
    41ea:	04 c0       	rjmp	.+8      	; 0x41f4 <vTaskDelete+0x36>
    41ec:	8b 81       	ldd	r24, Y+3	; 0x03
    41ee:	9c 81       	ldd	r25, Y+4	; 0x04
    41f0:	9e 83       	std	Y+6, r25	; 0x06
    41f2:	8d 83       	std	Y+5, r24	; 0x05
    41f4:	8d 81       	ldd	r24, Y+5	; 0x05
    41f6:	9e 81       	ldd	r25, Y+6	; 0x06
    41f8:	9a 83       	std	Y+2, r25	; 0x02
    41fa:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    41fc:	89 81       	ldd	r24, Y+1	; 0x01
    41fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4200:	02 96       	adiw	r24, 0x02	; 2
    4202:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4206:	e9 81       	ldd	r30, Y+1	; 0x01
    4208:	fa 81       	ldd	r31, Y+2	; 0x02
    420a:	84 89       	ldd	r24, Z+20	; 0x14
    420c:	95 89       	ldd	r25, Z+21	; 0x15
    420e:	00 97       	sbiw	r24, 0x00	; 0
    4210:	29 f0       	breq	.+10     	; 0x421c <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4212:	89 81       	ldd	r24, Y+1	; 0x01
    4214:	9a 81       	ldd	r25, Y+2	; 0x02
    4216:	0c 96       	adiw	r24, 0x0c	; 12
    4218:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    421c:	80 91 d9 06 	lds	r24, 0x06D9
    4220:	8f 5f       	subi	r24, 0xFF	; 255
    4222:	80 93 d9 06 	sts	0x06D9, r24

			if( pxTCB == pxCurrentTCB )
    4226:	20 91 ce 06 	lds	r18, 0x06CE
    422a:	30 91 cf 06 	lds	r19, 0x06CF
    422e:	89 81       	ldd	r24, Y+1	; 0x01
    4230:	9a 81       	ldd	r25, Y+2	; 0x02
    4232:	82 17       	cp	r24, r18
    4234:	93 07       	cpc	r25, r19
    4236:	81 f4       	brne	.+32     	; 0x4258 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4238:	89 81       	ldd	r24, Y+1	; 0x01
    423a:	9a 81       	ldd	r25, Y+2	; 0x02
    423c:	9c 01       	movw	r18, r24
    423e:	2e 5f       	subi	r18, 0xFE	; 254
    4240:	3f 4f       	sbci	r19, 0xFF	; 255
    4242:	8d e3       	ldi	r24, 0x3D	; 61
    4244:	97 e0       	ldi	r25, 0x07	; 7
    4246:	b9 01       	movw	r22, r18
    4248:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    424c:	80 91 d0 06 	lds	r24, 0x06D0
    4250:	8f 5f       	subi	r24, 0xFF	; 255
    4252:	80 93 d0 06 	sts	0x06D0, r24
    4256:	0b c0       	rjmp	.+22     	; 0x426e <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4258:	80 91 d1 06 	lds	r24, 0x06D1
    425c:	81 50       	subi	r24, 0x01	; 1
    425e:	80 93 d1 06 	sts	0x06D1, r24
				prvDeleteTCB( pxTCB );
    4262:	89 81       	ldd	r24, Y+1	; 0x01
    4264:	9a 81       	ldd	r25, Y+2	; 0x02
    4266:	0e 94 ae 27 	call	0x4f5c	; 0x4f5c <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    426a:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    426e:	0f 90       	pop	r0
    4270:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4272:	80 91 d5 06 	lds	r24, 0x06D5
    4276:	88 23       	and	r24, r24
    4278:	59 f0       	breq	.+22     	; 0x4290 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    427a:	20 91 ce 06 	lds	r18, 0x06CE
    427e:	30 91 cf 06 	lds	r19, 0x06CF
    4282:	89 81       	ldd	r24, Y+1	; 0x01
    4284:	9a 81       	ldd	r25, Y+2	; 0x02
    4286:	82 17       	cp	r24, r18
    4288:	93 07       	cpc	r25, r19
    428a:	11 f4       	brne	.+4      	; 0x4290 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    428c:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4290:	26 96       	adiw	r28, 0x06	; 6
    4292:	0f b6       	in	r0, 0x3f	; 63
    4294:	f8 94       	cli
    4296:	de bf       	out	0x3e, r29	; 62
    4298:	0f be       	out	0x3f, r0	; 63
    429a:	cd bf       	out	0x3d, r28	; 61
    429c:	cf 91       	pop	r28
    429e:	df 91       	pop	r29
    42a0:	08 95       	ret

000042a2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    42a2:	df 93       	push	r29
    42a4:	cf 93       	push	r28
    42a6:	00 d0       	rcall	.+0      	; 0x42a8 <vTaskDelay+0x6>
    42a8:	0f 92       	push	r0
    42aa:	cd b7       	in	r28, 0x3d	; 61
    42ac:	de b7       	in	r29, 0x3e	; 62
    42ae:	9b 83       	std	Y+3, r25	; 0x03
    42b0:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    42b2:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    42b4:	8a 81       	ldd	r24, Y+2	; 0x02
    42b6:	9b 81       	ldd	r25, Y+3	; 0x03
    42b8:	00 97       	sbiw	r24, 0x00	; 0
    42ba:	51 f0       	breq	.+20     	; 0x42d0 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    42bc:	0e 94 1e 23 	call	0x463c	; 0x463c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    42c0:	8a 81       	ldd	r24, Y+2	; 0x02
    42c2:	9b 81       	ldd	r25, Y+3	; 0x03
    42c4:	60 e0       	ldi	r22, 0x00	; 0
    42c6:	0e 94 8d 2d 	call	0x5b1a	; 0x5b1a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    42ca:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskResumeAll>
    42ce:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    42d0:	89 81       	ldd	r24, Y+1	; 0x01
    42d2:	88 23       	and	r24, r24
    42d4:	11 f4       	brne	.+4      	; 0x42da <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    42d6:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    42da:	0f 90       	pop	r0
    42dc:	0f 90       	pop	r0
    42de:	0f 90       	pop	r0
    42e0:	cf 91       	pop	r28
    42e2:	df 91       	pop	r29
    42e4:	08 95       	ret

000042e6 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    42e6:	df 93       	push	r29
    42e8:	cf 93       	push	r28
    42ea:	00 d0       	rcall	.+0      	; 0x42ec <vTaskSuspend+0x6>
    42ec:	00 d0       	rcall	.+0      	; 0x42ee <vTaskSuspend+0x8>
    42ee:	00 d0       	rcall	.+0      	; 0x42f0 <vTaskSuspend+0xa>
    42f0:	cd b7       	in	r28, 0x3d	; 61
    42f2:	de b7       	in	r29, 0x3e	; 62
    42f4:	9c 83       	std	Y+4, r25	; 0x04
    42f6:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    42f8:	0f b6       	in	r0, 0x3f	; 63
    42fa:	f8 94       	cli
    42fc:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    42fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4300:	9c 81       	ldd	r25, Y+4	; 0x04
    4302:	00 97       	sbiw	r24, 0x00	; 0
    4304:	39 f4       	brne	.+14     	; 0x4314 <vTaskSuspend+0x2e>
    4306:	80 91 ce 06 	lds	r24, 0x06CE
    430a:	90 91 cf 06 	lds	r25, 0x06CF
    430e:	9e 83       	std	Y+6, r25	; 0x06
    4310:	8d 83       	std	Y+5, r24	; 0x05
    4312:	04 c0       	rjmp	.+8      	; 0x431c <vTaskSuspend+0x36>
    4314:	8b 81       	ldd	r24, Y+3	; 0x03
    4316:	9c 81       	ldd	r25, Y+4	; 0x04
    4318:	9e 83       	std	Y+6, r25	; 0x06
    431a:	8d 83       	std	Y+5, r24	; 0x05
    431c:	8d 81       	ldd	r24, Y+5	; 0x05
    431e:	9e 81       	ldd	r25, Y+6	; 0x06
    4320:	9a 83       	std	Y+2, r25	; 0x02
    4322:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4324:	89 81       	ldd	r24, Y+1	; 0x01
    4326:	9a 81       	ldd	r25, Y+2	; 0x02
    4328:	02 96       	adiw	r24, 0x02	; 2
    432a:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    432e:	e9 81       	ldd	r30, Y+1	; 0x01
    4330:	fa 81       	ldd	r31, Y+2	; 0x02
    4332:	84 89       	ldd	r24, Z+20	; 0x14
    4334:	95 89       	ldd	r25, Z+21	; 0x15
    4336:	00 97       	sbiw	r24, 0x00	; 0
    4338:	29 f0       	breq	.+10     	; 0x4344 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    433a:	89 81       	ldd	r24, Y+1	; 0x01
    433c:	9a 81       	ldd	r25, Y+2	; 0x02
    433e:	0c 96       	adiw	r24, 0x0c	; 12
    4340:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    4344:	89 81       	ldd	r24, Y+1	; 0x01
    4346:	9a 81       	ldd	r25, Y+2	; 0x02
    4348:	9c 01       	movw	r18, r24
    434a:	2e 5f       	subi	r18, 0xFE	; 254
    434c:	3f 4f       	sbci	r19, 0xFF	; 255
    434e:	86 e4       	ldi	r24, 0x46	; 70
    4350:	97 e0       	ldi	r25, 0x07	; 7
    4352:	b9 01       	movw	r22, r18
    4354:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    4358:	e9 81       	ldd	r30, Y+1	; 0x01
    435a:	fa 81       	ldd	r31, Y+2	; 0x02
    435c:	83 a9       	ldd	r24, Z+51	; 0x33
    435e:	81 30       	cpi	r24, 0x01	; 1
    4360:	19 f4       	brne	.+6      	; 0x4368 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4362:	e9 81       	ldd	r30, Y+1	; 0x01
    4364:	fa 81       	ldd	r31, Y+2	; 0x02
    4366:	13 aa       	std	Z+51, r1	; 0x33
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    4368:	0f 90       	pop	r0
    436a:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    436c:	80 91 d5 06 	lds	r24, 0x06D5
    4370:	88 23       	and	r24, r24
    4372:	39 f0       	breq	.+14     	; 0x4382 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    4374:	0f b6       	in	r0, 0x3f	; 63
    4376:	f8 94       	cli
    4378:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    437a:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    437e:	0f 90       	pop	r0
    4380:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    4382:	20 91 ce 06 	lds	r18, 0x06CE
    4386:	30 91 cf 06 	lds	r19, 0x06CF
    438a:	89 81       	ldd	r24, Y+1	; 0x01
    438c:	9a 81       	ldd	r25, Y+2	; 0x02
    438e:	82 17       	cp	r24, r18
    4390:	93 07       	cpc	r25, r19
    4392:	a1 f4       	brne	.+40     	; 0x43bc <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    4394:	80 91 d5 06 	lds	r24, 0x06D5
    4398:	88 23       	and	r24, r24
    439a:	19 f0       	breq	.+6      	; 0x43a2 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    439c:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
    43a0:	0d c0       	rjmp	.+26     	; 0x43bc <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    43a2:	90 91 46 07 	lds	r25, 0x0746
    43a6:	80 91 d1 06 	lds	r24, 0x06D1
    43aa:	98 17       	cp	r25, r24
    43ac:	29 f4       	brne	.+10     	; 0x43b8 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    43ae:	10 92 cf 06 	sts	0x06CF, r1
    43b2:	10 92 ce 06 	sts	0x06CE, r1
    43b6:	02 c0       	rjmp	.+4      	; 0x43bc <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    43b8:	0e 94 ff 24 	call	0x49fe	; 0x49fe <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    43bc:	26 96       	adiw	r28, 0x06	; 6
    43be:	0f b6       	in	r0, 0x3f	; 63
    43c0:	f8 94       	cli
    43c2:	de bf       	out	0x3e, r29	; 62
    43c4:	0f be       	out	0x3f, r0	; 63
    43c6:	cd bf       	out	0x3d, r28	; 61
    43c8:	cf 91       	pop	r28
    43ca:	df 91       	pop	r29
    43cc:	08 95       	ret

000043ce <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    43ce:	df 93       	push	r29
    43d0:	cf 93       	push	r28
    43d2:	00 d0       	rcall	.+0      	; 0x43d4 <prvTaskIsTaskSuspended+0x6>
    43d4:	00 d0       	rcall	.+0      	; 0x43d6 <prvTaskIsTaskSuspended+0x8>
    43d6:	0f 92       	push	r0
    43d8:	cd b7       	in	r28, 0x3d	; 61
    43da:	de b7       	in	r29, 0x3e	; 62
    43dc:	9d 83       	std	Y+5, r25	; 0x05
    43de:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    43e0:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    43e2:	8c 81       	ldd	r24, Y+4	; 0x04
    43e4:	9d 81       	ldd	r25, Y+5	; 0x05
    43e6:	9a 83       	std	Y+2, r25	; 0x02
    43e8:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    43ea:	e9 81       	ldd	r30, Y+1	; 0x01
    43ec:	fa 81       	ldd	r31, Y+2	; 0x02
    43ee:	82 85       	ldd	r24, Z+10	; 0x0a
    43f0:	93 85       	ldd	r25, Z+11	; 0x0b
    43f2:	27 e0       	ldi	r18, 0x07	; 7
    43f4:	86 34       	cpi	r24, 0x46	; 70
    43f6:	92 07       	cpc	r25, r18
    43f8:	81 f4       	brne	.+32     	; 0x441a <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    43fa:	e9 81       	ldd	r30, Y+1	; 0x01
    43fc:	fa 81       	ldd	r31, Y+2	; 0x02
    43fe:	84 89       	ldd	r24, Z+20	; 0x14
    4400:	95 89       	ldd	r25, Z+21	; 0x15
    4402:	27 e0       	ldi	r18, 0x07	; 7
    4404:	84 33       	cpi	r24, 0x34	; 52
    4406:	92 07       	cpc	r25, r18
    4408:	41 f0       	breq	.+16     	; 0x441a <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    440a:	e9 81       	ldd	r30, Y+1	; 0x01
    440c:	fa 81       	ldd	r31, Y+2	; 0x02
    440e:	84 89       	ldd	r24, Z+20	; 0x14
    4410:	95 89       	ldd	r25, Z+21	; 0x15
    4412:	00 97       	sbiw	r24, 0x00	; 0
    4414:	11 f4       	brne	.+4      	; 0x441a <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    4416:	81 e0       	ldi	r24, 0x01	; 1
    4418:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    441a:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    441c:	0f 90       	pop	r0
    441e:	0f 90       	pop	r0
    4420:	0f 90       	pop	r0
    4422:	0f 90       	pop	r0
    4424:	0f 90       	pop	r0
    4426:	cf 91       	pop	r28
    4428:	df 91       	pop	r29
    442a:	08 95       	ret

0000442c <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    442c:	df 93       	push	r29
    442e:	cf 93       	push	r28
    4430:	00 d0       	rcall	.+0      	; 0x4432 <vTaskResume+0x6>
    4432:	00 d0       	rcall	.+0      	; 0x4434 <vTaskResume+0x8>
    4434:	cd b7       	in	r28, 0x3d	; 61
    4436:	de b7       	in	r29, 0x3e	; 62
    4438:	9c 83       	std	Y+4, r25	; 0x04
    443a:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    443c:	8b 81       	ldd	r24, Y+3	; 0x03
    443e:	9c 81       	ldd	r25, Y+4	; 0x04
    4440:	9a 83       	std	Y+2, r25	; 0x02
    4442:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    4444:	20 91 ce 06 	lds	r18, 0x06CE
    4448:	30 91 cf 06 	lds	r19, 0x06CF
    444c:	89 81       	ldd	r24, Y+1	; 0x01
    444e:	9a 81       	ldd	r25, Y+2	; 0x02
    4450:	82 17       	cp	r24, r18
    4452:	93 07       	cpc	r25, r19
    4454:	09 f4       	brne	.+2      	; 0x4458 <vTaskResume+0x2c>
    4456:	47 c0       	rjmp	.+142    	; 0x44e6 <vTaskResume+0xba>
    4458:	89 81       	ldd	r24, Y+1	; 0x01
    445a:	9a 81       	ldd	r25, Y+2	; 0x02
    445c:	00 97       	sbiw	r24, 0x00	; 0
    445e:	09 f4       	brne	.+2      	; 0x4462 <vTaskResume+0x36>
    4460:	42 c0       	rjmp	.+132    	; 0x44e6 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    4462:	0f b6       	in	r0, 0x3f	; 63
    4464:	f8 94       	cli
    4466:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4468:	89 81       	ldd	r24, Y+1	; 0x01
    446a:	9a 81       	ldd	r25, Y+2	; 0x02
    446c:	0e 94 e7 21 	call	0x43ce	; 0x43ce <prvTaskIsTaskSuspended>
    4470:	88 23       	and	r24, r24
    4472:	b9 f1       	breq	.+110    	; 0x44e2 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    4474:	89 81       	ldd	r24, Y+1	; 0x01
    4476:	9a 81       	ldd	r25, Y+2	; 0x02
    4478:	02 96       	adiw	r24, 0x02	; 2
    447a:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    447e:	e9 81       	ldd	r30, Y+1	; 0x01
    4480:	fa 81       	ldd	r31, Y+2	; 0x02
    4482:	96 89       	ldd	r25, Z+22	; 0x16
    4484:	80 91 d4 06 	lds	r24, 0x06D4
    4488:	89 17       	cp	r24, r25
    448a:	28 f4       	brcc	.+10     	; 0x4496 <vTaskResume+0x6a>
    448c:	e9 81       	ldd	r30, Y+1	; 0x01
    448e:	fa 81       	ldd	r31, Y+2	; 0x02
    4490:	86 89       	ldd	r24, Z+22	; 0x16
    4492:	80 93 d4 06 	sts	0x06D4, r24
    4496:	e9 81       	ldd	r30, Y+1	; 0x01
    4498:	fa 81       	ldd	r31, Y+2	; 0x02
    449a:	86 89       	ldd	r24, Z+22	; 0x16
    449c:	28 2f       	mov	r18, r24
    449e:	30 e0       	ldi	r19, 0x00	; 0
    44a0:	c9 01       	movw	r24, r18
    44a2:	88 0f       	add	r24, r24
    44a4:	99 1f       	adc	r25, r25
    44a6:	88 0f       	add	r24, r24
    44a8:	99 1f       	adc	r25, r25
    44aa:	88 0f       	add	r24, r24
    44ac:	99 1f       	adc	r25, r25
    44ae:	82 0f       	add	r24, r18
    44b0:	93 1f       	adc	r25, r19
    44b2:	ac 01       	movw	r20, r24
    44b4:	41 52       	subi	r20, 0x21	; 33
    44b6:	59 4f       	sbci	r21, 0xF9	; 249
    44b8:	89 81       	ldd	r24, Y+1	; 0x01
    44ba:	9a 81       	ldd	r25, Y+2	; 0x02
    44bc:	9c 01       	movw	r18, r24
    44be:	2e 5f       	subi	r18, 0xFE	; 254
    44c0:	3f 4f       	sbci	r19, 0xFF	; 255
    44c2:	ca 01       	movw	r24, r20
    44c4:	b9 01       	movw	r22, r18
    44c6:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    44ca:	e9 81       	ldd	r30, Y+1	; 0x01
    44cc:	fa 81       	ldd	r31, Y+2	; 0x02
    44ce:	96 89       	ldd	r25, Z+22	; 0x16
    44d0:	e0 91 ce 06 	lds	r30, 0x06CE
    44d4:	f0 91 cf 06 	lds	r31, 0x06CF
    44d8:	86 89       	ldd	r24, Z+22	; 0x16
    44da:	98 17       	cp	r25, r24
    44dc:	10 f0       	brcs	.+4      	; 0x44e2 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    44de:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    44e2:	0f 90       	pop	r0
    44e4:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    44e6:	0f 90       	pop	r0
    44e8:	0f 90       	pop	r0
    44ea:	0f 90       	pop	r0
    44ec:	0f 90       	pop	r0
    44ee:	cf 91       	pop	r28
    44f0:	df 91       	pop	r29
    44f2:	08 95       	ret

000044f4 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    44f4:	df 93       	push	r29
    44f6:	cf 93       	push	r28
    44f8:	00 d0       	rcall	.+0      	; 0x44fa <xTaskResumeFromISR+0x6>
    44fa:	00 d0       	rcall	.+0      	; 0x44fc <xTaskResumeFromISR+0x8>
    44fc:	00 d0       	rcall	.+0      	; 0x44fe <xTaskResumeFromISR+0xa>
    44fe:	cd b7       	in	r28, 0x3d	; 61
    4500:	de b7       	in	r29, 0x3e	; 62
    4502:	9e 83       	std	Y+6, r25	; 0x06
    4504:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    4506:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    4508:	8d 81       	ldd	r24, Y+5	; 0x05
    450a:	9e 81       	ldd	r25, Y+6	; 0x06
    450c:	9b 83       	std	Y+3, r25	; 0x03
    450e:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4510:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    4512:	8a 81       	ldd	r24, Y+2	; 0x02
    4514:	9b 81       	ldd	r25, Y+3	; 0x03
    4516:	0e 94 e7 21 	call	0x43ce	; 0x43ce <prvTaskIsTaskSuspended>
    451a:	88 23       	and	r24, r24
    451c:	09 f4       	brne	.+2      	; 0x4520 <xTaskResumeFromISR+0x2c>
    451e:	46 c0       	rjmp	.+140    	; 0x45ac <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4520:	80 91 de 06 	lds	r24, 0x06DE
    4524:	88 23       	and	r24, r24
    4526:	c1 f5       	brne	.+112    	; 0x4598 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4528:	ea 81       	ldd	r30, Y+2	; 0x02
    452a:	fb 81       	ldd	r31, Y+3	; 0x03
    452c:	96 89       	ldd	r25, Z+22	; 0x16
    452e:	e0 91 ce 06 	lds	r30, 0x06CE
    4532:	f0 91 cf 06 	lds	r31, 0x06CF
    4536:	86 89       	ldd	r24, Z+22	; 0x16
    4538:	98 17       	cp	r25, r24
    453a:	10 f0       	brcs	.+4      	; 0x4540 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    453c:	81 e0       	ldi	r24, 0x01	; 1
    453e:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4540:	8a 81       	ldd	r24, Y+2	; 0x02
    4542:	9b 81       	ldd	r25, Y+3	; 0x03
    4544:	02 96       	adiw	r24, 0x02	; 2
    4546:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    454a:	ea 81       	ldd	r30, Y+2	; 0x02
    454c:	fb 81       	ldd	r31, Y+3	; 0x03
    454e:	96 89       	ldd	r25, Z+22	; 0x16
    4550:	80 91 d4 06 	lds	r24, 0x06D4
    4554:	89 17       	cp	r24, r25
    4556:	28 f4       	brcc	.+10     	; 0x4562 <xTaskResumeFromISR+0x6e>
    4558:	ea 81       	ldd	r30, Y+2	; 0x02
    455a:	fb 81       	ldd	r31, Y+3	; 0x03
    455c:	86 89       	ldd	r24, Z+22	; 0x16
    455e:	80 93 d4 06 	sts	0x06D4, r24
    4562:	ea 81       	ldd	r30, Y+2	; 0x02
    4564:	fb 81       	ldd	r31, Y+3	; 0x03
    4566:	86 89       	ldd	r24, Z+22	; 0x16
    4568:	28 2f       	mov	r18, r24
    456a:	30 e0       	ldi	r19, 0x00	; 0
    456c:	c9 01       	movw	r24, r18
    456e:	88 0f       	add	r24, r24
    4570:	99 1f       	adc	r25, r25
    4572:	88 0f       	add	r24, r24
    4574:	99 1f       	adc	r25, r25
    4576:	88 0f       	add	r24, r24
    4578:	99 1f       	adc	r25, r25
    457a:	82 0f       	add	r24, r18
    457c:	93 1f       	adc	r25, r19
    457e:	ac 01       	movw	r20, r24
    4580:	41 52       	subi	r20, 0x21	; 33
    4582:	59 4f       	sbci	r21, 0xF9	; 249
    4584:	8a 81       	ldd	r24, Y+2	; 0x02
    4586:	9b 81       	ldd	r25, Y+3	; 0x03
    4588:	9c 01       	movw	r18, r24
    458a:	2e 5f       	subi	r18, 0xFE	; 254
    458c:	3f 4f       	sbci	r19, 0xFF	; 255
    458e:	ca 01       	movw	r24, r20
    4590:	b9 01       	movw	r22, r18
    4592:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
    4596:	0a c0       	rjmp	.+20     	; 0x45ac <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4598:	8a 81       	ldd	r24, Y+2	; 0x02
    459a:	9b 81       	ldd	r25, Y+3	; 0x03
    459c:	9c 01       	movw	r18, r24
    459e:	24 5f       	subi	r18, 0xF4	; 244
    45a0:	3f 4f       	sbci	r19, 0xFF	; 255
    45a2:	84 e3       	ldi	r24, 0x34	; 52
    45a4:	97 e0       	ldi	r25, 0x07	; 7
    45a6:	b9 01       	movw	r22, r18
    45a8:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    45ac:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    45ae:	26 96       	adiw	r28, 0x06	; 6
    45b0:	0f b6       	in	r0, 0x3f	; 63
    45b2:	f8 94       	cli
    45b4:	de bf       	out	0x3e, r29	; 62
    45b6:	0f be       	out	0x3f, r0	; 63
    45b8:	cd bf       	out	0x3d, r28	; 61
    45ba:	cf 91       	pop	r28
    45bc:	df 91       	pop	r29
    45be:	08 95       	ret

000045c0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    45c0:	ef 92       	push	r14
    45c2:	ff 92       	push	r15
    45c4:	0f 93       	push	r16
    45c6:	df 93       	push	r29
    45c8:	cf 93       	push	r28
    45ca:	0f 92       	push	r0
    45cc:	cd b7       	in	r28, 0x3d	; 61
    45ce:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    45d0:	84 e3       	ldi	r24, 0x34	; 52
    45d2:	97 e2       	ldi	r25, 0x27	; 39
    45d4:	21 ee       	ldi	r18, 0xE1	; 225
    45d6:	30 e0       	ldi	r19, 0x00	; 0
    45d8:	ec ed       	ldi	r30, 0xDC	; 220
    45da:	f6 e0       	ldi	r31, 0x06	; 6
    45dc:	b9 01       	movw	r22, r18
    45de:	46 e9       	ldi	r20, 0x96	; 150
    45e0:	50 e0       	ldi	r21, 0x00	; 0
    45e2:	20 e0       	ldi	r18, 0x00	; 0
    45e4:	30 e0       	ldi	r19, 0x00	; 0
    45e6:	00 e0       	ldi	r16, 0x00	; 0
    45e8:	7f 01       	movw	r14, r30
    45ea:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <xTaskCreate>
    45ee:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    45f0:	89 81       	ldd	r24, Y+1	; 0x01
    45f2:	81 30       	cpi	r24, 0x01	; 1
    45f4:	81 f4       	brne	.+32     	; 0x4616 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    45f6:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    45f8:	8f ef       	ldi	r24, 0xFF	; 255
    45fa:	9f ef       	ldi	r25, 0xFF	; 255
    45fc:	90 93 db 06 	sts	0x06DB, r25
    4600:	80 93 da 06 	sts	0x06DA, r24
		xSchedulerRunning = pdTRUE;
    4604:	81 e0       	ldi	r24, 0x01	; 1
    4606:	80 93 d5 06 	sts	0x06D5, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    460a:	10 92 d3 06 	sts	0x06D3, r1
    460e:	10 92 d2 06 	sts	0x06D2, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4612:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    4616:	0f 90       	pop	r0
    4618:	cf 91       	pop	r28
    461a:	df 91       	pop	r29
    461c:	0f 91       	pop	r16
    461e:	ff 90       	pop	r15
    4620:	ef 90       	pop	r14
    4622:	08 95       	ret

00004624 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4624:	df 93       	push	r29
    4626:	cf 93       	push	r28
    4628:	cd b7       	in	r28, 0x3d	; 61
    462a:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    462c:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    462e:	10 92 d5 06 	sts	0x06D5, r1
	vPortEndScheduler();
    4632:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <vPortEndScheduler>
}
    4636:	cf 91       	pop	r28
    4638:	df 91       	pop	r29
    463a:	08 95       	ret

0000463c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    463c:	df 93       	push	r29
    463e:	cf 93       	push	r28
    4640:	cd b7       	in	r28, 0x3d	; 61
    4642:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    4644:	80 91 de 06 	lds	r24, 0x06DE
    4648:	8f 5f       	subi	r24, 0xFF	; 255
    464a:	80 93 de 06 	sts	0x06DE, r24
}
    464e:	cf 91       	pop	r28
    4650:	df 91       	pop	r29
    4652:	08 95       	ret

00004654 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    4654:	df 93       	push	r29
    4656:	cf 93       	push	r28
    4658:	00 d0       	rcall	.+0      	; 0x465a <xTaskResumeAll+0x6>
    465a:	00 d0       	rcall	.+0      	; 0x465c <xTaskResumeAll+0x8>
    465c:	cd b7       	in	r28, 0x3d	; 61
    465e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4660:	1c 82       	std	Y+4, r1	; 0x04
    4662:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    4664:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4666:	0f b6       	in	r0, 0x3f	; 63
    4668:	f8 94       	cli
    466a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    466c:	80 91 de 06 	lds	r24, 0x06DE
    4670:	81 50       	subi	r24, 0x01	; 1
    4672:	80 93 de 06 	sts	0x06DE, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4676:	80 91 de 06 	lds	r24, 0x06DE
    467a:	88 23       	and	r24, r24
    467c:	09 f0       	breq	.+2      	; 0x4680 <xTaskResumeAll+0x2c>
    467e:	73 c0       	rjmp	.+230    	; 0x4766 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4680:	80 91 d1 06 	lds	r24, 0x06D1
    4684:	88 23       	and	r24, r24
    4686:	09 f4       	brne	.+2      	; 0x468a <xTaskResumeAll+0x36>
    4688:	6e c0       	rjmp	.+220    	; 0x4766 <xTaskResumeAll+0x112>
    468a:	45 c0       	rjmp	.+138    	; 0x4716 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    468c:	e0 91 39 07 	lds	r30, 0x0739
    4690:	f0 91 3a 07 	lds	r31, 0x073A
    4694:	86 81       	ldd	r24, Z+6	; 0x06
    4696:	97 81       	ldd	r25, Z+7	; 0x07
    4698:	9c 83       	std	Y+4, r25	; 0x04
    469a:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    469c:	8b 81       	ldd	r24, Y+3	; 0x03
    469e:	9c 81       	ldd	r25, Y+4	; 0x04
    46a0:	0c 96       	adiw	r24, 0x0c	; 12
    46a2:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    46a6:	8b 81       	ldd	r24, Y+3	; 0x03
    46a8:	9c 81       	ldd	r25, Y+4	; 0x04
    46aa:	02 96       	adiw	r24, 0x02	; 2
    46ac:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    46b0:	eb 81       	ldd	r30, Y+3	; 0x03
    46b2:	fc 81       	ldd	r31, Y+4	; 0x04
    46b4:	96 89       	ldd	r25, Z+22	; 0x16
    46b6:	80 91 d4 06 	lds	r24, 0x06D4
    46ba:	89 17       	cp	r24, r25
    46bc:	28 f4       	brcc	.+10     	; 0x46c8 <xTaskResumeAll+0x74>
    46be:	eb 81       	ldd	r30, Y+3	; 0x03
    46c0:	fc 81       	ldd	r31, Y+4	; 0x04
    46c2:	86 89       	ldd	r24, Z+22	; 0x16
    46c4:	80 93 d4 06 	sts	0x06D4, r24
    46c8:	eb 81       	ldd	r30, Y+3	; 0x03
    46ca:	fc 81       	ldd	r31, Y+4	; 0x04
    46cc:	86 89       	ldd	r24, Z+22	; 0x16
    46ce:	28 2f       	mov	r18, r24
    46d0:	30 e0       	ldi	r19, 0x00	; 0
    46d2:	c9 01       	movw	r24, r18
    46d4:	88 0f       	add	r24, r24
    46d6:	99 1f       	adc	r25, r25
    46d8:	88 0f       	add	r24, r24
    46da:	99 1f       	adc	r25, r25
    46dc:	88 0f       	add	r24, r24
    46de:	99 1f       	adc	r25, r25
    46e0:	82 0f       	add	r24, r18
    46e2:	93 1f       	adc	r25, r19
    46e4:	ac 01       	movw	r20, r24
    46e6:	41 52       	subi	r20, 0x21	; 33
    46e8:	59 4f       	sbci	r21, 0xF9	; 249
    46ea:	8b 81       	ldd	r24, Y+3	; 0x03
    46ec:	9c 81       	ldd	r25, Y+4	; 0x04
    46ee:	9c 01       	movw	r18, r24
    46f0:	2e 5f       	subi	r18, 0xFE	; 254
    46f2:	3f 4f       	sbci	r19, 0xFF	; 255
    46f4:	ca 01       	movw	r24, r20
    46f6:	b9 01       	movw	r22, r18
    46f8:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    46fc:	eb 81       	ldd	r30, Y+3	; 0x03
    46fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4700:	96 89       	ldd	r25, Z+22	; 0x16
    4702:	e0 91 ce 06 	lds	r30, 0x06CE
    4706:	f0 91 cf 06 	lds	r31, 0x06CF
    470a:	86 89       	ldd	r24, Z+22	; 0x16
    470c:	98 17       	cp	r25, r24
    470e:	18 f0       	brcs	.+6      	; 0x4716 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    4710:	81 e0       	ldi	r24, 0x01	; 1
    4712:	80 93 d7 06 	sts	0x06D7, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    4716:	80 91 34 07 	lds	r24, 0x0734
    471a:	88 23       	and	r24, r24
    471c:	09 f0       	breq	.+2      	; 0x4720 <xTaskResumeAll+0xcc>
    471e:	b6 cf       	rjmp	.-148    	; 0x468c <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    4720:	8b 81       	ldd	r24, Y+3	; 0x03
    4722:	9c 81       	ldd	r25, Y+4	; 0x04
    4724:	00 97       	sbiw	r24, 0x00	; 0
    4726:	11 f0       	breq	.+4      	; 0x472c <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    4728:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    472c:	80 91 d6 06 	lds	r24, 0x06D6
    4730:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    4732:	89 81       	ldd	r24, Y+1	; 0x01
    4734:	88 23       	and	r24, r24
    4736:	79 f0       	breq	.+30     	; 0x4756 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    4738:	0e 94 1a 24 	call	0x4834	; 0x4834 <xTaskIncrementTick>
    473c:	88 23       	and	r24, r24
    473e:	19 f0       	breq	.+6      	; 0x4746 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    4740:	81 e0       	ldi	r24, 0x01	; 1
    4742:	80 93 d7 06 	sts	0x06D7, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    4746:	89 81       	ldd	r24, Y+1	; 0x01
    4748:	81 50       	subi	r24, 0x01	; 1
    474a:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    474c:	89 81       	ldd	r24, Y+1	; 0x01
    474e:	88 23       	and	r24, r24
    4750:	99 f7       	brne	.-26     	; 0x4738 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    4752:	10 92 d6 06 	sts	0x06D6, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    4756:	80 91 d7 06 	lds	r24, 0x06D7
    475a:	88 23       	and	r24, r24
    475c:	21 f0       	breq	.+8      	; 0x4766 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    475e:	81 e0       	ldi	r24, 0x01	; 1
    4760:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4762:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    4766:	0f 90       	pop	r0
    4768:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    476a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    476c:	0f 90       	pop	r0
    476e:	0f 90       	pop	r0
    4770:	0f 90       	pop	r0
    4772:	0f 90       	pop	r0
    4774:	cf 91       	pop	r28
    4776:	df 91       	pop	r29
    4778:	08 95       	ret

0000477a <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    477a:	df 93       	push	r29
    477c:	cf 93       	push	r28
    477e:	00 d0       	rcall	.+0      	; 0x4780 <xTaskGetTickCount+0x6>
    4780:	cd b7       	in	r28, 0x3d	; 61
    4782:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    4784:	0f b6       	in	r0, 0x3f	; 63
    4786:	f8 94       	cli
    4788:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    478a:	80 91 d2 06 	lds	r24, 0x06D2
    478e:	90 91 d3 06 	lds	r25, 0x06D3
    4792:	9a 83       	std	Y+2, r25	; 0x02
    4794:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    4796:	0f 90       	pop	r0
    4798:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    479a:	89 81       	ldd	r24, Y+1	; 0x01
    479c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    479e:	0f 90       	pop	r0
    47a0:	0f 90       	pop	r0
    47a2:	cf 91       	pop	r28
    47a4:	df 91       	pop	r29
    47a6:	08 95       	ret

000047a8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    47a8:	df 93       	push	r29
    47aa:	cf 93       	push	r28
    47ac:	00 d0       	rcall	.+0      	; 0x47ae <xTaskGetTickCountFromISR+0x6>
    47ae:	0f 92       	push	r0
    47b0:	cd b7       	in	r28, 0x3d	; 61
    47b2:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    47b4:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    47b6:	80 91 d2 06 	lds	r24, 0x06D2
    47ba:	90 91 d3 06 	lds	r25, 0x06D3
    47be:	9b 83       	std	Y+3, r25	; 0x03
    47c0:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    47c2:	8a 81       	ldd	r24, Y+2	; 0x02
    47c4:	9b 81       	ldd	r25, Y+3	; 0x03
}
    47c6:	0f 90       	pop	r0
    47c8:	0f 90       	pop	r0
    47ca:	0f 90       	pop	r0
    47cc:	cf 91       	pop	r28
    47ce:	df 91       	pop	r29
    47d0:	08 95       	ret

000047d2 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    47d2:	df 93       	push	r29
    47d4:	cf 93       	push	r28
    47d6:	cd b7       	in	r28, 0x3d	; 61
    47d8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    47da:	80 91 d1 06 	lds	r24, 0x06D1
}
    47de:	cf 91       	pop	r28
    47e0:	df 91       	pop	r29
    47e2:	08 95       	ret

000047e4 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    47e4:	df 93       	push	r29
    47e6:	cf 93       	push	r28
    47e8:	00 d0       	rcall	.+0      	; 0x47ea <pcTaskGetName+0x6>
    47ea:	00 d0       	rcall	.+0      	; 0x47ec <pcTaskGetName+0x8>
    47ec:	00 d0       	rcall	.+0      	; 0x47ee <pcTaskGetName+0xa>
    47ee:	cd b7       	in	r28, 0x3d	; 61
    47f0:	de b7       	in	r29, 0x3e	; 62
    47f2:	9c 83       	std	Y+4, r25	; 0x04
    47f4:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    47f6:	8b 81       	ldd	r24, Y+3	; 0x03
    47f8:	9c 81       	ldd	r25, Y+4	; 0x04
    47fa:	00 97       	sbiw	r24, 0x00	; 0
    47fc:	39 f4       	brne	.+14     	; 0x480c <pcTaskGetName+0x28>
    47fe:	80 91 ce 06 	lds	r24, 0x06CE
    4802:	90 91 cf 06 	lds	r25, 0x06CF
    4806:	9e 83       	std	Y+6, r25	; 0x06
    4808:	8d 83       	std	Y+5, r24	; 0x05
    480a:	04 c0       	rjmp	.+8      	; 0x4814 <pcTaskGetName+0x30>
    480c:	8b 81       	ldd	r24, Y+3	; 0x03
    480e:	9c 81       	ldd	r25, Y+4	; 0x04
    4810:	9e 83       	std	Y+6, r25	; 0x06
    4812:	8d 83       	std	Y+5, r24	; 0x05
    4814:	8d 81       	ldd	r24, Y+5	; 0x05
    4816:	9e 81       	ldd	r25, Y+6	; 0x06
    4818:	9a 83       	std	Y+2, r25	; 0x02
    481a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    481c:	89 81       	ldd	r24, Y+1	; 0x01
    481e:	9a 81       	ldd	r25, Y+2	; 0x02
    4820:	49 96       	adiw	r24, 0x19	; 25
}
    4822:	26 96       	adiw	r28, 0x06	; 6
    4824:	0f b6       	in	r0, 0x3f	; 63
    4826:	f8 94       	cli
    4828:	de bf       	out	0x3e, r29	; 62
    482a:	0f be       	out	0x3f, r0	; 63
    482c:	cd bf       	out	0x3d, r28	; 61
    482e:	cf 91       	pop	r28
    4830:	df 91       	pop	r29
    4832:	08 95       	ret

00004834 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4834:	df 93       	push	r29
    4836:	cf 93       	push	r28
    4838:	cd b7       	in	r28, 0x3d	; 61
    483a:	de b7       	in	r29, 0x3e	; 62
    483c:	29 97       	sbiw	r28, 0x09	; 9
    483e:	0f b6       	in	r0, 0x3f	; 63
    4840:	f8 94       	cli
    4842:	de bf       	out	0x3e, r29	; 62
    4844:	0f be       	out	0x3f, r0	; 63
    4846:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    4848:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    484a:	80 91 de 06 	lds	r24, 0x06DE
    484e:	88 23       	and	r24, r24
    4850:	09 f0       	breq	.+2      	; 0x4854 <xTaskIncrementTick+0x20>
    4852:	c0 c0       	rjmp	.+384    	; 0x49d4 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4854:	80 91 d2 06 	lds	r24, 0x06D2
    4858:	90 91 d3 06 	lds	r25, 0x06D3
    485c:	01 96       	adiw	r24, 0x01	; 1
    485e:	9c 83       	std	Y+4, r25	; 0x04
    4860:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4862:	8b 81       	ldd	r24, Y+3	; 0x03
    4864:	9c 81       	ldd	r25, Y+4	; 0x04
    4866:	90 93 d3 06 	sts	0x06D3, r25
    486a:	80 93 d2 06 	sts	0x06D2, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    486e:	8b 81       	ldd	r24, Y+3	; 0x03
    4870:	9c 81       	ldd	r25, Y+4	; 0x04
    4872:	00 97       	sbiw	r24, 0x00	; 0
    4874:	d9 f4       	brne	.+54     	; 0x48ac <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    4876:	80 91 30 07 	lds	r24, 0x0730
    487a:	90 91 31 07 	lds	r25, 0x0731
    487e:	9a 83       	std	Y+2, r25	; 0x02
    4880:	89 83       	std	Y+1, r24	; 0x01
    4882:	80 91 32 07 	lds	r24, 0x0732
    4886:	90 91 33 07 	lds	r25, 0x0733
    488a:	90 93 31 07 	sts	0x0731, r25
    488e:	80 93 30 07 	sts	0x0730, r24
    4892:	89 81       	ldd	r24, Y+1	; 0x01
    4894:	9a 81       	ldd	r25, Y+2	; 0x02
    4896:	90 93 33 07 	sts	0x0733, r25
    489a:	80 93 32 07 	sts	0x0732, r24
    489e:	80 91 d8 06 	lds	r24, 0x06D8
    48a2:	8f 5f       	subi	r24, 0xFF	; 255
    48a4:	80 93 d8 06 	sts	0x06D8, r24
    48a8:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    48ac:	20 91 da 06 	lds	r18, 0x06DA
    48b0:	30 91 db 06 	lds	r19, 0x06DB
    48b4:	8b 81       	ldd	r24, Y+3	; 0x03
    48b6:	9c 81       	ldd	r25, Y+4	; 0x04
    48b8:	82 17       	cp	r24, r18
    48ba:	93 07       	cpc	r25, r19
    48bc:	08 f4       	brcc	.+2      	; 0x48c0 <xTaskIncrementTick+0x8c>
    48be:	71 c0       	rjmp	.+226    	; 0x49a2 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    48c0:	e0 91 30 07 	lds	r30, 0x0730
    48c4:	f0 91 31 07 	lds	r31, 0x0731
    48c8:	80 81       	ld	r24, Z
    48ca:	88 23       	and	r24, r24
    48cc:	39 f4       	brne	.+14     	; 0x48dc <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    48ce:	8f ef       	ldi	r24, 0xFF	; 255
    48d0:	9f ef       	ldi	r25, 0xFF	; 255
    48d2:	90 93 db 06 	sts	0x06DB, r25
    48d6:	80 93 da 06 	sts	0x06DA, r24
    48da:	63 c0       	rjmp	.+198    	; 0x49a2 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    48dc:	e0 91 30 07 	lds	r30, 0x0730
    48e0:	f0 91 31 07 	lds	r31, 0x0731
    48e4:	05 80       	ldd	r0, Z+5	; 0x05
    48e6:	f6 81       	ldd	r31, Z+6	; 0x06
    48e8:	e0 2d       	mov	r30, r0
    48ea:	86 81       	ldd	r24, Z+6	; 0x06
    48ec:	97 81       	ldd	r25, Z+7	; 0x07
    48ee:	99 87       	std	Y+9, r25	; 0x09
    48f0:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    48f2:	e8 85       	ldd	r30, Y+8	; 0x08
    48f4:	f9 85       	ldd	r31, Y+9	; 0x09
    48f6:	82 81       	ldd	r24, Z+2	; 0x02
    48f8:	93 81       	ldd	r25, Z+3	; 0x03
    48fa:	9f 83       	std	Y+7, r25	; 0x07
    48fc:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    48fe:	2b 81       	ldd	r18, Y+3	; 0x03
    4900:	3c 81       	ldd	r19, Y+4	; 0x04
    4902:	8e 81       	ldd	r24, Y+6	; 0x06
    4904:	9f 81       	ldd	r25, Y+7	; 0x07
    4906:	28 17       	cp	r18, r24
    4908:	39 07       	cpc	r19, r25
    490a:	38 f4       	brcc	.+14     	; 0x491a <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    490c:	8e 81       	ldd	r24, Y+6	; 0x06
    490e:	9f 81       	ldd	r25, Y+7	; 0x07
    4910:	90 93 db 06 	sts	0x06DB, r25
    4914:	80 93 da 06 	sts	0x06DA, r24
    4918:	44 c0       	rjmp	.+136    	; 0x49a2 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    491a:	88 85       	ldd	r24, Y+8	; 0x08
    491c:	99 85       	ldd	r25, Y+9	; 0x09
    491e:	02 96       	adiw	r24, 0x02	; 2
    4920:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4924:	e8 85       	ldd	r30, Y+8	; 0x08
    4926:	f9 85       	ldd	r31, Y+9	; 0x09
    4928:	84 89       	ldd	r24, Z+20	; 0x14
    492a:	95 89       	ldd	r25, Z+21	; 0x15
    492c:	00 97       	sbiw	r24, 0x00	; 0
    492e:	29 f0       	breq	.+10     	; 0x493a <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4930:	88 85       	ldd	r24, Y+8	; 0x08
    4932:	99 85       	ldd	r25, Y+9	; 0x09
    4934:	0c 96       	adiw	r24, 0x0c	; 12
    4936:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    493a:	e8 85       	ldd	r30, Y+8	; 0x08
    493c:	f9 85       	ldd	r31, Y+9	; 0x09
    493e:	96 89       	ldd	r25, Z+22	; 0x16
    4940:	80 91 d4 06 	lds	r24, 0x06D4
    4944:	89 17       	cp	r24, r25
    4946:	28 f4       	brcc	.+10     	; 0x4952 <xTaskIncrementTick+0x11e>
    4948:	e8 85       	ldd	r30, Y+8	; 0x08
    494a:	f9 85       	ldd	r31, Y+9	; 0x09
    494c:	86 89       	ldd	r24, Z+22	; 0x16
    494e:	80 93 d4 06 	sts	0x06D4, r24
    4952:	e8 85       	ldd	r30, Y+8	; 0x08
    4954:	f9 85       	ldd	r31, Y+9	; 0x09
    4956:	86 89       	ldd	r24, Z+22	; 0x16
    4958:	28 2f       	mov	r18, r24
    495a:	30 e0       	ldi	r19, 0x00	; 0
    495c:	c9 01       	movw	r24, r18
    495e:	88 0f       	add	r24, r24
    4960:	99 1f       	adc	r25, r25
    4962:	88 0f       	add	r24, r24
    4964:	99 1f       	adc	r25, r25
    4966:	88 0f       	add	r24, r24
    4968:	99 1f       	adc	r25, r25
    496a:	82 0f       	add	r24, r18
    496c:	93 1f       	adc	r25, r19
    496e:	ac 01       	movw	r20, r24
    4970:	41 52       	subi	r20, 0x21	; 33
    4972:	59 4f       	sbci	r21, 0xF9	; 249
    4974:	88 85       	ldd	r24, Y+8	; 0x08
    4976:	99 85       	ldd	r25, Y+9	; 0x09
    4978:	9c 01       	movw	r18, r24
    497a:	2e 5f       	subi	r18, 0xFE	; 254
    497c:	3f 4f       	sbci	r19, 0xFF	; 255
    497e:	ca 01       	movw	r24, r20
    4980:	b9 01       	movw	r22, r18
    4982:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4986:	e8 85       	ldd	r30, Y+8	; 0x08
    4988:	f9 85       	ldd	r31, Y+9	; 0x09
    498a:	96 89       	ldd	r25, Z+22	; 0x16
    498c:	e0 91 ce 06 	lds	r30, 0x06CE
    4990:	f0 91 cf 06 	lds	r31, 0x06CF
    4994:	86 89       	ldd	r24, Z+22	; 0x16
    4996:	98 17       	cp	r25, r24
    4998:	08 f4       	brcc	.+2      	; 0x499c <xTaskIncrementTick+0x168>
    499a:	92 cf       	rjmp	.-220    	; 0x48c0 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    499c:	81 e0       	ldi	r24, 0x01	; 1
    499e:	8d 83       	std	Y+5, r24	; 0x05
    49a0:	8f cf       	rjmp	.-226    	; 0x48c0 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    49a2:	e0 91 ce 06 	lds	r30, 0x06CE
    49a6:	f0 91 cf 06 	lds	r31, 0x06CF
    49aa:	86 89       	ldd	r24, Z+22	; 0x16
    49ac:	28 2f       	mov	r18, r24
    49ae:	30 e0       	ldi	r19, 0x00	; 0
    49b0:	c9 01       	movw	r24, r18
    49b2:	88 0f       	add	r24, r24
    49b4:	99 1f       	adc	r25, r25
    49b6:	88 0f       	add	r24, r24
    49b8:	99 1f       	adc	r25, r25
    49ba:	88 0f       	add	r24, r24
    49bc:	99 1f       	adc	r25, r25
    49be:	82 0f       	add	r24, r18
    49c0:	93 1f       	adc	r25, r19
    49c2:	fc 01       	movw	r30, r24
    49c4:	e1 52       	subi	r30, 0x21	; 33
    49c6:	f9 4f       	sbci	r31, 0xF9	; 249
    49c8:	80 81       	ld	r24, Z
    49ca:	82 30       	cpi	r24, 0x02	; 2
    49cc:	40 f0       	brcs	.+16     	; 0x49de <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    49ce:	81 e0       	ldi	r24, 0x01	; 1
    49d0:	8d 83       	std	Y+5, r24	; 0x05
    49d2:	05 c0       	rjmp	.+10     	; 0x49de <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    49d4:	80 91 d6 06 	lds	r24, 0x06D6
    49d8:	8f 5f       	subi	r24, 0xFF	; 255
    49da:	80 93 d6 06 	sts	0x06D6, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    49de:	80 91 d7 06 	lds	r24, 0x06D7
    49e2:	88 23       	and	r24, r24
    49e4:	11 f0       	breq	.+4      	; 0x49ea <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    49e6:	81 e0       	ldi	r24, 0x01	; 1
    49e8:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    49ea:	8d 81       	ldd	r24, Y+5	; 0x05
}
    49ec:	29 96       	adiw	r28, 0x09	; 9
    49ee:	0f b6       	in	r0, 0x3f	; 63
    49f0:	f8 94       	cli
    49f2:	de bf       	out	0x3e, r29	; 62
    49f4:	0f be       	out	0x3f, r0	; 63
    49f6:	cd bf       	out	0x3d, r28	; 61
    49f8:	cf 91       	pop	r28
    49fa:	df 91       	pop	r29
    49fc:	08 95       	ret

000049fe <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    49fe:	df 93       	push	r29
    4a00:	cf 93       	push	r28
    4a02:	00 d0       	rcall	.+0      	; 0x4a04 <vTaskSwitchContext+0x6>
    4a04:	0f 92       	push	r0
    4a06:	cd b7       	in	r28, 0x3d	; 61
    4a08:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4a0a:	80 91 de 06 	lds	r24, 0x06DE
    4a0e:	88 23       	and	r24, r24
    4a10:	21 f0       	breq	.+8      	; 0x4a1a <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    4a12:	81 e0       	ldi	r24, 0x01	; 1
    4a14:	80 93 d7 06 	sts	0x06D7, r24
    4a18:	59 c0       	rjmp	.+178    	; 0x4acc <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    4a1a:	10 92 d7 06 	sts	0x06D7, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4a1e:	80 91 d4 06 	lds	r24, 0x06D4
    4a22:	8b 83       	std	Y+3, r24	; 0x03
    4a24:	03 c0       	rjmp	.+6      	; 0x4a2c <vTaskSwitchContext+0x2e>
    4a26:	8b 81       	ldd	r24, Y+3	; 0x03
    4a28:	81 50       	subi	r24, 0x01	; 1
    4a2a:	8b 83       	std	Y+3, r24	; 0x03
    4a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a2e:	28 2f       	mov	r18, r24
    4a30:	30 e0       	ldi	r19, 0x00	; 0
    4a32:	c9 01       	movw	r24, r18
    4a34:	88 0f       	add	r24, r24
    4a36:	99 1f       	adc	r25, r25
    4a38:	88 0f       	add	r24, r24
    4a3a:	99 1f       	adc	r25, r25
    4a3c:	88 0f       	add	r24, r24
    4a3e:	99 1f       	adc	r25, r25
    4a40:	82 0f       	add	r24, r18
    4a42:	93 1f       	adc	r25, r19
    4a44:	fc 01       	movw	r30, r24
    4a46:	e1 52       	subi	r30, 0x21	; 33
    4a48:	f9 4f       	sbci	r31, 0xF9	; 249
    4a4a:	80 81       	ld	r24, Z
    4a4c:	88 23       	and	r24, r24
    4a4e:	59 f3       	breq	.-42     	; 0x4a26 <vTaskSwitchContext+0x28>
    4a50:	8b 81       	ldd	r24, Y+3	; 0x03
    4a52:	28 2f       	mov	r18, r24
    4a54:	30 e0       	ldi	r19, 0x00	; 0
    4a56:	c9 01       	movw	r24, r18
    4a58:	88 0f       	add	r24, r24
    4a5a:	99 1f       	adc	r25, r25
    4a5c:	88 0f       	add	r24, r24
    4a5e:	99 1f       	adc	r25, r25
    4a60:	88 0f       	add	r24, r24
    4a62:	99 1f       	adc	r25, r25
    4a64:	82 0f       	add	r24, r18
    4a66:	93 1f       	adc	r25, r19
    4a68:	81 52       	subi	r24, 0x21	; 33
    4a6a:	99 4f       	sbci	r25, 0xF9	; 249
    4a6c:	9a 83       	std	Y+2, r25	; 0x02
    4a6e:	89 83       	std	Y+1, r24	; 0x01
    4a70:	e9 81       	ldd	r30, Y+1	; 0x01
    4a72:	fa 81       	ldd	r31, Y+2	; 0x02
    4a74:	01 80       	ldd	r0, Z+1	; 0x01
    4a76:	f2 81       	ldd	r31, Z+2	; 0x02
    4a78:	e0 2d       	mov	r30, r0
    4a7a:	82 81       	ldd	r24, Z+2	; 0x02
    4a7c:	93 81       	ldd	r25, Z+3	; 0x03
    4a7e:	e9 81       	ldd	r30, Y+1	; 0x01
    4a80:	fa 81       	ldd	r31, Y+2	; 0x02
    4a82:	92 83       	std	Z+2, r25	; 0x02
    4a84:	81 83       	std	Z+1, r24	; 0x01
    4a86:	e9 81       	ldd	r30, Y+1	; 0x01
    4a88:	fa 81       	ldd	r31, Y+2	; 0x02
    4a8a:	21 81       	ldd	r18, Z+1	; 0x01
    4a8c:	32 81       	ldd	r19, Z+2	; 0x02
    4a8e:	89 81       	ldd	r24, Y+1	; 0x01
    4a90:	9a 81       	ldd	r25, Y+2	; 0x02
    4a92:	03 96       	adiw	r24, 0x03	; 3
    4a94:	28 17       	cp	r18, r24
    4a96:	39 07       	cpc	r19, r25
    4a98:	59 f4       	brne	.+22     	; 0x4ab0 <vTaskSwitchContext+0xb2>
    4a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a9e:	01 80       	ldd	r0, Z+1	; 0x01
    4aa0:	f2 81       	ldd	r31, Z+2	; 0x02
    4aa2:	e0 2d       	mov	r30, r0
    4aa4:	82 81       	ldd	r24, Z+2	; 0x02
    4aa6:	93 81       	ldd	r25, Z+3	; 0x03
    4aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    4aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    4aac:	92 83       	std	Z+2, r25	; 0x02
    4aae:	81 83       	std	Z+1, r24	; 0x01
    4ab0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ab2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ab4:	01 80       	ldd	r0, Z+1	; 0x01
    4ab6:	f2 81       	ldd	r31, Z+2	; 0x02
    4ab8:	e0 2d       	mov	r30, r0
    4aba:	86 81       	ldd	r24, Z+6	; 0x06
    4abc:	97 81       	ldd	r25, Z+7	; 0x07
    4abe:	90 93 cf 06 	sts	0x06CF, r25
    4ac2:	80 93 ce 06 	sts	0x06CE, r24
    4ac6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ac8:	80 93 d4 06 	sts	0x06D4, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4acc:	0f 90       	pop	r0
    4ace:	0f 90       	pop	r0
    4ad0:	0f 90       	pop	r0
    4ad2:	cf 91       	pop	r28
    4ad4:	df 91       	pop	r29
    4ad6:	08 95       	ret

00004ad8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    4ad8:	df 93       	push	r29
    4ada:	cf 93       	push	r28
    4adc:	00 d0       	rcall	.+0      	; 0x4ade <vTaskPlaceOnEventList+0x6>
    4ade:	00 d0       	rcall	.+0      	; 0x4ae0 <vTaskPlaceOnEventList+0x8>
    4ae0:	cd b7       	in	r28, 0x3d	; 61
    4ae2:	de b7       	in	r29, 0x3e	; 62
    4ae4:	9a 83       	std	Y+2, r25	; 0x02
    4ae6:	89 83       	std	Y+1, r24	; 0x01
    4ae8:	7c 83       	std	Y+4, r23	; 0x04
    4aea:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4aec:	80 91 ce 06 	lds	r24, 0x06CE
    4af0:	90 91 cf 06 	lds	r25, 0x06CF
    4af4:	9c 01       	movw	r18, r24
    4af6:	24 5f       	subi	r18, 0xF4	; 244
    4af8:	3f 4f       	sbci	r19, 0xFF	; 255
    4afa:	89 81       	ldd	r24, Y+1	; 0x01
    4afc:	9a 81       	ldd	r25, Y+2	; 0x02
    4afe:	b9 01       	movw	r22, r18
    4b00:	0e 94 23 0c 	call	0x1846	; 0x1846 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4b04:	8b 81       	ldd	r24, Y+3	; 0x03
    4b06:	9c 81       	ldd	r25, Y+4	; 0x04
    4b08:	61 e0       	ldi	r22, 0x01	; 1
    4b0a:	0e 94 8d 2d 	call	0x5b1a	; 0x5b1a <prvAddCurrentTaskToDelayedList>
}
    4b0e:	0f 90       	pop	r0
    4b10:	0f 90       	pop	r0
    4b12:	0f 90       	pop	r0
    4b14:	0f 90       	pop	r0
    4b16:	cf 91       	pop	r28
    4b18:	df 91       	pop	r29
    4b1a:	08 95       	ret

00004b1c <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    4b1c:	df 93       	push	r29
    4b1e:	cf 93       	push	r28
    4b20:	00 d0       	rcall	.+0      	; 0x4b22 <vTaskPlaceOnUnorderedEventList+0x6>
    4b22:	00 d0       	rcall	.+0      	; 0x4b24 <vTaskPlaceOnUnorderedEventList+0x8>
    4b24:	00 d0       	rcall	.+0      	; 0x4b26 <vTaskPlaceOnUnorderedEventList+0xa>
    4b26:	cd b7       	in	r28, 0x3d	; 61
    4b28:	de b7       	in	r29, 0x3e	; 62
    4b2a:	9a 83       	std	Y+2, r25	; 0x02
    4b2c:	89 83       	std	Y+1, r24	; 0x01
    4b2e:	7c 83       	std	Y+4, r23	; 0x04
    4b30:	6b 83       	std	Y+3, r22	; 0x03
    4b32:	5e 83       	std	Y+6, r21	; 0x06
    4b34:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4b36:	e0 91 ce 06 	lds	r30, 0x06CE
    4b3a:	f0 91 cf 06 	lds	r31, 0x06CF
    4b3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b40:	9c 81       	ldd	r25, Y+4	; 0x04
    4b42:	90 68       	ori	r25, 0x80	; 128
    4b44:	95 87       	std	Z+13, r25	; 0x0d
    4b46:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4b48:	80 91 ce 06 	lds	r24, 0x06CE
    4b4c:	90 91 cf 06 	lds	r25, 0x06CF
    4b50:	9c 01       	movw	r18, r24
    4b52:	24 5f       	subi	r18, 0xF4	; 244
    4b54:	3f 4f       	sbci	r19, 0xFF	; 255
    4b56:	89 81       	ldd	r24, Y+1	; 0x01
    4b58:	9a 81       	ldd	r25, Y+2	; 0x02
    4b5a:	b9 01       	movw	r22, r18
    4b5c:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4b60:	8d 81       	ldd	r24, Y+5	; 0x05
    4b62:	9e 81       	ldd	r25, Y+6	; 0x06
    4b64:	61 e0       	ldi	r22, 0x01	; 1
    4b66:	0e 94 8d 2d 	call	0x5b1a	; 0x5b1a <prvAddCurrentTaskToDelayedList>
}
    4b6a:	26 96       	adiw	r28, 0x06	; 6
    4b6c:	0f b6       	in	r0, 0x3f	; 63
    4b6e:	f8 94       	cli
    4b70:	de bf       	out	0x3e, r29	; 62
    4b72:	0f be       	out	0x3f, r0	; 63
    4b74:	cd bf       	out	0x3d, r28	; 61
    4b76:	cf 91       	pop	r28
    4b78:	df 91       	pop	r29
    4b7a:	08 95       	ret

00004b7c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4b7c:	df 93       	push	r29
    4b7e:	cf 93       	push	r28
    4b80:	00 d0       	rcall	.+0      	; 0x4b82 <xTaskRemoveFromEventList+0x6>
    4b82:	00 d0       	rcall	.+0      	; 0x4b84 <xTaskRemoveFromEventList+0x8>
    4b84:	0f 92       	push	r0
    4b86:	cd b7       	in	r28, 0x3d	; 61
    4b88:	de b7       	in	r29, 0x3e	; 62
    4b8a:	9d 83       	std	Y+5, r25	; 0x05
    4b8c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b8e:	ec 81       	ldd	r30, Y+4	; 0x04
    4b90:	fd 81       	ldd	r31, Y+5	; 0x05
    4b92:	05 80       	ldd	r0, Z+5	; 0x05
    4b94:	f6 81       	ldd	r31, Z+6	; 0x06
    4b96:	e0 2d       	mov	r30, r0
    4b98:	86 81       	ldd	r24, Z+6	; 0x06
    4b9a:	97 81       	ldd	r25, Z+7	; 0x07
    4b9c:	9b 83       	std	Y+3, r25	; 0x03
    4b9e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4ba0:	8a 81       	ldd	r24, Y+2	; 0x02
    4ba2:	9b 81       	ldd	r25, Y+3	; 0x03
    4ba4:	0c 96       	adiw	r24, 0x0c	; 12
    4ba6:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4baa:	80 91 de 06 	lds	r24, 0x06DE
    4bae:	88 23       	and	r24, r24
    4bb0:	61 f5       	brne	.+88     	; 0x4c0a <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4bb2:	8a 81       	ldd	r24, Y+2	; 0x02
    4bb4:	9b 81       	ldd	r25, Y+3	; 0x03
    4bb6:	02 96       	adiw	r24, 0x02	; 2
    4bb8:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4bbc:	ea 81       	ldd	r30, Y+2	; 0x02
    4bbe:	fb 81       	ldd	r31, Y+3	; 0x03
    4bc0:	96 89       	ldd	r25, Z+22	; 0x16
    4bc2:	80 91 d4 06 	lds	r24, 0x06D4
    4bc6:	89 17       	cp	r24, r25
    4bc8:	28 f4       	brcc	.+10     	; 0x4bd4 <xTaskRemoveFromEventList+0x58>
    4bca:	ea 81       	ldd	r30, Y+2	; 0x02
    4bcc:	fb 81       	ldd	r31, Y+3	; 0x03
    4bce:	86 89       	ldd	r24, Z+22	; 0x16
    4bd0:	80 93 d4 06 	sts	0x06D4, r24
    4bd4:	ea 81       	ldd	r30, Y+2	; 0x02
    4bd6:	fb 81       	ldd	r31, Y+3	; 0x03
    4bd8:	86 89       	ldd	r24, Z+22	; 0x16
    4bda:	28 2f       	mov	r18, r24
    4bdc:	30 e0       	ldi	r19, 0x00	; 0
    4bde:	c9 01       	movw	r24, r18
    4be0:	88 0f       	add	r24, r24
    4be2:	99 1f       	adc	r25, r25
    4be4:	88 0f       	add	r24, r24
    4be6:	99 1f       	adc	r25, r25
    4be8:	88 0f       	add	r24, r24
    4bea:	99 1f       	adc	r25, r25
    4bec:	82 0f       	add	r24, r18
    4bee:	93 1f       	adc	r25, r19
    4bf0:	ac 01       	movw	r20, r24
    4bf2:	41 52       	subi	r20, 0x21	; 33
    4bf4:	59 4f       	sbci	r21, 0xF9	; 249
    4bf6:	8a 81       	ldd	r24, Y+2	; 0x02
    4bf8:	9b 81       	ldd	r25, Y+3	; 0x03
    4bfa:	9c 01       	movw	r18, r24
    4bfc:	2e 5f       	subi	r18, 0xFE	; 254
    4bfe:	3f 4f       	sbci	r19, 0xFF	; 255
    4c00:	ca 01       	movw	r24, r20
    4c02:	b9 01       	movw	r22, r18
    4c04:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
    4c08:	0a c0       	rjmp	.+20     	; 0x4c1e <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4c0a:	8a 81       	ldd	r24, Y+2	; 0x02
    4c0c:	9b 81       	ldd	r25, Y+3	; 0x03
    4c0e:	9c 01       	movw	r18, r24
    4c10:	24 5f       	subi	r18, 0xF4	; 244
    4c12:	3f 4f       	sbci	r19, 0xFF	; 255
    4c14:	84 e3       	ldi	r24, 0x34	; 52
    4c16:	97 e0       	ldi	r25, 0x07	; 7
    4c18:	b9 01       	movw	r22, r18
    4c1a:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4c1e:	ea 81       	ldd	r30, Y+2	; 0x02
    4c20:	fb 81       	ldd	r31, Y+3	; 0x03
    4c22:	96 89       	ldd	r25, Z+22	; 0x16
    4c24:	e0 91 ce 06 	lds	r30, 0x06CE
    4c28:	f0 91 cf 06 	lds	r31, 0x06CF
    4c2c:	86 89       	ldd	r24, Z+22	; 0x16
    4c2e:	89 17       	cp	r24, r25
    4c30:	30 f4       	brcc	.+12     	; 0x4c3e <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    4c32:	81 e0       	ldi	r24, 0x01	; 1
    4c34:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    4c36:	81 e0       	ldi	r24, 0x01	; 1
    4c38:	80 93 d7 06 	sts	0x06D7, r24
    4c3c:	01 c0       	rjmp	.+2      	; 0x4c40 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    4c3e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4c40:	89 81       	ldd	r24, Y+1	; 0x01
}
    4c42:	0f 90       	pop	r0
    4c44:	0f 90       	pop	r0
    4c46:	0f 90       	pop	r0
    4c48:	0f 90       	pop	r0
    4c4a:	0f 90       	pop	r0
    4c4c:	cf 91       	pop	r28
    4c4e:	df 91       	pop	r29
    4c50:	08 95       	ret

00004c52 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4c52:	df 93       	push	r29
    4c54:	cf 93       	push	r28
    4c56:	00 d0       	rcall	.+0      	; 0x4c58 <vTaskRemoveFromUnorderedEventList+0x6>
    4c58:	00 d0       	rcall	.+0      	; 0x4c5a <vTaskRemoveFromUnorderedEventList+0x8>
    4c5a:	00 d0       	rcall	.+0      	; 0x4c5c <vTaskRemoveFromUnorderedEventList+0xa>
    4c5c:	cd b7       	in	r28, 0x3d	; 61
    4c5e:	de b7       	in	r29, 0x3e	; 62
    4c60:	9c 83       	std	Y+4, r25	; 0x04
    4c62:	8b 83       	std	Y+3, r24	; 0x03
    4c64:	7e 83       	std	Y+6, r23	; 0x06
    4c66:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4c68:	8d 81       	ldd	r24, Y+5	; 0x05
    4c6a:	9e 81       	ldd	r25, Y+6	; 0x06
    4c6c:	90 68       	ori	r25, 0x80	; 128
    4c6e:	eb 81       	ldd	r30, Y+3	; 0x03
    4c70:	fc 81       	ldd	r31, Y+4	; 0x04
    4c72:	91 83       	std	Z+1, r25	; 0x01
    4c74:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4c76:	eb 81       	ldd	r30, Y+3	; 0x03
    4c78:	fc 81       	ldd	r31, Y+4	; 0x04
    4c7a:	86 81       	ldd	r24, Z+6	; 0x06
    4c7c:	97 81       	ldd	r25, Z+7	; 0x07
    4c7e:	9a 83       	std	Y+2, r25	; 0x02
    4c80:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4c82:	8b 81       	ldd	r24, Y+3	; 0x03
    4c84:	9c 81       	ldd	r25, Y+4	; 0x04
    4c86:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4c8a:	89 81       	ldd	r24, Y+1	; 0x01
    4c8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c8e:	02 96       	adiw	r24, 0x02	; 2
    4c90:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    4c94:	e9 81       	ldd	r30, Y+1	; 0x01
    4c96:	fa 81       	ldd	r31, Y+2	; 0x02
    4c98:	96 89       	ldd	r25, Z+22	; 0x16
    4c9a:	80 91 d4 06 	lds	r24, 0x06D4
    4c9e:	89 17       	cp	r24, r25
    4ca0:	28 f4       	brcc	.+10     	; 0x4cac <vTaskRemoveFromUnorderedEventList+0x5a>
    4ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    4ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    4ca6:	86 89       	ldd	r24, Z+22	; 0x16
    4ca8:	80 93 d4 06 	sts	0x06D4, r24
    4cac:	e9 81       	ldd	r30, Y+1	; 0x01
    4cae:	fa 81       	ldd	r31, Y+2	; 0x02
    4cb0:	86 89       	ldd	r24, Z+22	; 0x16
    4cb2:	28 2f       	mov	r18, r24
    4cb4:	30 e0       	ldi	r19, 0x00	; 0
    4cb6:	c9 01       	movw	r24, r18
    4cb8:	88 0f       	add	r24, r24
    4cba:	99 1f       	adc	r25, r25
    4cbc:	88 0f       	add	r24, r24
    4cbe:	99 1f       	adc	r25, r25
    4cc0:	88 0f       	add	r24, r24
    4cc2:	99 1f       	adc	r25, r25
    4cc4:	82 0f       	add	r24, r18
    4cc6:	93 1f       	adc	r25, r19
    4cc8:	ac 01       	movw	r20, r24
    4cca:	41 52       	subi	r20, 0x21	; 33
    4ccc:	59 4f       	sbci	r21, 0xF9	; 249
    4cce:	89 81       	ldd	r24, Y+1	; 0x01
    4cd0:	9a 81       	ldd	r25, Y+2	; 0x02
    4cd2:	9c 01       	movw	r18, r24
    4cd4:	2e 5f       	subi	r18, 0xFE	; 254
    4cd6:	3f 4f       	sbci	r19, 0xFF	; 255
    4cd8:	ca 01       	movw	r24, r20
    4cda:	b9 01       	movw	r22, r18
    4cdc:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4ce0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ce2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ce4:	96 89       	ldd	r25, Z+22	; 0x16
    4ce6:	e0 91 ce 06 	lds	r30, 0x06CE
    4cea:	f0 91 cf 06 	lds	r31, 0x06CF
    4cee:	86 89       	ldd	r24, Z+22	; 0x16
    4cf0:	89 17       	cp	r24, r25
    4cf2:	18 f4       	brcc	.+6      	; 0x4cfa <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    4cf4:	81 e0       	ldi	r24, 0x01	; 1
    4cf6:	80 93 d7 06 	sts	0x06D7, r24
	}
}
    4cfa:	26 96       	adiw	r28, 0x06	; 6
    4cfc:	0f b6       	in	r0, 0x3f	; 63
    4cfe:	f8 94       	cli
    4d00:	de bf       	out	0x3e, r29	; 62
    4d02:	0f be       	out	0x3f, r0	; 63
    4d04:	cd bf       	out	0x3d, r28	; 61
    4d06:	cf 91       	pop	r28
    4d08:	df 91       	pop	r29
    4d0a:	08 95       	ret

00004d0c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4d0c:	df 93       	push	r29
    4d0e:	cf 93       	push	r28
    4d10:	00 d0       	rcall	.+0      	; 0x4d12 <vTaskSetTimeOutState+0x6>
    4d12:	cd b7       	in	r28, 0x3d	; 61
    4d14:	de b7       	in	r29, 0x3e	; 62
    4d16:	9a 83       	std	Y+2, r25	; 0x02
    4d18:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    4d1a:	0f b6       	in	r0, 0x3f	; 63
    4d1c:	f8 94       	cli
    4d1e:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    4d20:	80 91 d8 06 	lds	r24, 0x06D8
    4d24:	e9 81       	ldd	r30, Y+1	; 0x01
    4d26:	fa 81       	ldd	r31, Y+2	; 0x02
    4d28:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    4d2a:	80 91 d2 06 	lds	r24, 0x06D2
    4d2e:	90 91 d3 06 	lds	r25, 0x06D3
    4d32:	e9 81       	ldd	r30, Y+1	; 0x01
    4d34:	fa 81       	ldd	r31, Y+2	; 0x02
    4d36:	92 83       	std	Z+2, r25	; 0x02
    4d38:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4d3a:	0f 90       	pop	r0
    4d3c:	0f be       	out	0x3f, r0	; 63
}
    4d3e:	0f 90       	pop	r0
    4d40:	0f 90       	pop	r0
    4d42:	cf 91       	pop	r28
    4d44:	df 91       	pop	r29
    4d46:	08 95       	ret

00004d48 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4d48:	df 93       	push	r29
    4d4a:	cf 93       	push	r28
    4d4c:	00 d0       	rcall	.+0      	; 0x4d4e <vTaskInternalSetTimeOutState+0x6>
    4d4e:	cd b7       	in	r28, 0x3d	; 61
    4d50:	de b7       	in	r29, 0x3e	; 62
    4d52:	9a 83       	std	Y+2, r25	; 0x02
    4d54:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4d56:	80 91 d8 06 	lds	r24, 0x06D8
    4d5a:	e9 81       	ldd	r30, Y+1	; 0x01
    4d5c:	fa 81       	ldd	r31, Y+2	; 0x02
    4d5e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4d60:	80 91 d2 06 	lds	r24, 0x06D2
    4d64:	90 91 d3 06 	lds	r25, 0x06D3
    4d68:	e9 81       	ldd	r30, Y+1	; 0x01
    4d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    4d6c:	92 83       	std	Z+2, r25	; 0x02
    4d6e:	81 83       	std	Z+1, r24	; 0x01
}
    4d70:	0f 90       	pop	r0
    4d72:	0f 90       	pop	r0
    4d74:	cf 91       	pop	r28
    4d76:	df 91       	pop	r29
    4d78:	08 95       	ret

00004d7a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4d7a:	df 93       	push	r29
    4d7c:	cf 93       	push	r28
    4d7e:	cd b7       	in	r28, 0x3d	; 61
    4d80:	de b7       	in	r29, 0x3e	; 62
    4d82:	29 97       	sbiw	r28, 0x09	; 9
    4d84:	0f b6       	in	r0, 0x3f	; 63
    4d86:	f8 94       	cli
    4d88:	de bf       	out	0x3e, r29	; 62
    4d8a:	0f be       	out	0x3f, r0	; 63
    4d8c:	cd bf       	out	0x3d, r28	; 61
    4d8e:	9f 83       	std	Y+7, r25	; 0x07
    4d90:	8e 83       	std	Y+6, r24	; 0x06
    4d92:	79 87       	std	Y+9, r23	; 0x09
    4d94:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4d96:	0f b6       	in	r0, 0x3f	; 63
    4d98:	f8 94       	cli
    4d9a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4d9c:	80 91 d2 06 	lds	r24, 0x06D2
    4da0:	90 91 d3 06 	lds	r25, 0x06D3
    4da4:	9c 83       	std	Y+4, r25	; 0x04
    4da6:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4da8:	ee 81       	ldd	r30, Y+6	; 0x06
    4daa:	ff 81       	ldd	r31, Y+7	; 0x07
    4dac:	21 81       	ldd	r18, Z+1	; 0x01
    4dae:	32 81       	ldd	r19, Z+2	; 0x02
    4db0:	8b 81       	ldd	r24, Y+3	; 0x03
    4db2:	9c 81       	ldd	r25, Y+4	; 0x04
    4db4:	82 1b       	sub	r24, r18
    4db6:	93 0b       	sbc	r25, r19
    4db8:	9a 83       	std	Y+2, r25	; 0x02
    4dba:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4dbc:	e8 85       	ldd	r30, Y+8	; 0x08
    4dbe:	f9 85       	ldd	r31, Y+9	; 0x09
    4dc0:	80 81       	ld	r24, Z
    4dc2:	91 81       	ldd	r25, Z+1	; 0x01
    4dc4:	2f ef       	ldi	r18, 0xFF	; 255
    4dc6:	8f 3f       	cpi	r24, 0xFF	; 255
    4dc8:	92 07       	cpc	r25, r18
    4dca:	11 f4       	brne	.+4      	; 0x4dd0 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4dcc:	1d 82       	std	Y+5, r1	; 0x05
    4dce:	36 c0       	rjmp	.+108    	; 0x4e3c <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4dd0:	ee 81       	ldd	r30, Y+6	; 0x06
    4dd2:	ff 81       	ldd	r31, Y+7	; 0x07
    4dd4:	90 81       	ld	r25, Z
    4dd6:	80 91 d8 06 	lds	r24, 0x06D8
    4dda:	98 17       	cp	r25, r24
    4ddc:	61 f0       	breq	.+24     	; 0x4df6 <xTaskCheckForTimeOut+0x7c>
    4dde:	ee 81       	ldd	r30, Y+6	; 0x06
    4de0:	ff 81       	ldd	r31, Y+7	; 0x07
    4de2:	21 81       	ldd	r18, Z+1	; 0x01
    4de4:	32 81       	ldd	r19, Z+2	; 0x02
    4de6:	8b 81       	ldd	r24, Y+3	; 0x03
    4de8:	9c 81       	ldd	r25, Y+4	; 0x04
    4dea:	82 17       	cp	r24, r18
    4dec:	93 07       	cpc	r25, r19
    4dee:	18 f0       	brcs	.+6      	; 0x4df6 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    4df0:	81 e0       	ldi	r24, 0x01	; 1
    4df2:	8d 83       	std	Y+5, r24	; 0x05
    4df4:	23 c0       	rjmp	.+70     	; 0x4e3c <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4df6:	e8 85       	ldd	r30, Y+8	; 0x08
    4df8:	f9 85       	ldd	r31, Y+9	; 0x09
    4dfa:	20 81       	ld	r18, Z
    4dfc:	31 81       	ldd	r19, Z+1	; 0x01
    4dfe:	89 81       	ldd	r24, Y+1	; 0x01
    4e00:	9a 81       	ldd	r25, Y+2	; 0x02
    4e02:	82 17       	cp	r24, r18
    4e04:	93 07       	cpc	r25, r19
    4e06:	a0 f4       	brcc	.+40     	; 0x4e30 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    4e08:	e8 85       	ldd	r30, Y+8	; 0x08
    4e0a:	f9 85       	ldd	r31, Y+9	; 0x09
    4e0c:	20 81       	ld	r18, Z
    4e0e:	31 81       	ldd	r19, Z+1	; 0x01
    4e10:	89 81       	ldd	r24, Y+1	; 0x01
    4e12:	9a 81       	ldd	r25, Y+2	; 0x02
    4e14:	a9 01       	movw	r20, r18
    4e16:	48 1b       	sub	r20, r24
    4e18:	59 0b       	sbc	r21, r25
    4e1a:	ca 01       	movw	r24, r20
    4e1c:	e8 85       	ldd	r30, Y+8	; 0x08
    4e1e:	f9 85       	ldd	r31, Y+9	; 0x09
    4e20:	91 83       	std	Z+1, r25	; 0x01
    4e22:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    4e24:	8e 81       	ldd	r24, Y+6	; 0x06
    4e26:	9f 81       	ldd	r25, Y+7	; 0x07
    4e28:	0e 94 a4 26 	call	0x4d48	; 0x4d48 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    4e2c:	1d 82       	std	Y+5, r1	; 0x05
    4e2e:	06 c0       	rjmp	.+12     	; 0x4e3c <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    4e30:	e8 85       	ldd	r30, Y+8	; 0x08
    4e32:	f9 85       	ldd	r31, Y+9	; 0x09
    4e34:	11 82       	std	Z+1, r1	; 0x01
    4e36:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    4e38:	81 e0       	ldi	r24, 0x01	; 1
    4e3a:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    4e3c:	0f 90       	pop	r0
    4e3e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4e40:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4e42:	29 96       	adiw	r28, 0x09	; 9
    4e44:	0f b6       	in	r0, 0x3f	; 63
    4e46:	f8 94       	cli
    4e48:	de bf       	out	0x3e, r29	; 62
    4e4a:	0f be       	out	0x3f, r0	; 63
    4e4c:	cd bf       	out	0x3d, r28	; 61
    4e4e:	cf 91       	pop	r28
    4e50:	df 91       	pop	r29
    4e52:	08 95       	ret

00004e54 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4e54:	df 93       	push	r29
    4e56:	cf 93       	push	r28
    4e58:	cd b7       	in	r28, 0x3d	; 61
    4e5a:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4e5c:	81 e0       	ldi	r24, 0x01	; 1
    4e5e:	80 93 d7 06 	sts	0x06D7, r24
}
    4e62:	cf 91       	pop	r28
    4e64:	df 91       	pop	r29
    4e66:	08 95       	ret

00004e68 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4e68:	df 93       	push	r29
    4e6a:	cf 93       	push	r28
    4e6c:	00 d0       	rcall	.+0      	; 0x4e6e <prvIdleTask+0x6>
    4e6e:	cd b7       	in	r28, 0x3d	; 61
    4e70:	de b7       	in	r29, 0x3e	; 62
    4e72:	9a 83       	std	Y+2, r25	; 0x02
    4e74:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4e76:	0e 94 7f 27 	call	0x4efe	; 0x4efe <prvCheckTasksWaitingTermination>
    4e7a:	fd cf       	rjmp	.-6      	; 0x4e76 <prvIdleTask+0xe>

00004e7c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4e7c:	df 93       	push	r29
    4e7e:	cf 93       	push	r28
    4e80:	0f 92       	push	r0
    4e82:	cd b7       	in	r28, 0x3d	; 61
    4e84:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4e86:	19 82       	std	Y+1, r1	; 0x01
    4e88:	13 c0       	rjmp	.+38     	; 0x4eb0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4e8a:	89 81       	ldd	r24, Y+1	; 0x01
    4e8c:	28 2f       	mov	r18, r24
    4e8e:	30 e0       	ldi	r19, 0x00	; 0
    4e90:	c9 01       	movw	r24, r18
    4e92:	88 0f       	add	r24, r24
    4e94:	99 1f       	adc	r25, r25
    4e96:	88 0f       	add	r24, r24
    4e98:	99 1f       	adc	r25, r25
    4e9a:	88 0f       	add	r24, r24
    4e9c:	99 1f       	adc	r25, r25
    4e9e:	82 0f       	add	r24, r18
    4ea0:	93 1f       	adc	r25, r19
    4ea2:	81 52       	subi	r24, 0x21	; 33
    4ea4:	99 4f       	sbci	r25, 0xF9	; 249
    4ea6:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4eaa:	89 81       	ldd	r24, Y+1	; 0x01
    4eac:	8f 5f       	subi	r24, 0xFF	; 255
    4eae:	89 83       	std	Y+1, r24	; 0x01
    4eb0:	89 81       	ldd	r24, Y+1	; 0x01
    4eb2:	87 30       	cpi	r24, 0x07	; 7
    4eb4:	50 f3       	brcs	.-44     	; 0x4e8a <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4eb6:	8e e1       	ldi	r24, 0x1E	; 30
    4eb8:	97 e0       	ldi	r25, 0x07	; 7
    4eba:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4ebe:	87 e2       	ldi	r24, 0x27	; 39
    4ec0:	97 e0       	ldi	r25, 0x07	; 7
    4ec2:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4ec6:	84 e3       	ldi	r24, 0x34	; 52
    4ec8:	97 e0       	ldi	r25, 0x07	; 7
    4eca:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4ece:	8d e3       	ldi	r24, 0x3D	; 61
    4ed0:	97 e0       	ldi	r25, 0x07	; 7
    4ed2:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4ed6:	86 e4       	ldi	r24, 0x46	; 70
    4ed8:	97 e0       	ldi	r25, 0x07	; 7
    4eda:	0e 94 a5 0b 	call	0x174a	; 0x174a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4ede:	8e e1       	ldi	r24, 0x1E	; 30
    4ee0:	97 e0       	ldi	r25, 0x07	; 7
    4ee2:	90 93 31 07 	sts	0x0731, r25
    4ee6:	80 93 30 07 	sts	0x0730, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4eea:	87 e2       	ldi	r24, 0x27	; 39
    4eec:	97 e0       	ldi	r25, 0x07	; 7
    4eee:	90 93 33 07 	sts	0x0733, r25
    4ef2:	80 93 32 07 	sts	0x0732, r24
}
    4ef6:	0f 90       	pop	r0
    4ef8:	cf 91       	pop	r28
    4efa:	df 91       	pop	r29
    4efc:	08 95       	ret

00004efe <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4efe:	df 93       	push	r29
    4f00:	cf 93       	push	r28
    4f02:	00 d0       	rcall	.+0      	; 0x4f04 <prvCheckTasksWaitingTermination+0x6>
    4f04:	cd b7       	in	r28, 0x3d	; 61
    4f06:	de b7       	in	r29, 0x3e	; 62
    4f08:	20 c0       	rjmp	.+64     	; 0x4f4a <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4f0a:	0f b6       	in	r0, 0x3f	; 63
    4f0c:	f8 94       	cli
    4f0e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4f10:	e0 91 42 07 	lds	r30, 0x0742
    4f14:	f0 91 43 07 	lds	r31, 0x0743
    4f18:	86 81       	ldd	r24, Z+6	; 0x06
    4f1a:	97 81       	ldd	r25, Z+7	; 0x07
    4f1c:	9a 83       	std	Y+2, r25	; 0x02
    4f1e:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4f20:	89 81       	ldd	r24, Y+1	; 0x01
    4f22:	9a 81       	ldd	r25, Y+2	; 0x02
    4f24:	02 96       	adiw	r24, 0x02	; 2
    4f26:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
				--uxCurrentNumberOfTasks;
    4f2a:	80 91 d1 06 	lds	r24, 0x06D1
    4f2e:	81 50       	subi	r24, 0x01	; 1
    4f30:	80 93 d1 06 	sts	0x06D1, r24
				--uxDeletedTasksWaitingCleanUp;
    4f34:	80 91 d0 06 	lds	r24, 0x06D0
    4f38:	81 50       	subi	r24, 0x01	; 1
    4f3a:	80 93 d0 06 	sts	0x06D0, r24
			}
			taskEXIT_CRITICAL();
    4f3e:	0f 90       	pop	r0
    4f40:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4f42:	89 81       	ldd	r24, Y+1	; 0x01
    4f44:	9a 81       	ldd	r25, Y+2	; 0x02
    4f46:	0e 94 ae 27 	call	0x4f5c	; 0x4f5c <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4f4a:	80 91 d0 06 	lds	r24, 0x06D0
    4f4e:	88 23       	and	r24, r24
    4f50:	e1 f6       	brne	.-72     	; 0x4f0a <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4f52:	0f 90       	pop	r0
    4f54:	0f 90       	pop	r0
    4f56:	cf 91       	pop	r28
    4f58:	df 91       	pop	r29
    4f5a:	08 95       	ret

00004f5c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4f5c:	df 93       	push	r29
    4f5e:	cf 93       	push	r28
    4f60:	00 d0       	rcall	.+0      	; 0x4f62 <prvDeleteTCB+0x6>
    4f62:	cd b7       	in	r28, 0x3d	; 61
    4f64:	de b7       	in	r29, 0x3e	; 62
    4f66:	9a 83       	std	Y+2, r25	; 0x02
    4f68:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4f6a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f6c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f6e:	87 89       	ldd	r24, Z+23	; 0x17
    4f70:	90 8d       	ldd	r25, Z+24	; 0x18
    4f72:	0e 94 f6 09 	call	0x13ec	; 0x13ec <vPortFree>
			vPortFree( pxTCB );
    4f76:	89 81       	ldd	r24, Y+1	; 0x01
    4f78:	9a 81       	ldd	r25, Y+2	; 0x02
    4f7a:	0e 94 f6 09 	call	0x13ec	; 0x13ec <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4f7e:	0f 90       	pop	r0
    4f80:	0f 90       	pop	r0
    4f82:	cf 91       	pop	r28
    4f84:	df 91       	pop	r29
    4f86:	08 95       	ret

00004f88 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4f88:	df 93       	push	r29
    4f8a:	cf 93       	push	r28
    4f8c:	00 d0       	rcall	.+0      	; 0x4f8e <prvResetNextTaskUnblockTime+0x6>
    4f8e:	cd b7       	in	r28, 0x3d	; 61
    4f90:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4f92:	e0 91 30 07 	lds	r30, 0x0730
    4f96:	f0 91 31 07 	lds	r31, 0x0731
    4f9a:	80 81       	ld	r24, Z
    4f9c:	88 23       	and	r24, r24
    4f9e:	39 f4       	brne	.+14     	; 0x4fae <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4fa0:	8f ef       	ldi	r24, 0xFF	; 255
    4fa2:	9f ef       	ldi	r25, 0xFF	; 255
    4fa4:	90 93 db 06 	sts	0x06DB, r25
    4fa8:	80 93 da 06 	sts	0x06DA, r24
    4fac:	13 c0       	rjmp	.+38     	; 0x4fd4 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4fae:	e0 91 30 07 	lds	r30, 0x0730
    4fb2:	f0 91 31 07 	lds	r31, 0x0731
    4fb6:	05 80       	ldd	r0, Z+5	; 0x05
    4fb8:	f6 81       	ldd	r31, Z+6	; 0x06
    4fba:	e0 2d       	mov	r30, r0
    4fbc:	86 81       	ldd	r24, Z+6	; 0x06
    4fbe:	97 81       	ldd	r25, Z+7	; 0x07
    4fc0:	9a 83       	std	Y+2, r25	; 0x02
    4fc2:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4fc4:	e9 81       	ldd	r30, Y+1	; 0x01
    4fc6:	fa 81       	ldd	r31, Y+2	; 0x02
    4fc8:	82 81       	ldd	r24, Z+2	; 0x02
    4fca:	93 81       	ldd	r25, Z+3	; 0x03
    4fcc:	90 93 db 06 	sts	0x06DB, r25
    4fd0:	80 93 da 06 	sts	0x06DA, r24
	}
}
    4fd4:	0f 90       	pop	r0
    4fd6:	0f 90       	pop	r0
    4fd8:	cf 91       	pop	r28
    4fda:	df 91       	pop	r29
    4fdc:	08 95       	ret

00004fde <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4fde:	df 93       	push	r29
    4fe0:	cf 93       	push	r28
    4fe2:	00 d0       	rcall	.+0      	; 0x4fe4 <xTaskGetCurrentTaskHandle+0x6>
    4fe4:	cd b7       	in	r28, 0x3d	; 61
    4fe6:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4fe8:	80 91 ce 06 	lds	r24, 0x06CE
    4fec:	90 91 cf 06 	lds	r25, 0x06CF
    4ff0:	9a 83       	std	Y+2, r25	; 0x02
    4ff2:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4ff4:	89 81       	ldd	r24, Y+1	; 0x01
    4ff6:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4ff8:	0f 90       	pop	r0
    4ffa:	0f 90       	pop	r0
    4ffc:	cf 91       	pop	r28
    4ffe:	df 91       	pop	r29
    5000:	08 95       	ret

00005002 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    5002:	df 93       	push	r29
    5004:	cf 93       	push	r28
    5006:	00 d0       	rcall	.+0      	; 0x5008 <xTaskPriorityInherit+0x6>
    5008:	00 d0       	rcall	.+0      	; 0x500a <xTaskPriorityInherit+0x8>
    500a:	0f 92       	push	r0
    500c:	cd b7       	in	r28, 0x3d	; 61
    500e:	de b7       	in	r29, 0x3e	; 62
    5010:	9d 83       	std	Y+5, r25	; 0x05
    5012:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    5014:	8c 81       	ldd	r24, Y+4	; 0x04
    5016:	9d 81       	ldd	r25, Y+5	; 0x05
    5018:	9b 83       	std	Y+3, r25	; 0x03
    501a:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    501c:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    501e:	8c 81       	ldd	r24, Y+4	; 0x04
    5020:	9d 81       	ldd	r25, Y+5	; 0x05
    5022:	00 97       	sbiw	r24, 0x00	; 0
    5024:	09 f4       	brne	.+2      	; 0x5028 <xTaskPriorityInherit+0x26>
    5026:	82 c0       	rjmp	.+260    	; 0x512c <xTaskPriorityInherit+0x12a>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    5028:	ea 81       	ldd	r30, Y+2	; 0x02
    502a:	fb 81       	ldd	r31, Y+3	; 0x03
    502c:	96 89       	ldd	r25, Z+22	; 0x16
    502e:	e0 91 ce 06 	lds	r30, 0x06CE
    5032:	f0 91 cf 06 	lds	r31, 0x06CF
    5036:	86 89       	ldd	r24, Z+22	; 0x16
    5038:	98 17       	cp	r25, r24
    503a:	08 f0       	brcs	.+2      	; 0x503e <xTaskPriorityInherit+0x3c>
    503c:	6b c0       	rjmp	.+214    	; 0x5114 <xTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    503e:	ea 81       	ldd	r30, Y+2	; 0x02
    5040:	fb 81       	ldd	r31, Y+3	; 0x03
    5042:	84 85       	ldd	r24, Z+12	; 0x0c
    5044:	95 85       	ldd	r25, Z+13	; 0x0d
    5046:	99 23       	and	r25, r25
    5048:	7c f0       	brlt	.+30     	; 0x5068 <xTaskPriorityInherit+0x66>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    504a:	e0 91 ce 06 	lds	r30, 0x06CE
    504e:	f0 91 cf 06 	lds	r31, 0x06CF
    5052:	86 89       	ldd	r24, Z+22	; 0x16
    5054:	28 2f       	mov	r18, r24
    5056:	30 e0       	ldi	r19, 0x00	; 0
    5058:	87 e0       	ldi	r24, 0x07	; 7
    505a:	90 e0       	ldi	r25, 0x00	; 0
    505c:	82 1b       	sub	r24, r18
    505e:	93 0b       	sbc	r25, r19
    5060:	ea 81       	ldd	r30, Y+2	; 0x02
    5062:	fb 81       	ldd	r31, Y+3	; 0x03
    5064:	95 87       	std	Z+13, r25	; 0x0d
    5066:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    5068:	ea 81       	ldd	r30, Y+2	; 0x02
    506a:	fb 81       	ldd	r31, Y+3	; 0x03
    506c:	42 85       	ldd	r20, Z+10	; 0x0a
    506e:	53 85       	ldd	r21, Z+11	; 0x0b
    5070:	ea 81       	ldd	r30, Y+2	; 0x02
    5072:	fb 81       	ldd	r31, Y+3	; 0x03
    5074:	86 89       	ldd	r24, Z+22	; 0x16
    5076:	28 2f       	mov	r18, r24
    5078:	30 e0       	ldi	r19, 0x00	; 0
    507a:	c9 01       	movw	r24, r18
    507c:	88 0f       	add	r24, r24
    507e:	99 1f       	adc	r25, r25
    5080:	88 0f       	add	r24, r24
    5082:	99 1f       	adc	r25, r25
    5084:	88 0f       	add	r24, r24
    5086:	99 1f       	adc	r25, r25
    5088:	82 0f       	add	r24, r18
    508a:	93 1f       	adc	r25, r19
    508c:	81 52       	subi	r24, 0x21	; 33
    508e:	99 4f       	sbci	r25, 0xF9	; 249
    5090:	48 17       	cp	r20, r24
    5092:	59 07       	cpc	r21, r25
    5094:	a1 f5       	brne	.+104    	; 0x50fe <xTaskPriorityInherit+0xfc>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5096:	8a 81       	ldd	r24, Y+2	; 0x02
    5098:	9b 81       	ldd	r25, Y+3	; 0x03
    509a:	02 96       	adiw	r24, 0x02	; 2
    509c:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    50a0:	e0 91 ce 06 	lds	r30, 0x06CE
    50a4:	f0 91 cf 06 	lds	r31, 0x06CF
    50a8:	86 89       	ldd	r24, Z+22	; 0x16
    50aa:	ea 81       	ldd	r30, Y+2	; 0x02
    50ac:	fb 81       	ldd	r31, Y+3	; 0x03
    50ae:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    50b0:	ea 81       	ldd	r30, Y+2	; 0x02
    50b2:	fb 81       	ldd	r31, Y+3	; 0x03
    50b4:	96 89       	ldd	r25, Z+22	; 0x16
    50b6:	80 91 d4 06 	lds	r24, 0x06D4
    50ba:	89 17       	cp	r24, r25
    50bc:	28 f4       	brcc	.+10     	; 0x50c8 <xTaskPriorityInherit+0xc6>
    50be:	ea 81       	ldd	r30, Y+2	; 0x02
    50c0:	fb 81       	ldd	r31, Y+3	; 0x03
    50c2:	86 89       	ldd	r24, Z+22	; 0x16
    50c4:	80 93 d4 06 	sts	0x06D4, r24
    50c8:	ea 81       	ldd	r30, Y+2	; 0x02
    50ca:	fb 81       	ldd	r31, Y+3	; 0x03
    50cc:	86 89       	ldd	r24, Z+22	; 0x16
    50ce:	28 2f       	mov	r18, r24
    50d0:	30 e0       	ldi	r19, 0x00	; 0
    50d2:	c9 01       	movw	r24, r18
    50d4:	88 0f       	add	r24, r24
    50d6:	99 1f       	adc	r25, r25
    50d8:	88 0f       	add	r24, r24
    50da:	99 1f       	adc	r25, r25
    50dc:	88 0f       	add	r24, r24
    50de:	99 1f       	adc	r25, r25
    50e0:	82 0f       	add	r24, r18
    50e2:	93 1f       	adc	r25, r19
    50e4:	ac 01       	movw	r20, r24
    50e6:	41 52       	subi	r20, 0x21	; 33
    50e8:	59 4f       	sbci	r21, 0xF9	; 249
    50ea:	8a 81       	ldd	r24, Y+2	; 0x02
    50ec:	9b 81       	ldd	r25, Y+3	; 0x03
    50ee:	9c 01       	movw	r18, r24
    50f0:	2e 5f       	subi	r18, 0xFE	; 254
    50f2:	3f 4f       	sbci	r19, 0xFF	; 255
    50f4:	ca 01       	movw	r24, r20
    50f6:	b9 01       	movw	r22, r18
    50f8:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
    50fc:	08 c0       	rjmp	.+16     	; 0x510e <xTaskPriorityInherit+0x10c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    50fe:	e0 91 ce 06 	lds	r30, 0x06CE
    5102:	f0 91 cf 06 	lds	r31, 0x06CF
    5106:	86 89       	ldd	r24, Z+22	; 0x16
    5108:	ea 81       	ldd	r30, Y+2	; 0x02
    510a:	fb 81       	ldd	r31, Y+3	; 0x03
    510c:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    510e:	81 e0       	ldi	r24, 0x01	; 1
    5110:	89 83       	std	Y+1, r24	; 0x01
    5112:	0c c0       	rjmp	.+24     	; 0x512c <xTaskPriorityInherit+0x12a>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    5114:	ea 81       	ldd	r30, Y+2	; 0x02
    5116:	fb 81       	ldd	r31, Y+3	; 0x03
    5118:	95 a5       	ldd	r25, Z+45	; 0x2d
    511a:	e0 91 ce 06 	lds	r30, 0x06CE
    511e:	f0 91 cf 06 	lds	r31, 0x06CF
    5122:	86 89       	ldd	r24, Z+22	; 0x16
    5124:	98 17       	cp	r25, r24
    5126:	10 f4       	brcc	.+4      	; 0x512c <xTaskPriorityInherit+0x12a>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    5128:	81 e0       	ldi	r24, 0x01	; 1
    512a:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    512c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    512e:	0f 90       	pop	r0
    5130:	0f 90       	pop	r0
    5132:	0f 90       	pop	r0
    5134:	0f 90       	pop	r0
    5136:	0f 90       	pop	r0
    5138:	cf 91       	pop	r28
    513a:	df 91       	pop	r29
    513c:	08 95       	ret

0000513e <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    513e:	df 93       	push	r29
    5140:	cf 93       	push	r28
    5142:	00 d0       	rcall	.+0      	; 0x5144 <xTaskPriorityDisinherit+0x6>
    5144:	00 d0       	rcall	.+0      	; 0x5146 <xTaskPriorityDisinherit+0x8>
    5146:	0f 92       	push	r0
    5148:	cd b7       	in	r28, 0x3d	; 61
    514a:	de b7       	in	r29, 0x3e	; 62
    514c:	9d 83       	std	Y+5, r25	; 0x05
    514e:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    5150:	8c 81       	ldd	r24, Y+4	; 0x04
    5152:	9d 81       	ldd	r25, Y+5	; 0x05
    5154:	9b 83       	std	Y+3, r25	; 0x03
    5156:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    5158:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    515a:	8c 81       	ldd	r24, Y+4	; 0x04
    515c:	9d 81       	ldd	r25, Y+5	; 0x05
    515e:	00 97       	sbiw	r24, 0x00	; 0
    5160:	09 f4       	brne	.+2      	; 0x5164 <xTaskPriorityDisinherit+0x26>
    5162:	56 c0       	rjmp	.+172    	; 0x5210 <xTaskPriorityDisinherit+0xd2>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    5164:	ea 81       	ldd	r30, Y+2	; 0x02
    5166:	fb 81       	ldd	r31, Y+3	; 0x03
    5168:	86 a5       	ldd	r24, Z+46	; 0x2e
    516a:	81 50       	subi	r24, 0x01	; 1
    516c:	ea 81       	ldd	r30, Y+2	; 0x02
    516e:	fb 81       	ldd	r31, Y+3	; 0x03
    5170:	86 a7       	std	Z+46, r24	; 0x2e

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    5172:	ea 81       	ldd	r30, Y+2	; 0x02
    5174:	fb 81       	ldd	r31, Y+3	; 0x03
    5176:	96 89       	ldd	r25, Z+22	; 0x16
    5178:	ea 81       	ldd	r30, Y+2	; 0x02
    517a:	fb 81       	ldd	r31, Y+3	; 0x03
    517c:	85 a5       	ldd	r24, Z+45	; 0x2d
    517e:	98 17       	cp	r25, r24
    5180:	09 f4       	brne	.+2      	; 0x5184 <xTaskPriorityDisinherit+0x46>
    5182:	46 c0       	rjmp	.+140    	; 0x5210 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    5184:	ea 81       	ldd	r30, Y+2	; 0x02
    5186:	fb 81       	ldd	r31, Y+3	; 0x03
    5188:	86 a5       	ldd	r24, Z+46	; 0x2e
    518a:	88 23       	and	r24, r24
    518c:	09 f0       	breq	.+2      	; 0x5190 <xTaskPriorityDisinherit+0x52>
    518e:	40 c0       	rjmp	.+128    	; 0x5210 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5190:	8a 81       	ldd	r24, Y+2	; 0x02
    5192:	9b 81       	ldd	r25, Y+3	; 0x03
    5194:	02 96       	adiw	r24, 0x02	; 2
    5196:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    519a:	ea 81       	ldd	r30, Y+2	; 0x02
    519c:	fb 81       	ldd	r31, Y+3	; 0x03
    519e:	85 a5       	ldd	r24, Z+45	; 0x2d
    51a0:	ea 81       	ldd	r30, Y+2	; 0x02
    51a2:	fb 81       	ldd	r31, Y+3	; 0x03
    51a4:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    51a6:	ea 81       	ldd	r30, Y+2	; 0x02
    51a8:	fb 81       	ldd	r31, Y+3	; 0x03
    51aa:	86 89       	ldd	r24, Z+22	; 0x16
    51ac:	28 2f       	mov	r18, r24
    51ae:	30 e0       	ldi	r19, 0x00	; 0
    51b0:	87 e0       	ldi	r24, 0x07	; 7
    51b2:	90 e0       	ldi	r25, 0x00	; 0
    51b4:	82 1b       	sub	r24, r18
    51b6:	93 0b       	sbc	r25, r19
    51b8:	ea 81       	ldd	r30, Y+2	; 0x02
    51ba:	fb 81       	ldd	r31, Y+3	; 0x03
    51bc:	95 87       	std	Z+13, r25	; 0x0d
    51be:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    51c0:	ea 81       	ldd	r30, Y+2	; 0x02
    51c2:	fb 81       	ldd	r31, Y+3	; 0x03
    51c4:	96 89       	ldd	r25, Z+22	; 0x16
    51c6:	80 91 d4 06 	lds	r24, 0x06D4
    51ca:	89 17       	cp	r24, r25
    51cc:	28 f4       	brcc	.+10     	; 0x51d8 <xTaskPriorityDisinherit+0x9a>
    51ce:	ea 81       	ldd	r30, Y+2	; 0x02
    51d0:	fb 81       	ldd	r31, Y+3	; 0x03
    51d2:	86 89       	ldd	r24, Z+22	; 0x16
    51d4:	80 93 d4 06 	sts	0x06D4, r24
    51d8:	ea 81       	ldd	r30, Y+2	; 0x02
    51da:	fb 81       	ldd	r31, Y+3	; 0x03
    51dc:	86 89       	ldd	r24, Z+22	; 0x16
    51de:	28 2f       	mov	r18, r24
    51e0:	30 e0       	ldi	r19, 0x00	; 0
    51e2:	c9 01       	movw	r24, r18
    51e4:	88 0f       	add	r24, r24
    51e6:	99 1f       	adc	r25, r25
    51e8:	88 0f       	add	r24, r24
    51ea:	99 1f       	adc	r25, r25
    51ec:	88 0f       	add	r24, r24
    51ee:	99 1f       	adc	r25, r25
    51f0:	82 0f       	add	r24, r18
    51f2:	93 1f       	adc	r25, r19
    51f4:	ac 01       	movw	r20, r24
    51f6:	41 52       	subi	r20, 0x21	; 33
    51f8:	59 4f       	sbci	r21, 0xF9	; 249
    51fa:	8a 81       	ldd	r24, Y+2	; 0x02
    51fc:	9b 81       	ldd	r25, Y+3	; 0x03
    51fe:	9c 01       	movw	r18, r24
    5200:	2e 5f       	subi	r18, 0xFE	; 254
    5202:	3f 4f       	sbci	r19, 0xFF	; 255
    5204:	ca 01       	movw	r24, r20
    5206:	b9 01       	movw	r22, r18
    5208:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    520c:	81 e0       	ldi	r24, 0x01	; 1
    520e:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5210:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5212:	0f 90       	pop	r0
    5214:	0f 90       	pop	r0
    5216:	0f 90       	pop	r0
    5218:	0f 90       	pop	r0
    521a:	0f 90       	pop	r0
    521c:	cf 91       	pop	r28
    521e:	df 91       	pop	r29
    5220:	08 95       	ret

00005222 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    5222:	df 93       	push	r29
    5224:	cf 93       	push	r28
    5226:	cd b7       	in	r28, 0x3d	; 61
    5228:	de b7       	in	r29, 0x3e	; 62
    522a:	28 97       	sbiw	r28, 0x08	; 8
    522c:	0f b6       	in	r0, 0x3f	; 63
    522e:	f8 94       	cli
    5230:	de bf       	out	0x3e, r29	; 62
    5232:	0f be       	out	0x3f, r0	; 63
    5234:	cd bf       	out	0x3d, r28	; 61
    5236:	9f 83       	std	Y+7, r25	; 0x07
    5238:	8e 83       	std	Y+6, r24	; 0x06
    523a:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    523c:	8e 81       	ldd	r24, Y+6	; 0x06
    523e:	9f 81       	ldd	r25, Y+7	; 0x07
    5240:	9d 83       	std	Y+5, r25	; 0x05
    5242:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    5244:	81 e0       	ldi	r24, 0x01	; 1
    5246:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    5248:	8e 81       	ldd	r24, Y+6	; 0x06
    524a:	9f 81       	ldd	r25, Y+7	; 0x07
    524c:	00 97       	sbiw	r24, 0x00	; 0
    524e:	09 f4       	brne	.+2      	; 0x5252 <vTaskPriorityDisinheritAfterTimeout+0x30>
    5250:	74 c0       	rjmp	.+232    	; 0x533a <vTaskPriorityDisinheritAfterTimeout+0x118>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    5252:	ec 81       	ldd	r30, Y+4	; 0x04
    5254:	fd 81       	ldd	r31, Y+5	; 0x05
    5256:	95 a5       	ldd	r25, Z+45	; 0x2d
    5258:	88 85       	ldd	r24, Y+8	; 0x08
    525a:	98 17       	cp	r25, r24
    525c:	18 f4       	brcc	.+6      	; 0x5264 <vTaskPriorityDisinheritAfterTimeout+0x42>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    525e:	88 85       	ldd	r24, Y+8	; 0x08
    5260:	8a 83       	std	Y+2, r24	; 0x02
    5262:	04 c0       	rjmp	.+8      	; 0x526c <vTaskPriorityDisinheritAfterTimeout+0x4a>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    5264:	ec 81       	ldd	r30, Y+4	; 0x04
    5266:	fd 81       	ldd	r31, Y+5	; 0x05
    5268:	85 a5       	ldd	r24, Z+45	; 0x2d
    526a:	8a 83       	std	Y+2, r24	; 0x02
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    526c:	ec 81       	ldd	r30, Y+4	; 0x04
    526e:	fd 81       	ldd	r31, Y+5	; 0x05
    5270:	96 89       	ldd	r25, Z+22	; 0x16
    5272:	8a 81       	ldd	r24, Y+2	; 0x02
    5274:	98 17       	cp	r25, r24
    5276:	09 f4       	brne	.+2      	; 0x527a <vTaskPriorityDisinheritAfterTimeout+0x58>
    5278:	60 c0       	rjmp	.+192    	; 0x533a <vTaskPriorityDisinheritAfterTimeout+0x118>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    527a:	ec 81       	ldd	r30, Y+4	; 0x04
    527c:	fd 81       	ldd	r31, Y+5	; 0x05
    527e:	96 a5       	ldd	r25, Z+46	; 0x2e
    5280:	89 81       	ldd	r24, Y+1	; 0x01
    5282:	98 17       	cp	r25, r24
    5284:	09 f0       	breq	.+2      	; 0x5288 <vTaskPriorityDisinheritAfterTimeout+0x66>
    5286:	59 c0       	rjmp	.+178    	; 0x533a <vTaskPriorityDisinheritAfterTimeout+0x118>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    5288:	ec 81       	ldd	r30, Y+4	; 0x04
    528a:	fd 81       	ldd	r31, Y+5	; 0x05
    528c:	86 89       	ldd	r24, Z+22	; 0x16
    528e:	8b 83       	std	Y+3, r24	; 0x03
					pxTCB->uxPriority = uxPriorityToUse;
    5290:	ec 81       	ldd	r30, Y+4	; 0x04
    5292:	fd 81       	ldd	r31, Y+5	; 0x05
    5294:	8a 81       	ldd	r24, Y+2	; 0x02
    5296:	86 8b       	std	Z+22, r24	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    5298:	ec 81       	ldd	r30, Y+4	; 0x04
    529a:	fd 81       	ldd	r31, Y+5	; 0x05
    529c:	84 85       	ldd	r24, Z+12	; 0x0c
    529e:	95 85       	ldd	r25, Z+13	; 0x0d
    52a0:	99 23       	and	r25, r25
    52a2:	5c f0       	brlt	.+22     	; 0x52ba <vTaskPriorityDisinheritAfterTimeout+0x98>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    52a4:	8a 81       	ldd	r24, Y+2	; 0x02
    52a6:	28 2f       	mov	r18, r24
    52a8:	30 e0       	ldi	r19, 0x00	; 0
    52aa:	87 e0       	ldi	r24, 0x07	; 7
    52ac:	90 e0       	ldi	r25, 0x00	; 0
    52ae:	82 1b       	sub	r24, r18
    52b0:	93 0b       	sbc	r25, r19
    52b2:	ec 81       	ldd	r30, Y+4	; 0x04
    52b4:	fd 81       	ldd	r31, Y+5	; 0x05
    52b6:	95 87       	std	Z+13, r25	; 0x0d
    52b8:	84 87       	std	Z+12, r24	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    52ba:	ec 81       	ldd	r30, Y+4	; 0x04
    52bc:	fd 81       	ldd	r31, Y+5	; 0x05
    52be:	42 85       	ldd	r20, Z+10	; 0x0a
    52c0:	53 85       	ldd	r21, Z+11	; 0x0b
    52c2:	8b 81       	ldd	r24, Y+3	; 0x03
    52c4:	28 2f       	mov	r18, r24
    52c6:	30 e0       	ldi	r19, 0x00	; 0
    52c8:	c9 01       	movw	r24, r18
    52ca:	88 0f       	add	r24, r24
    52cc:	99 1f       	adc	r25, r25
    52ce:	88 0f       	add	r24, r24
    52d0:	99 1f       	adc	r25, r25
    52d2:	88 0f       	add	r24, r24
    52d4:	99 1f       	adc	r25, r25
    52d6:	82 0f       	add	r24, r18
    52d8:	93 1f       	adc	r25, r19
    52da:	81 52       	subi	r24, 0x21	; 33
    52dc:	99 4f       	sbci	r25, 0xF9	; 249
    52de:	48 17       	cp	r20, r24
    52e0:	59 07       	cpc	r21, r25
    52e2:	59 f5       	brne	.+86     	; 0x533a <vTaskPriorityDisinheritAfterTimeout+0x118>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    52e4:	8c 81       	ldd	r24, Y+4	; 0x04
    52e6:	9d 81       	ldd	r25, Y+5	; 0x05
    52e8:	02 96       	adiw	r24, 0x02	; 2
    52ea:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    52ee:	ec 81       	ldd	r30, Y+4	; 0x04
    52f0:	fd 81       	ldd	r31, Y+5	; 0x05
    52f2:	96 89       	ldd	r25, Z+22	; 0x16
    52f4:	80 91 d4 06 	lds	r24, 0x06D4
    52f8:	89 17       	cp	r24, r25
    52fa:	28 f4       	brcc	.+10     	; 0x5306 <vTaskPriorityDisinheritAfterTimeout+0xe4>
    52fc:	ec 81       	ldd	r30, Y+4	; 0x04
    52fe:	fd 81       	ldd	r31, Y+5	; 0x05
    5300:	86 89       	ldd	r24, Z+22	; 0x16
    5302:	80 93 d4 06 	sts	0x06D4, r24
    5306:	ec 81       	ldd	r30, Y+4	; 0x04
    5308:	fd 81       	ldd	r31, Y+5	; 0x05
    530a:	86 89       	ldd	r24, Z+22	; 0x16
    530c:	28 2f       	mov	r18, r24
    530e:	30 e0       	ldi	r19, 0x00	; 0
    5310:	c9 01       	movw	r24, r18
    5312:	88 0f       	add	r24, r24
    5314:	99 1f       	adc	r25, r25
    5316:	88 0f       	add	r24, r24
    5318:	99 1f       	adc	r25, r25
    531a:	88 0f       	add	r24, r24
    531c:	99 1f       	adc	r25, r25
    531e:	82 0f       	add	r24, r18
    5320:	93 1f       	adc	r25, r19
    5322:	ac 01       	movw	r20, r24
    5324:	41 52       	subi	r20, 0x21	; 33
    5326:	59 4f       	sbci	r21, 0xF9	; 249
    5328:	8c 81       	ldd	r24, Y+4	; 0x04
    532a:	9d 81       	ldd	r25, Y+5	; 0x05
    532c:	9c 01       	movw	r18, r24
    532e:	2e 5f       	subi	r18, 0xFE	; 254
    5330:	3f 4f       	sbci	r19, 0xFF	; 255
    5332:	ca 01       	movw	r24, r20
    5334:	b9 01       	movw	r22, r18
    5336:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    533a:	28 96       	adiw	r28, 0x08	; 8
    533c:	0f b6       	in	r0, 0x3f	; 63
    533e:	f8 94       	cli
    5340:	de bf       	out	0x3e, r29	; 62
    5342:	0f be       	out	0x3f, r0	; 63
    5344:	cd bf       	out	0x3d, r28	; 61
    5346:	cf 91       	pop	r28
    5348:	df 91       	pop	r29
    534a:	08 95       	ret

0000534c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    534c:	df 93       	push	r29
    534e:	cf 93       	push	r28
    5350:	00 d0       	rcall	.+0      	; 0x5352 <uxTaskResetEventItemValue+0x6>
    5352:	cd b7       	in	r28, 0x3d	; 61
    5354:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5356:	e0 91 ce 06 	lds	r30, 0x06CE
    535a:	f0 91 cf 06 	lds	r31, 0x06CF
    535e:	84 85       	ldd	r24, Z+12	; 0x0c
    5360:	95 85       	ldd	r25, Z+13	; 0x0d
    5362:	9a 83       	std	Y+2, r25	; 0x02
    5364:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5366:	a0 91 ce 06 	lds	r26, 0x06CE
    536a:	b0 91 cf 06 	lds	r27, 0x06CF
    536e:	e0 91 ce 06 	lds	r30, 0x06CE
    5372:	f0 91 cf 06 	lds	r31, 0x06CF
    5376:	86 89       	ldd	r24, Z+22	; 0x16
    5378:	28 2f       	mov	r18, r24
    537a:	30 e0       	ldi	r19, 0x00	; 0
    537c:	87 e0       	ldi	r24, 0x07	; 7
    537e:	90 e0       	ldi	r25, 0x00	; 0
    5380:	82 1b       	sub	r24, r18
    5382:	93 0b       	sbc	r25, r19
    5384:	1d 96       	adiw	r26, 0x0d	; 13
    5386:	9c 93       	st	X, r25
    5388:	8e 93       	st	-X, r24
    538a:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    538c:	89 81       	ldd	r24, Y+1	; 0x01
    538e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    5390:	0f 90       	pop	r0
    5392:	0f 90       	pop	r0
    5394:	cf 91       	pop	r28
    5396:	df 91       	pop	r29
    5398:	08 95       	ret

0000539a <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    539a:	df 93       	push	r29
    539c:	cf 93       	push	r28
    539e:	cd b7       	in	r28, 0x3d	; 61
    53a0:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    53a2:	80 91 ce 06 	lds	r24, 0x06CE
    53a6:	90 91 cf 06 	lds	r25, 0x06CF
    53aa:	00 97       	sbiw	r24, 0x00	; 0
    53ac:	39 f0       	breq	.+14     	; 0x53bc <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    53ae:	e0 91 ce 06 	lds	r30, 0x06CE
    53b2:	f0 91 cf 06 	lds	r31, 0x06CF
    53b6:	86 a5       	ldd	r24, Z+46	; 0x2e
    53b8:	8f 5f       	subi	r24, 0xFF	; 255
    53ba:	86 a7       	std	Z+46, r24	; 0x2e
		}

		return pxCurrentTCB;
    53bc:	80 91 ce 06 	lds	r24, 0x06CE
    53c0:	90 91 cf 06 	lds	r25, 0x06CF
	}
    53c4:	cf 91       	pop	r28
    53c6:	df 91       	pop	r29
    53c8:	08 95       	ret

000053ca <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    53ca:	df 93       	push	r29
    53cc:	cf 93       	push	r28
    53ce:	cd b7       	in	r28, 0x3d	; 61
    53d0:	de b7       	in	r29, 0x3e	; 62
    53d2:	27 97       	sbiw	r28, 0x07	; 7
    53d4:	0f b6       	in	r0, 0x3f	; 63
    53d6:	f8 94       	cli
    53d8:	de bf       	out	0x3e, r29	; 62
    53da:	0f be       	out	0x3f, r0	; 63
    53dc:	cd bf       	out	0x3d, r28	; 61
    53de:	8d 83       	std	Y+5, r24	; 0x05
    53e0:	7f 83       	std	Y+7, r23	; 0x07
    53e2:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    53e4:	0f b6       	in	r0, 0x3f	; 63
    53e6:	f8 94       	cli
    53e8:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    53ea:	e0 91 ce 06 	lds	r30, 0x06CE
    53ee:	f0 91 cf 06 	lds	r31, 0x06CF
    53f2:	87 a5       	ldd	r24, Z+47	; 0x2f
    53f4:	90 a9       	ldd	r25, Z+48	; 0x30
    53f6:	a1 a9       	ldd	r26, Z+49	; 0x31
    53f8:	b2 a9       	ldd	r27, Z+50	; 0x32
    53fa:	00 97       	sbiw	r24, 0x00	; 0
    53fc:	a1 05       	cpc	r26, r1
    53fe:	b1 05       	cpc	r27, r1
    5400:	89 f4       	brne	.+34     	; 0x5424 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5402:	e0 91 ce 06 	lds	r30, 0x06CE
    5406:	f0 91 cf 06 	lds	r31, 0x06CF
    540a:	81 e0       	ldi	r24, 0x01	; 1
    540c:	83 ab       	std	Z+51, r24	; 0x33

				if( xTicksToWait > ( TickType_t ) 0 )
    540e:	8e 81       	ldd	r24, Y+6	; 0x06
    5410:	9f 81       	ldd	r25, Y+7	; 0x07
    5412:	00 97       	sbiw	r24, 0x00	; 0
    5414:	39 f0       	breq	.+14     	; 0x5424 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5416:	8e 81       	ldd	r24, Y+6	; 0x06
    5418:	9f 81       	ldd	r25, Y+7	; 0x07
    541a:	61 e0       	ldi	r22, 0x01	; 1
    541c:	0e 94 8d 2d 	call	0x5b1a	; 0x5b1a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    5420:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5424:	0f 90       	pop	r0
    5426:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5428:	0f b6       	in	r0, 0x3f	; 63
    542a:	f8 94       	cli
    542c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    542e:	e0 91 ce 06 	lds	r30, 0x06CE
    5432:	f0 91 cf 06 	lds	r31, 0x06CF
    5436:	87 a5       	ldd	r24, Z+47	; 0x2f
    5438:	90 a9       	ldd	r25, Z+48	; 0x30
    543a:	a1 a9       	ldd	r26, Z+49	; 0x31
    543c:	b2 a9       	ldd	r27, Z+50	; 0x32
    543e:	89 83       	std	Y+1, r24	; 0x01
    5440:	9a 83       	std	Y+2, r25	; 0x02
    5442:	ab 83       	std	Y+3, r26	; 0x03
    5444:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    5446:	89 81       	ldd	r24, Y+1	; 0x01
    5448:	9a 81       	ldd	r25, Y+2	; 0x02
    544a:	ab 81       	ldd	r26, Y+3	; 0x03
    544c:	bc 81       	ldd	r27, Y+4	; 0x04
    544e:	00 97       	sbiw	r24, 0x00	; 0
    5450:	a1 05       	cpc	r26, r1
    5452:	b1 05       	cpc	r27, r1
    5454:	d9 f0       	breq	.+54     	; 0x548c <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    5456:	8d 81       	ldd	r24, Y+5	; 0x05
    5458:	88 23       	and	r24, r24
    545a:	49 f0       	breq	.+18     	; 0x546e <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    545c:	e0 91 ce 06 	lds	r30, 0x06CE
    5460:	f0 91 cf 06 	lds	r31, 0x06CF
    5464:	17 a6       	std	Z+47, r1	; 0x2f
    5466:	10 aa       	std	Z+48, r1	; 0x30
    5468:	11 aa       	std	Z+49, r1	; 0x31
    546a:	12 aa       	std	Z+50, r1	; 0x32
    546c:	0f c0       	rjmp	.+30     	; 0x548c <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    546e:	e0 91 ce 06 	lds	r30, 0x06CE
    5472:	f0 91 cf 06 	lds	r31, 0x06CF
    5476:	89 81       	ldd	r24, Y+1	; 0x01
    5478:	9a 81       	ldd	r25, Y+2	; 0x02
    547a:	ab 81       	ldd	r26, Y+3	; 0x03
    547c:	bc 81       	ldd	r27, Y+4	; 0x04
    547e:	01 97       	sbiw	r24, 0x01	; 1
    5480:	a1 09       	sbc	r26, r1
    5482:	b1 09       	sbc	r27, r1
    5484:	87 a7       	std	Z+47, r24	; 0x2f
    5486:	90 ab       	std	Z+48, r25	; 0x30
    5488:	a1 ab       	std	Z+49, r26	; 0x31
    548a:	b2 ab       	std	Z+50, r27	; 0x32
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    548c:	e0 91 ce 06 	lds	r30, 0x06CE
    5490:	f0 91 cf 06 	lds	r31, 0x06CF
    5494:	13 aa       	std	Z+51, r1	; 0x33
		}
		taskEXIT_CRITICAL();
    5496:	0f 90       	pop	r0
    5498:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    549a:	89 81       	ldd	r24, Y+1	; 0x01
    549c:	9a 81       	ldd	r25, Y+2	; 0x02
    549e:	ab 81       	ldd	r26, Y+3	; 0x03
    54a0:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    54a2:	bc 01       	movw	r22, r24
    54a4:	cd 01       	movw	r24, r26
    54a6:	27 96       	adiw	r28, 0x07	; 7
    54a8:	0f b6       	in	r0, 0x3f	; 63
    54aa:	f8 94       	cli
    54ac:	de bf       	out	0x3e, r29	; 62
    54ae:	0f be       	out	0x3f, r0	; 63
    54b0:	cd bf       	out	0x3d, r28	; 61
    54b2:	cf 91       	pop	r28
    54b4:	df 91       	pop	r29
    54b6:	08 95       	ret

000054b8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    54b8:	ef 92       	push	r14
    54ba:	ff 92       	push	r15
    54bc:	0f 93       	push	r16
    54be:	1f 93       	push	r17
    54c0:	df 93       	push	r29
    54c2:	cf 93       	push	r28
    54c4:	cd b7       	in	r28, 0x3d	; 61
    54c6:	de b7       	in	r29, 0x3e	; 62
    54c8:	2d 97       	sbiw	r28, 0x0d	; 13
    54ca:	0f b6       	in	r0, 0x3f	; 63
    54cc:	f8 94       	cli
    54ce:	de bf       	out	0x3e, r29	; 62
    54d0:	0f be       	out	0x3f, r0	; 63
    54d2:	cd bf       	out	0x3d, r28	; 61
    54d4:	6a 83       	std	Y+2, r22	; 0x02
    54d6:	7b 83       	std	Y+3, r23	; 0x03
    54d8:	8c 83       	std	Y+4, r24	; 0x04
    54da:	9d 83       	std	Y+5, r25	; 0x05
    54dc:	2e 83       	std	Y+6, r18	; 0x06
    54de:	3f 83       	std	Y+7, r19	; 0x07
    54e0:	48 87       	std	Y+8, r20	; 0x08
    54e2:	59 87       	std	Y+9, r21	; 0x09
    54e4:	1b 87       	std	Y+11, r17	; 0x0b
    54e6:	0a 87       	std	Y+10, r16	; 0x0a
    54e8:	fd 86       	std	Y+13, r15	; 0x0d
    54ea:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    54ec:	0f b6       	in	r0, 0x3f	; 63
    54ee:	f8 94       	cli
    54f0:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    54f2:	e0 91 ce 06 	lds	r30, 0x06CE
    54f6:	f0 91 cf 06 	lds	r31, 0x06CF
    54fa:	83 a9       	ldd	r24, Z+51	; 0x33
    54fc:	82 30       	cpi	r24, 0x02	; 2
    54fe:	49 f1       	breq	.+82     	; 0x5552 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    5500:	e0 91 ce 06 	lds	r30, 0x06CE
    5504:	f0 91 cf 06 	lds	r31, 0x06CF
    5508:	27 a5       	ldd	r18, Z+47	; 0x2f
    550a:	30 a9       	ldd	r19, Z+48	; 0x30
    550c:	41 a9       	ldd	r20, Z+49	; 0x31
    550e:	52 a9       	ldd	r21, Z+50	; 0x32
    5510:	8a 81       	ldd	r24, Y+2	; 0x02
    5512:	9b 81       	ldd	r25, Y+3	; 0x03
    5514:	ac 81       	ldd	r26, Y+4	; 0x04
    5516:	bd 81       	ldd	r27, Y+5	; 0x05
    5518:	80 95       	com	r24
    551a:	90 95       	com	r25
    551c:	a0 95       	com	r26
    551e:	b0 95       	com	r27
    5520:	82 23       	and	r24, r18
    5522:	93 23       	and	r25, r19
    5524:	a4 23       	and	r26, r20
    5526:	b5 23       	and	r27, r21
    5528:	87 a7       	std	Z+47, r24	; 0x2f
    552a:	90 ab       	std	Z+48, r25	; 0x30
    552c:	a1 ab       	std	Z+49, r26	; 0x31
    552e:	b2 ab       	std	Z+50, r27	; 0x32

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    5530:	e0 91 ce 06 	lds	r30, 0x06CE
    5534:	f0 91 cf 06 	lds	r31, 0x06CF
    5538:	81 e0       	ldi	r24, 0x01	; 1
    553a:	83 ab       	std	Z+51, r24	; 0x33

				if( xTicksToWait > ( TickType_t ) 0 )
    553c:	8c 85       	ldd	r24, Y+12	; 0x0c
    553e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5540:	00 97       	sbiw	r24, 0x00	; 0
    5542:	39 f0       	breq	.+14     	; 0x5552 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5544:	8c 85       	ldd	r24, Y+12	; 0x0c
    5546:	9d 85       	ldd	r25, Y+13	; 0x0d
    5548:	61 e0       	ldi	r22, 0x01	; 1
    554a:	0e 94 8d 2d 	call	0x5b1a	; 0x5b1a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    554e:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    5552:	0f 90       	pop	r0
    5554:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    5556:	0f b6       	in	r0, 0x3f	; 63
    5558:	f8 94       	cli
    555a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    555c:	8a 85       	ldd	r24, Y+10	; 0x0a
    555e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5560:	00 97       	sbiw	r24, 0x00	; 0
    5562:	71 f0       	breq	.+28     	; 0x5580 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    5564:	e0 91 ce 06 	lds	r30, 0x06CE
    5568:	f0 91 cf 06 	lds	r31, 0x06CF
    556c:	87 a5       	ldd	r24, Z+47	; 0x2f
    556e:	90 a9       	ldd	r25, Z+48	; 0x30
    5570:	a1 a9       	ldd	r26, Z+49	; 0x31
    5572:	b2 a9       	ldd	r27, Z+50	; 0x32
    5574:	ea 85       	ldd	r30, Y+10	; 0x0a
    5576:	fb 85       	ldd	r31, Y+11	; 0x0b
    5578:	80 83       	st	Z, r24
    557a:	91 83       	std	Z+1, r25	; 0x01
    557c:	a2 83       	std	Z+2, r26	; 0x02
    557e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    5580:	e0 91 ce 06 	lds	r30, 0x06CE
    5584:	f0 91 cf 06 	lds	r31, 0x06CF
    5588:	83 a9       	ldd	r24, Z+51	; 0x33
    558a:	82 30       	cpi	r24, 0x02	; 2
    558c:	11 f0       	breq	.+4      	; 0x5592 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    558e:	19 82       	std	Y+1, r1	; 0x01
    5590:	1a c0       	rjmp	.+52     	; 0x55c6 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    5592:	e0 91 ce 06 	lds	r30, 0x06CE
    5596:	f0 91 cf 06 	lds	r31, 0x06CF
    559a:	27 a5       	ldd	r18, Z+47	; 0x2f
    559c:	30 a9       	ldd	r19, Z+48	; 0x30
    559e:	41 a9       	ldd	r20, Z+49	; 0x31
    55a0:	52 a9       	ldd	r21, Z+50	; 0x32
    55a2:	8e 81       	ldd	r24, Y+6	; 0x06
    55a4:	9f 81       	ldd	r25, Y+7	; 0x07
    55a6:	a8 85       	ldd	r26, Y+8	; 0x08
    55a8:	b9 85       	ldd	r27, Y+9	; 0x09
    55aa:	80 95       	com	r24
    55ac:	90 95       	com	r25
    55ae:	a0 95       	com	r26
    55b0:	b0 95       	com	r27
    55b2:	82 23       	and	r24, r18
    55b4:	93 23       	and	r25, r19
    55b6:	a4 23       	and	r26, r20
    55b8:	b5 23       	and	r27, r21
    55ba:	87 a7       	std	Z+47, r24	; 0x2f
    55bc:	90 ab       	std	Z+48, r25	; 0x30
    55be:	a1 ab       	std	Z+49, r26	; 0x31
    55c0:	b2 ab       	std	Z+50, r27	; 0x32
				xReturn = pdTRUE;
    55c2:	81 e0       	ldi	r24, 0x01	; 1
    55c4:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    55c6:	e0 91 ce 06 	lds	r30, 0x06CE
    55ca:	f0 91 cf 06 	lds	r31, 0x06CF
    55ce:	13 aa       	std	Z+51, r1	; 0x33
		}
		taskEXIT_CRITICAL();
    55d0:	0f 90       	pop	r0
    55d2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    55d4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    55d6:	2d 96       	adiw	r28, 0x0d	; 13
    55d8:	0f b6       	in	r0, 0x3f	; 63
    55da:	f8 94       	cli
    55dc:	de bf       	out	0x3e, r29	; 62
    55de:	0f be       	out	0x3f, r0	; 63
    55e0:	cd bf       	out	0x3d, r28	; 61
    55e2:	cf 91       	pop	r28
    55e4:	df 91       	pop	r29
    55e6:	1f 91       	pop	r17
    55e8:	0f 91       	pop	r16
    55ea:	ff 90       	pop	r15
    55ec:	ef 90       	pop	r14
    55ee:	08 95       	ret

000055f0 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    55f0:	0f 93       	push	r16
    55f2:	1f 93       	push	r17
    55f4:	df 93       	push	r29
    55f6:	cf 93       	push	r28
    55f8:	cd b7       	in	r28, 0x3d	; 61
    55fa:	de b7       	in	r29, 0x3e	; 62
    55fc:	2f 97       	sbiw	r28, 0x0f	; 15
    55fe:	0f b6       	in	r0, 0x3f	; 63
    5600:	f8 94       	cli
    5602:	de bf       	out	0x3e, r29	; 62
    5604:	0f be       	out	0x3f, r0	; 63
    5606:	cd bf       	out	0x3d, r28	; 61
    5608:	9e 83       	std	Y+6, r25	; 0x06
    560a:	8d 83       	std	Y+5, r24	; 0x05
    560c:	4f 83       	std	Y+7, r20	; 0x07
    560e:	58 87       	std	Y+8, r21	; 0x08
    5610:	69 87       	std	Y+9, r22	; 0x09
    5612:	7a 87       	std	Y+10, r23	; 0x0a
    5614:	2b 87       	std	Y+11, r18	; 0x0b
    5616:	1d 87       	std	Y+13, r17	; 0x0d
    5618:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    561a:	81 e0       	ldi	r24, 0x01	; 1
    561c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    561e:	8d 81       	ldd	r24, Y+5	; 0x05
    5620:	9e 81       	ldd	r25, Y+6	; 0x06
    5622:	9c 83       	std	Y+4, r25	; 0x04
    5624:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    5626:	0f b6       	in	r0, 0x3f	; 63
    5628:	f8 94       	cli
    562a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    562c:	8c 85       	ldd	r24, Y+12	; 0x0c
    562e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5630:	00 97       	sbiw	r24, 0x00	; 0
    5632:	61 f0       	breq	.+24     	; 0x564c <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    5634:	eb 81       	ldd	r30, Y+3	; 0x03
    5636:	fc 81       	ldd	r31, Y+4	; 0x04
    5638:	87 a5       	ldd	r24, Z+47	; 0x2f
    563a:	90 a9       	ldd	r25, Z+48	; 0x30
    563c:	a1 a9       	ldd	r26, Z+49	; 0x31
    563e:	b2 a9       	ldd	r27, Z+50	; 0x32
    5640:	ec 85       	ldd	r30, Y+12	; 0x0c
    5642:	fd 85       	ldd	r31, Y+13	; 0x0d
    5644:	80 83       	st	Z, r24
    5646:	91 83       	std	Z+1, r25	; 0x01
    5648:	a2 83       	std	Z+2, r26	; 0x02
    564a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    564c:	eb 81       	ldd	r30, Y+3	; 0x03
    564e:	fc 81       	ldd	r31, Y+4	; 0x04
    5650:	83 a9       	ldd	r24, Z+51	; 0x33
    5652:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5654:	eb 81       	ldd	r30, Y+3	; 0x03
    5656:	fc 81       	ldd	r31, Y+4	; 0x04
    5658:	82 e0       	ldi	r24, 0x02	; 2
    565a:	83 ab       	std	Z+51, r24	; 0x33

			switch( eAction )
    565c:	8b 85       	ldd	r24, Y+11	; 0x0b
    565e:	28 2f       	mov	r18, r24
    5660:	30 e0       	ldi	r19, 0x00	; 0
    5662:	3f 87       	std	Y+15, r19	; 0x0f
    5664:	2e 87       	std	Y+14, r18	; 0x0e
    5666:	8e 85       	ldd	r24, Y+14	; 0x0e
    5668:	9f 85       	ldd	r25, Y+15	; 0x0f
    566a:	82 30       	cpi	r24, 0x02	; 2
    566c:	91 05       	cpc	r25, r1
    566e:	59 f1       	breq	.+86     	; 0x56c6 <xTaskGenericNotify+0xd6>
    5670:	2e 85       	ldd	r18, Y+14	; 0x0e
    5672:	3f 85       	ldd	r19, Y+15	; 0x0f
    5674:	23 30       	cpi	r18, 0x03	; 3
    5676:	31 05       	cpc	r19, r1
    5678:	34 f4       	brge	.+12     	; 0x5686 <xTaskGenericNotify+0x96>
    567a:	8e 85       	ldd	r24, Y+14	; 0x0e
    567c:	9f 85       	ldd	r25, Y+15	; 0x0f
    567e:	81 30       	cpi	r24, 0x01	; 1
    5680:	91 05       	cpc	r25, r1
    5682:	61 f0       	breq	.+24     	; 0x569c <xTaskGenericNotify+0xac>
    5684:	4a c0       	rjmp	.+148    	; 0x571a <xTaskGenericNotify+0x12a>
    5686:	2e 85       	ldd	r18, Y+14	; 0x0e
    5688:	3f 85       	ldd	r19, Y+15	; 0x0f
    568a:	23 30       	cpi	r18, 0x03	; 3
    568c:	31 05       	cpc	r19, r1
    568e:	59 f1       	breq	.+86     	; 0x56e6 <xTaskGenericNotify+0xf6>
    5690:	8e 85       	ldd	r24, Y+14	; 0x0e
    5692:	9f 85       	ldd	r25, Y+15	; 0x0f
    5694:	84 30       	cpi	r24, 0x04	; 4
    5696:	91 05       	cpc	r25, r1
    5698:	89 f1       	breq	.+98     	; 0x56fc <xTaskGenericNotify+0x10c>
    569a:	3f c0       	rjmp	.+126    	; 0x571a <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    569c:	eb 81       	ldd	r30, Y+3	; 0x03
    569e:	fc 81       	ldd	r31, Y+4	; 0x04
    56a0:	27 a5       	ldd	r18, Z+47	; 0x2f
    56a2:	30 a9       	ldd	r19, Z+48	; 0x30
    56a4:	41 a9       	ldd	r20, Z+49	; 0x31
    56a6:	52 a9       	ldd	r21, Z+50	; 0x32
    56a8:	8f 81       	ldd	r24, Y+7	; 0x07
    56aa:	98 85       	ldd	r25, Y+8	; 0x08
    56ac:	a9 85       	ldd	r26, Y+9	; 0x09
    56ae:	ba 85       	ldd	r27, Y+10	; 0x0a
    56b0:	82 2b       	or	r24, r18
    56b2:	93 2b       	or	r25, r19
    56b4:	a4 2b       	or	r26, r20
    56b6:	b5 2b       	or	r27, r21
    56b8:	eb 81       	ldd	r30, Y+3	; 0x03
    56ba:	fc 81       	ldd	r31, Y+4	; 0x04
    56bc:	87 a7       	std	Z+47, r24	; 0x2f
    56be:	90 ab       	std	Z+48, r25	; 0x30
    56c0:	a1 ab       	std	Z+49, r26	; 0x31
    56c2:	b2 ab       	std	Z+50, r27	; 0x32
    56c4:	2a c0       	rjmp	.+84     	; 0x571a <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    56c6:	eb 81       	ldd	r30, Y+3	; 0x03
    56c8:	fc 81       	ldd	r31, Y+4	; 0x04
    56ca:	87 a5       	ldd	r24, Z+47	; 0x2f
    56cc:	90 a9       	ldd	r25, Z+48	; 0x30
    56ce:	a1 a9       	ldd	r26, Z+49	; 0x31
    56d0:	b2 a9       	ldd	r27, Z+50	; 0x32
    56d2:	01 96       	adiw	r24, 0x01	; 1
    56d4:	a1 1d       	adc	r26, r1
    56d6:	b1 1d       	adc	r27, r1
    56d8:	eb 81       	ldd	r30, Y+3	; 0x03
    56da:	fc 81       	ldd	r31, Y+4	; 0x04
    56dc:	87 a7       	std	Z+47, r24	; 0x2f
    56de:	90 ab       	std	Z+48, r25	; 0x30
    56e0:	a1 ab       	std	Z+49, r26	; 0x31
    56e2:	b2 ab       	std	Z+50, r27	; 0x32
    56e4:	1a c0       	rjmp	.+52     	; 0x571a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    56e6:	eb 81       	ldd	r30, Y+3	; 0x03
    56e8:	fc 81       	ldd	r31, Y+4	; 0x04
    56ea:	8f 81       	ldd	r24, Y+7	; 0x07
    56ec:	98 85       	ldd	r25, Y+8	; 0x08
    56ee:	a9 85       	ldd	r26, Y+9	; 0x09
    56f0:	ba 85       	ldd	r27, Y+10	; 0x0a
    56f2:	87 a7       	std	Z+47, r24	; 0x2f
    56f4:	90 ab       	std	Z+48, r25	; 0x30
    56f6:	a1 ab       	std	Z+49, r26	; 0x31
    56f8:	b2 ab       	std	Z+50, r27	; 0x32
    56fa:	0f c0       	rjmp	.+30     	; 0x571a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    56fc:	89 81       	ldd	r24, Y+1	; 0x01
    56fe:	82 30       	cpi	r24, 0x02	; 2
    5700:	59 f0       	breq	.+22     	; 0x5718 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    5702:	eb 81       	ldd	r30, Y+3	; 0x03
    5704:	fc 81       	ldd	r31, Y+4	; 0x04
    5706:	8f 81       	ldd	r24, Y+7	; 0x07
    5708:	98 85       	ldd	r25, Y+8	; 0x08
    570a:	a9 85       	ldd	r26, Y+9	; 0x09
    570c:	ba 85       	ldd	r27, Y+10	; 0x0a
    570e:	87 a7       	std	Z+47, r24	; 0x2f
    5710:	90 ab       	std	Z+48, r25	; 0x30
    5712:	a1 ab       	std	Z+49, r26	; 0x31
    5714:	b2 ab       	std	Z+50, r27	; 0x32
    5716:	01 c0       	rjmp	.+2      	; 0x571a <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5718:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    571a:	89 81       	ldd	r24, Y+1	; 0x01
    571c:	81 30       	cpi	r24, 0x01	; 1
    571e:	b9 f5       	brne	.+110    	; 0x578e <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5720:	8b 81       	ldd	r24, Y+3	; 0x03
    5722:	9c 81       	ldd	r25, Y+4	; 0x04
    5724:	02 96       	adiw	r24, 0x02	; 2
    5726:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    572a:	eb 81       	ldd	r30, Y+3	; 0x03
    572c:	fc 81       	ldd	r31, Y+4	; 0x04
    572e:	96 89       	ldd	r25, Z+22	; 0x16
    5730:	80 91 d4 06 	lds	r24, 0x06D4
    5734:	89 17       	cp	r24, r25
    5736:	28 f4       	brcc	.+10     	; 0x5742 <xTaskGenericNotify+0x152>
    5738:	eb 81       	ldd	r30, Y+3	; 0x03
    573a:	fc 81       	ldd	r31, Y+4	; 0x04
    573c:	86 89       	ldd	r24, Z+22	; 0x16
    573e:	80 93 d4 06 	sts	0x06D4, r24
    5742:	eb 81       	ldd	r30, Y+3	; 0x03
    5744:	fc 81       	ldd	r31, Y+4	; 0x04
    5746:	86 89       	ldd	r24, Z+22	; 0x16
    5748:	28 2f       	mov	r18, r24
    574a:	30 e0       	ldi	r19, 0x00	; 0
    574c:	c9 01       	movw	r24, r18
    574e:	88 0f       	add	r24, r24
    5750:	99 1f       	adc	r25, r25
    5752:	88 0f       	add	r24, r24
    5754:	99 1f       	adc	r25, r25
    5756:	88 0f       	add	r24, r24
    5758:	99 1f       	adc	r25, r25
    575a:	82 0f       	add	r24, r18
    575c:	93 1f       	adc	r25, r19
    575e:	ac 01       	movw	r20, r24
    5760:	41 52       	subi	r20, 0x21	; 33
    5762:	59 4f       	sbci	r21, 0xF9	; 249
    5764:	8b 81       	ldd	r24, Y+3	; 0x03
    5766:	9c 81       	ldd	r25, Y+4	; 0x04
    5768:	9c 01       	movw	r18, r24
    576a:	2e 5f       	subi	r18, 0xFE	; 254
    576c:	3f 4f       	sbci	r19, 0xFF	; 255
    576e:	ca 01       	movw	r24, r20
    5770:	b9 01       	movw	r22, r18
    5772:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5776:	eb 81       	ldd	r30, Y+3	; 0x03
    5778:	fc 81       	ldd	r31, Y+4	; 0x04
    577a:	96 89       	ldd	r25, Z+22	; 0x16
    577c:	e0 91 ce 06 	lds	r30, 0x06CE
    5780:	f0 91 cf 06 	lds	r31, 0x06CF
    5784:	86 89       	ldd	r24, Z+22	; 0x16
    5786:	89 17       	cp	r24, r25
    5788:	10 f4       	brcc	.+4      	; 0x578e <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    578a:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    578e:	0f 90       	pop	r0
    5790:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5792:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5794:	2f 96       	adiw	r28, 0x0f	; 15
    5796:	0f b6       	in	r0, 0x3f	; 63
    5798:	f8 94       	cli
    579a:	de bf       	out	0x3e, r29	; 62
    579c:	0f be       	out	0x3f, r0	; 63
    579e:	cd bf       	out	0x3d, r28	; 61
    57a0:	cf 91       	pop	r28
    57a2:	df 91       	pop	r29
    57a4:	1f 91       	pop	r17
    57a6:	0f 91       	pop	r16
    57a8:	08 95       	ret

000057aa <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    57aa:	ef 92       	push	r14
    57ac:	ff 92       	push	r15
    57ae:	0f 93       	push	r16
    57b0:	1f 93       	push	r17
    57b2:	df 93       	push	r29
    57b4:	cf 93       	push	r28
    57b6:	cd b7       	in	r28, 0x3d	; 61
    57b8:	de b7       	in	r29, 0x3e	; 62
    57ba:	62 97       	sbiw	r28, 0x12	; 18
    57bc:	0f b6       	in	r0, 0x3f	; 63
    57be:	f8 94       	cli
    57c0:	de bf       	out	0x3e, r29	; 62
    57c2:	0f be       	out	0x3f, r0	; 63
    57c4:	cd bf       	out	0x3d, r28	; 61
    57c6:	9f 83       	std	Y+7, r25	; 0x07
    57c8:	8e 83       	std	Y+6, r24	; 0x06
    57ca:	48 87       	std	Y+8, r20	; 0x08
    57cc:	59 87       	std	Y+9, r21	; 0x09
    57ce:	6a 87       	std	Y+10, r22	; 0x0a
    57d0:	7b 87       	std	Y+11, r23	; 0x0b
    57d2:	2c 87       	std	Y+12, r18	; 0x0c
    57d4:	1e 87       	std	Y+14, r17	; 0x0e
    57d6:	0d 87       	std	Y+13, r16	; 0x0d
    57d8:	f8 8a       	std	Y+16, r15	; 0x10
    57da:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    57dc:	81 e0       	ldi	r24, 0x01	; 1
    57de:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    57e0:	8e 81       	ldd	r24, Y+6	; 0x06
    57e2:	9f 81       	ldd	r25, Y+7	; 0x07
    57e4:	9d 83       	std	Y+5, r25	; 0x05
    57e6:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    57e8:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    57ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    57ec:	9e 85       	ldd	r25, Y+14	; 0x0e
    57ee:	00 97       	sbiw	r24, 0x00	; 0
    57f0:	61 f0       	breq	.+24     	; 0x580a <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    57f2:	ec 81       	ldd	r30, Y+4	; 0x04
    57f4:	fd 81       	ldd	r31, Y+5	; 0x05
    57f6:	87 a5       	ldd	r24, Z+47	; 0x2f
    57f8:	90 a9       	ldd	r25, Z+48	; 0x30
    57fa:	a1 a9       	ldd	r26, Z+49	; 0x31
    57fc:	b2 a9       	ldd	r27, Z+50	; 0x32
    57fe:	ed 85       	ldd	r30, Y+13	; 0x0d
    5800:	fe 85       	ldd	r31, Y+14	; 0x0e
    5802:	80 83       	st	Z, r24
    5804:	91 83       	std	Z+1, r25	; 0x01
    5806:	a2 83       	std	Z+2, r26	; 0x02
    5808:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    580a:	ec 81       	ldd	r30, Y+4	; 0x04
    580c:	fd 81       	ldd	r31, Y+5	; 0x05
    580e:	83 a9       	ldd	r24, Z+51	; 0x33
    5810:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5812:	ec 81       	ldd	r30, Y+4	; 0x04
    5814:	fd 81       	ldd	r31, Y+5	; 0x05
    5816:	82 e0       	ldi	r24, 0x02	; 2
    5818:	83 ab       	std	Z+51, r24	; 0x33

			switch( eAction )
    581a:	8c 85       	ldd	r24, Y+12	; 0x0c
    581c:	28 2f       	mov	r18, r24
    581e:	30 e0       	ldi	r19, 0x00	; 0
    5820:	3a 8b       	std	Y+18, r19	; 0x12
    5822:	29 8b       	std	Y+17, r18	; 0x11
    5824:	89 89       	ldd	r24, Y+17	; 0x11
    5826:	9a 89       	ldd	r25, Y+18	; 0x12
    5828:	82 30       	cpi	r24, 0x02	; 2
    582a:	91 05       	cpc	r25, r1
    582c:	59 f1       	breq	.+86     	; 0x5884 <xTaskGenericNotifyFromISR+0xda>
    582e:	29 89       	ldd	r18, Y+17	; 0x11
    5830:	3a 89       	ldd	r19, Y+18	; 0x12
    5832:	23 30       	cpi	r18, 0x03	; 3
    5834:	31 05       	cpc	r19, r1
    5836:	34 f4       	brge	.+12     	; 0x5844 <xTaskGenericNotifyFromISR+0x9a>
    5838:	89 89       	ldd	r24, Y+17	; 0x11
    583a:	9a 89       	ldd	r25, Y+18	; 0x12
    583c:	81 30       	cpi	r24, 0x01	; 1
    583e:	91 05       	cpc	r25, r1
    5840:	61 f0       	breq	.+24     	; 0x585a <xTaskGenericNotifyFromISR+0xb0>
    5842:	4a c0       	rjmp	.+148    	; 0x58d8 <xTaskGenericNotifyFromISR+0x12e>
    5844:	29 89       	ldd	r18, Y+17	; 0x11
    5846:	3a 89       	ldd	r19, Y+18	; 0x12
    5848:	23 30       	cpi	r18, 0x03	; 3
    584a:	31 05       	cpc	r19, r1
    584c:	59 f1       	breq	.+86     	; 0x58a4 <xTaskGenericNotifyFromISR+0xfa>
    584e:	89 89       	ldd	r24, Y+17	; 0x11
    5850:	9a 89       	ldd	r25, Y+18	; 0x12
    5852:	84 30       	cpi	r24, 0x04	; 4
    5854:	91 05       	cpc	r25, r1
    5856:	89 f1       	breq	.+98     	; 0x58ba <xTaskGenericNotifyFromISR+0x110>
    5858:	3f c0       	rjmp	.+126    	; 0x58d8 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    585a:	ec 81       	ldd	r30, Y+4	; 0x04
    585c:	fd 81       	ldd	r31, Y+5	; 0x05
    585e:	27 a5       	ldd	r18, Z+47	; 0x2f
    5860:	30 a9       	ldd	r19, Z+48	; 0x30
    5862:	41 a9       	ldd	r20, Z+49	; 0x31
    5864:	52 a9       	ldd	r21, Z+50	; 0x32
    5866:	88 85       	ldd	r24, Y+8	; 0x08
    5868:	99 85       	ldd	r25, Y+9	; 0x09
    586a:	aa 85       	ldd	r26, Y+10	; 0x0a
    586c:	bb 85       	ldd	r27, Y+11	; 0x0b
    586e:	82 2b       	or	r24, r18
    5870:	93 2b       	or	r25, r19
    5872:	a4 2b       	or	r26, r20
    5874:	b5 2b       	or	r27, r21
    5876:	ec 81       	ldd	r30, Y+4	; 0x04
    5878:	fd 81       	ldd	r31, Y+5	; 0x05
    587a:	87 a7       	std	Z+47, r24	; 0x2f
    587c:	90 ab       	std	Z+48, r25	; 0x30
    587e:	a1 ab       	std	Z+49, r26	; 0x31
    5880:	b2 ab       	std	Z+50, r27	; 0x32
    5882:	2a c0       	rjmp	.+84     	; 0x58d8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    5884:	ec 81       	ldd	r30, Y+4	; 0x04
    5886:	fd 81       	ldd	r31, Y+5	; 0x05
    5888:	87 a5       	ldd	r24, Z+47	; 0x2f
    588a:	90 a9       	ldd	r25, Z+48	; 0x30
    588c:	a1 a9       	ldd	r26, Z+49	; 0x31
    588e:	b2 a9       	ldd	r27, Z+50	; 0x32
    5890:	01 96       	adiw	r24, 0x01	; 1
    5892:	a1 1d       	adc	r26, r1
    5894:	b1 1d       	adc	r27, r1
    5896:	ec 81       	ldd	r30, Y+4	; 0x04
    5898:	fd 81       	ldd	r31, Y+5	; 0x05
    589a:	87 a7       	std	Z+47, r24	; 0x2f
    589c:	90 ab       	std	Z+48, r25	; 0x30
    589e:	a1 ab       	std	Z+49, r26	; 0x31
    58a0:	b2 ab       	std	Z+50, r27	; 0x32
    58a2:	1a c0       	rjmp	.+52     	; 0x58d8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    58a4:	ec 81       	ldd	r30, Y+4	; 0x04
    58a6:	fd 81       	ldd	r31, Y+5	; 0x05
    58a8:	88 85       	ldd	r24, Y+8	; 0x08
    58aa:	99 85       	ldd	r25, Y+9	; 0x09
    58ac:	aa 85       	ldd	r26, Y+10	; 0x0a
    58ae:	bb 85       	ldd	r27, Y+11	; 0x0b
    58b0:	87 a7       	std	Z+47, r24	; 0x2f
    58b2:	90 ab       	std	Z+48, r25	; 0x30
    58b4:	a1 ab       	std	Z+49, r26	; 0x31
    58b6:	b2 ab       	std	Z+50, r27	; 0x32
    58b8:	0f c0       	rjmp	.+30     	; 0x58d8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    58ba:	8b 81       	ldd	r24, Y+3	; 0x03
    58bc:	82 30       	cpi	r24, 0x02	; 2
    58be:	59 f0       	breq	.+22     	; 0x58d6 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    58c0:	ec 81       	ldd	r30, Y+4	; 0x04
    58c2:	fd 81       	ldd	r31, Y+5	; 0x05
    58c4:	88 85       	ldd	r24, Y+8	; 0x08
    58c6:	99 85       	ldd	r25, Y+9	; 0x09
    58c8:	aa 85       	ldd	r26, Y+10	; 0x0a
    58ca:	bb 85       	ldd	r27, Y+11	; 0x0b
    58cc:	87 a7       	std	Z+47, r24	; 0x2f
    58ce:	90 ab       	std	Z+48, r25	; 0x30
    58d0:	a1 ab       	std	Z+49, r26	; 0x31
    58d2:	b2 ab       	std	Z+50, r27	; 0x32
    58d4:	01 c0       	rjmp	.+2      	; 0x58d8 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    58d6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    58d8:	8b 81       	ldd	r24, Y+3	; 0x03
    58da:	81 30       	cpi	r24, 0x01	; 1
    58dc:	09 f0       	breq	.+2      	; 0x58e0 <xTaskGenericNotifyFromISR+0x136>
    58de:	4f c0       	rjmp	.+158    	; 0x597e <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    58e0:	80 91 de 06 	lds	r24, 0x06DE
    58e4:	88 23       	and	r24, r24
    58e6:	61 f5       	brne	.+88     	; 0x5940 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    58e8:	8c 81       	ldd	r24, Y+4	; 0x04
    58ea:	9d 81       	ldd	r25, Y+5	; 0x05
    58ec:	02 96       	adiw	r24, 0x02	; 2
    58ee:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    58f2:	ec 81       	ldd	r30, Y+4	; 0x04
    58f4:	fd 81       	ldd	r31, Y+5	; 0x05
    58f6:	96 89       	ldd	r25, Z+22	; 0x16
    58f8:	80 91 d4 06 	lds	r24, 0x06D4
    58fc:	89 17       	cp	r24, r25
    58fe:	28 f4       	brcc	.+10     	; 0x590a <xTaskGenericNotifyFromISR+0x160>
    5900:	ec 81       	ldd	r30, Y+4	; 0x04
    5902:	fd 81       	ldd	r31, Y+5	; 0x05
    5904:	86 89       	ldd	r24, Z+22	; 0x16
    5906:	80 93 d4 06 	sts	0x06D4, r24
    590a:	ec 81       	ldd	r30, Y+4	; 0x04
    590c:	fd 81       	ldd	r31, Y+5	; 0x05
    590e:	86 89       	ldd	r24, Z+22	; 0x16
    5910:	28 2f       	mov	r18, r24
    5912:	30 e0       	ldi	r19, 0x00	; 0
    5914:	c9 01       	movw	r24, r18
    5916:	88 0f       	add	r24, r24
    5918:	99 1f       	adc	r25, r25
    591a:	88 0f       	add	r24, r24
    591c:	99 1f       	adc	r25, r25
    591e:	88 0f       	add	r24, r24
    5920:	99 1f       	adc	r25, r25
    5922:	82 0f       	add	r24, r18
    5924:	93 1f       	adc	r25, r19
    5926:	ac 01       	movw	r20, r24
    5928:	41 52       	subi	r20, 0x21	; 33
    592a:	59 4f       	sbci	r21, 0xF9	; 249
    592c:	8c 81       	ldd	r24, Y+4	; 0x04
    592e:	9d 81       	ldd	r25, Y+5	; 0x05
    5930:	9c 01       	movw	r18, r24
    5932:	2e 5f       	subi	r18, 0xFE	; 254
    5934:	3f 4f       	sbci	r19, 0xFF	; 255
    5936:	ca 01       	movw	r24, r20
    5938:	b9 01       	movw	r22, r18
    593a:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
    593e:	0a c0       	rjmp	.+20     	; 0x5954 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5940:	8c 81       	ldd	r24, Y+4	; 0x04
    5942:	9d 81       	ldd	r25, Y+5	; 0x05
    5944:	9c 01       	movw	r18, r24
    5946:	24 5f       	subi	r18, 0xF4	; 244
    5948:	3f 4f       	sbci	r19, 0xFF	; 255
    594a:	84 e3       	ldi	r24, 0x34	; 52
    594c:	97 e0       	ldi	r25, 0x07	; 7
    594e:	b9 01       	movw	r22, r18
    5950:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5954:	ec 81       	ldd	r30, Y+4	; 0x04
    5956:	fd 81       	ldd	r31, Y+5	; 0x05
    5958:	96 89       	ldd	r25, Z+22	; 0x16
    595a:	e0 91 ce 06 	lds	r30, 0x06CE
    595e:	f0 91 cf 06 	lds	r31, 0x06CF
    5962:	86 89       	ldd	r24, Z+22	; 0x16
    5964:	89 17       	cp	r24, r25
    5966:	58 f4       	brcc	.+22     	; 0x597e <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5968:	8f 85       	ldd	r24, Y+15	; 0x0f
    596a:	98 89       	ldd	r25, Y+16	; 0x10
    596c:	00 97       	sbiw	r24, 0x00	; 0
    596e:	21 f0       	breq	.+8      	; 0x5978 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5970:	ef 85       	ldd	r30, Y+15	; 0x0f
    5972:	f8 89       	ldd	r31, Y+16	; 0x10
    5974:	81 e0       	ldi	r24, 0x01	; 1
    5976:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5978:	81 e0       	ldi	r24, 0x01	; 1
    597a:	80 93 d7 06 	sts	0x06D7, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    597e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5980:	62 96       	adiw	r28, 0x12	; 18
    5982:	0f b6       	in	r0, 0x3f	; 63
    5984:	f8 94       	cli
    5986:	de bf       	out	0x3e, r29	; 62
    5988:	0f be       	out	0x3f, r0	; 63
    598a:	cd bf       	out	0x3d, r28	; 61
    598c:	cf 91       	pop	r28
    598e:	df 91       	pop	r29
    5990:	1f 91       	pop	r17
    5992:	0f 91       	pop	r16
    5994:	ff 90       	pop	r15
    5996:	ef 90       	pop	r14
    5998:	08 95       	ret

0000599a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    599a:	df 93       	push	r29
    599c:	cf 93       	push	r28
    599e:	cd b7       	in	r28, 0x3d	; 61
    59a0:	de b7       	in	r29, 0x3e	; 62
    59a2:	28 97       	sbiw	r28, 0x08	; 8
    59a4:	0f b6       	in	r0, 0x3f	; 63
    59a6:	f8 94       	cli
    59a8:	de bf       	out	0x3e, r29	; 62
    59aa:	0f be       	out	0x3f, r0	; 63
    59ac:	cd bf       	out	0x3d, r28	; 61
    59ae:	9e 83       	std	Y+6, r25	; 0x06
    59b0:	8d 83       	std	Y+5, r24	; 0x05
    59b2:	78 87       	std	Y+8, r23	; 0x08
    59b4:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    59b6:	8d 81       	ldd	r24, Y+5	; 0x05
    59b8:	9e 81       	ldd	r25, Y+6	; 0x06
    59ba:	9c 83       	std	Y+4, r25	; 0x04
    59bc:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    59be:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    59c0:	eb 81       	ldd	r30, Y+3	; 0x03
    59c2:	fc 81       	ldd	r31, Y+4	; 0x04
    59c4:	83 a9       	ldd	r24, Z+51	; 0x33
    59c6:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    59c8:	eb 81       	ldd	r30, Y+3	; 0x03
    59ca:	fc 81       	ldd	r31, Y+4	; 0x04
    59cc:	82 e0       	ldi	r24, 0x02	; 2
    59ce:	83 ab       	std	Z+51, r24	; 0x33

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    59d0:	eb 81       	ldd	r30, Y+3	; 0x03
    59d2:	fc 81       	ldd	r31, Y+4	; 0x04
    59d4:	87 a5       	ldd	r24, Z+47	; 0x2f
    59d6:	90 a9       	ldd	r25, Z+48	; 0x30
    59d8:	a1 a9       	ldd	r26, Z+49	; 0x31
    59da:	b2 a9       	ldd	r27, Z+50	; 0x32
    59dc:	01 96       	adiw	r24, 0x01	; 1
    59de:	a1 1d       	adc	r26, r1
    59e0:	b1 1d       	adc	r27, r1
    59e2:	eb 81       	ldd	r30, Y+3	; 0x03
    59e4:	fc 81       	ldd	r31, Y+4	; 0x04
    59e6:	87 a7       	std	Z+47, r24	; 0x2f
    59e8:	90 ab       	std	Z+48, r25	; 0x30
    59ea:	a1 ab       	std	Z+49, r26	; 0x31
    59ec:	b2 ab       	std	Z+50, r27	; 0x32

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    59ee:	8a 81       	ldd	r24, Y+2	; 0x02
    59f0:	81 30       	cpi	r24, 0x01	; 1
    59f2:	09 f0       	breq	.+2      	; 0x59f6 <vTaskNotifyGiveFromISR+0x5c>
    59f4:	4f c0       	rjmp	.+158    	; 0x5a94 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    59f6:	80 91 de 06 	lds	r24, 0x06DE
    59fa:	88 23       	and	r24, r24
    59fc:	61 f5       	brne	.+88     	; 0x5a56 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    59fe:	8b 81       	ldd	r24, Y+3	; 0x03
    5a00:	9c 81       	ldd	r25, Y+4	; 0x04
    5a02:	02 96       	adiw	r24, 0x02	; 2
    5a04:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5a08:	eb 81       	ldd	r30, Y+3	; 0x03
    5a0a:	fc 81       	ldd	r31, Y+4	; 0x04
    5a0c:	96 89       	ldd	r25, Z+22	; 0x16
    5a0e:	80 91 d4 06 	lds	r24, 0x06D4
    5a12:	89 17       	cp	r24, r25
    5a14:	28 f4       	brcc	.+10     	; 0x5a20 <vTaskNotifyGiveFromISR+0x86>
    5a16:	eb 81       	ldd	r30, Y+3	; 0x03
    5a18:	fc 81       	ldd	r31, Y+4	; 0x04
    5a1a:	86 89       	ldd	r24, Z+22	; 0x16
    5a1c:	80 93 d4 06 	sts	0x06D4, r24
    5a20:	eb 81       	ldd	r30, Y+3	; 0x03
    5a22:	fc 81       	ldd	r31, Y+4	; 0x04
    5a24:	86 89       	ldd	r24, Z+22	; 0x16
    5a26:	28 2f       	mov	r18, r24
    5a28:	30 e0       	ldi	r19, 0x00	; 0
    5a2a:	c9 01       	movw	r24, r18
    5a2c:	88 0f       	add	r24, r24
    5a2e:	99 1f       	adc	r25, r25
    5a30:	88 0f       	add	r24, r24
    5a32:	99 1f       	adc	r25, r25
    5a34:	88 0f       	add	r24, r24
    5a36:	99 1f       	adc	r25, r25
    5a38:	82 0f       	add	r24, r18
    5a3a:	93 1f       	adc	r25, r19
    5a3c:	ac 01       	movw	r20, r24
    5a3e:	41 52       	subi	r20, 0x21	; 33
    5a40:	59 4f       	sbci	r21, 0xF9	; 249
    5a42:	8b 81       	ldd	r24, Y+3	; 0x03
    5a44:	9c 81       	ldd	r25, Y+4	; 0x04
    5a46:	9c 01       	movw	r18, r24
    5a48:	2e 5f       	subi	r18, 0xFE	; 254
    5a4a:	3f 4f       	sbci	r19, 0xFF	; 255
    5a4c:	ca 01       	movw	r24, r20
    5a4e:	b9 01       	movw	r22, r18
    5a50:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
    5a54:	0a c0       	rjmp	.+20     	; 0x5a6a <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5a56:	8b 81       	ldd	r24, Y+3	; 0x03
    5a58:	9c 81       	ldd	r25, Y+4	; 0x04
    5a5a:	9c 01       	movw	r18, r24
    5a5c:	24 5f       	subi	r18, 0xF4	; 244
    5a5e:	3f 4f       	sbci	r19, 0xFF	; 255
    5a60:	84 e3       	ldi	r24, 0x34	; 52
    5a62:	97 e0       	ldi	r25, 0x07	; 7
    5a64:	b9 01       	movw	r22, r18
    5a66:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    5a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    5a6e:	96 89       	ldd	r25, Z+22	; 0x16
    5a70:	e0 91 ce 06 	lds	r30, 0x06CE
    5a74:	f0 91 cf 06 	lds	r31, 0x06CF
    5a78:	86 89       	ldd	r24, Z+22	; 0x16
    5a7a:	89 17       	cp	r24, r25
    5a7c:	58 f4       	brcc	.+22     	; 0x5a94 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    5a7e:	8f 81       	ldd	r24, Y+7	; 0x07
    5a80:	98 85       	ldd	r25, Y+8	; 0x08
    5a82:	00 97       	sbiw	r24, 0x00	; 0
    5a84:	21 f0       	breq	.+8      	; 0x5a8e <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    5a86:	ef 81       	ldd	r30, Y+7	; 0x07
    5a88:	f8 85       	ldd	r31, Y+8	; 0x08
    5a8a:	81 e0       	ldi	r24, 0x01	; 1
    5a8c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    5a8e:	81 e0       	ldi	r24, 0x01	; 1
    5a90:	80 93 d7 06 	sts	0x06D7, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    5a94:	28 96       	adiw	r28, 0x08	; 8
    5a96:	0f b6       	in	r0, 0x3f	; 63
    5a98:	f8 94       	cli
    5a9a:	de bf       	out	0x3e, r29	; 62
    5a9c:	0f be       	out	0x3f, r0	; 63
    5a9e:	cd bf       	out	0x3d, r28	; 61
    5aa0:	cf 91       	pop	r28
    5aa2:	df 91       	pop	r29
    5aa4:	08 95       	ret

00005aa6 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    5aa6:	df 93       	push	r29
    5aa8:	cf 93       	push	r28
    5aaa:	cd b7       	in	r28, 0x3d	; 61
    5aac:	de b7       	in	r29, 0x3e	; 62
    5aae:	27 97       	sbiw	r28, 0x07	; 7
    5ab0:	0f b6       	in	r0, 0x3f	; 63
    5ab2:	f8 94       	cli
    5ab4:	de bf       	out	0x3e, r29	; 62
    5ab6:	0f be       	out	0x3f, r0	; 63
    5ab8:	cd bf       	out	0x3d, r28	; 61
    5aba:	9d 83       	std	Y+5, r25	; 0x05
    5abc:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    5abe:	8c 81       	ldd	r24, Y+4	; 0x04
    5ac0:	9d 81       	ldd	r25, Y+5	; 0x05
    5ac2:	00 97       	sbiw	r24, 0x00	; 0
    5ac4:	39 f4       	brne	.+14     	; 0x5ad4 <xTaskNotifyStateClear+0x2e>
    5ac6:	80 91 ce 06 	lds	r24, 0x06CE
    5aca:	90 91 cf 06 	lds	r25, 0x06CF
    5ace:	9f 83       	std	Y+7, r25	; 0x07
    5ad0:	8e 83       	std	Y+6, r24	; 0x06
    5ad2:	04 c0       	rjmp	.+8      	; 0x5adc <xTaskNotifyStateClear+0x36>
    5ad4:	8c 81       	ldd	r24, Y+4	; 0x04
    5ad6:	9d 81       	ldd	r25, Y+5	; 0x05
    5ad8:	9f 83       	std	Y+7, r25	; 0x07
    5ada:	8e 83       	std	Y+6, r24	; 0x06
    5adc:	8e 81       	ldd	r24, Y+6	; 0x06
    5ade:	9f 81       	ldd	r25, Y+7	; 0x07
    5ae0:	9b 83       	std	Y+3, r25	; 0x03
    5ae2:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5ae4:	0f b6       	in	r0, 0x3f	; 63
    5ae6:	f8 94       	cli
    5ae8:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5aea:	ea 81       	ldd	r30, Y+2	; 0x02
    5aec:	fb 81       	ldd	r31, Y+3	; 0x03
    5aee:	83 a9       	ldd	r24, Z+51	; 0x33
    5af0:	82 30       	cpi	r24, 0x02	; 2
    5af2:	31 f4       	brne	.+12     	; 0x5b00 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5af4:	ea 81       	ldd	r30, Y+2	; 0x02
    5af6:	fb 81       	ldd	r31, Y+3	; 0x03
    5af8:	13 aa       	std	Z+51, r1	; 0x33
				xReturn = pdPASS;
    5afa:	81 e0       	ldi	r24, 0x01	; 1
    5afc:	89 83       	std	Y+1, r24	; 0x01
    5afe:	01 c0       	rjmp	.+2      	; 0x5b02 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    5b00:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    5b02:	0f 90       	pop	r0
    5b04:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5b06:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5b08:	27 96       	adiw	r28, 0x07	; 7
    5b0a:	0f b6       	in	r0, 0x3f	; 63
    5b0c:	f8 94       	cli
    5b0e:	de bf       	out	0x3e, r29	; 62
    5b10:	0f be       	out	0x3f, r0	; 63
    5b12:	cd bf       	out	0x3d, r28	; 61
    5b14:	cf 91       	pop	r28
    5b16:	df 91       	pop	r29
    5b18:	08 95       	ret

00005b1a <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5b1a:	df 93       	push	r29
    5b1c:	cf 93       	push	r28
    5b1e:	cd b7       	in	r28, 0x3d	; 61
    5b20:	de b7       	in	r29, 0x3e	; 62
    5b22:	27 97       	sbiw	r28, 0x07	; 7
    5b24:	0f b6       	in	r0, 0x3f	; 63
    5b26:	f8 94       	cli
    5b28:	de bf       	out	0x3e, r29	; 62
    5b2a:	0f be       	out	0x3f, r0	; 63
    5b2c:	cd bf       	out	0x3d, r28	; 61
    5b2e:	9e 83       	std	Y+6, r25	; 0x06
    5b30:	8d 83       	std	Y+5, r24	; 0x05
    5b32:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5b34:	80 91 d2 06 	lds	r24, 0x06D2
    5b38:	90 91 d3 06 	lds	r25, 0x06D3
    5b3c:	9a 83       	std	Y+2, r25	; 0x02
    5b3e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5b40:	80 91 ce 06 	lds	r24, 0x06CE
    5b44:	90 91 cf 06 	lds	r25, 0x06CF
    5b48:	02 96       	adiw	r24, 0x02	; 2
    5b4a:	0e 94 8f 0c 	call	0x191e	; 0x191e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    5b4e:	8d 81       	ldd	r24, Y+5	; 0x05
    5b50:	9e 81       	ldd	r25, Y+6	; 0x06
    5b52:	2f ef       	ldi	r18, 0xFF	; 255
    5b54:	8f 3f       	cpi	r24, 0xFF	; 255
    5b56:	92 07       	cpc	r25, r18
    5b58:	81 f4       	brne	.+32     	; 0x5b7a <prvAddCurrentTaskToDelayedList+0x60>
    5b5a:	8f 81       	ldd	r24, Y+7	; 0x07
    5b5c:	88 23       	and	r24, r24
    5b5e:	69 f0       	breq	.+26     	; 0x5b7a <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5b60:	80 91 ce 06 	lds	r24, 0x06CE
    5b64:	90 91 cf 06 	lds	r25, 0x06CF
    5b68:	9c 01       	movw	r18, r24
    5b6a:	2e 5f       	subi	r18, 0xFE	; 254
    5b6c:	3f 4f       	sbci	r19, 0xFF	; 255
    5b6e:	86 e4       	ldi	r24, 0x46	; 70
    5b70:	97 e0       	ldi	r25, 0x07	; 7
    5b72:	b9 01       	movw	r22, r18
    5b74:	0e 94 df 0b 	call	0x17be	; 0x17be <vListInsertEnd>
    5b78:	43 c0       	rjmp	.+134    	; 0x5c00 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    5b7a:	29 81       	ldd	r18, Y+1	; 0x01
    5b7c:	3a 81       	ldd	r19, Y+2	; 0x02
    5b7e:	8d 81       	ldd	r24, Y+5	; 0x05
    5b80:	9e 81       	ldd	r25, Y+6	; 0x06
    5b82:	82 0f       	add	r24, r18
    5b84:	93 1f       	adc	r25, r19
    5b86:	9c 83       	std	Y+4, r25	; 0x04
    5b88:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5b8a:	e0 91 ce 06 	lds	r30, 0x06CE
    5b8e:	f0 91 cf 06 	lds	r31, 0x06CF
    5b92:	8b 81       	ldd	r24, Y+3	; 0x03
    5b94:	9c 81       	ldd	r25, Y+4	; 0x04
    5b96:	93 83       	std	Z+3, r25	; 0x03
    5b98:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    5b9a:	2b 81       	ldd	r18, Y+3	; 0x03
    5b9c:	3c 81       	ldd	r19, Y+4	; 0x04
    5b9e:	89 81       	ldd	r24, Y+1	; 0x01
    5ba0:	9a 81       	ldd	r25, Y+2	; 0x02
    5ba2:	28 17       	cp	r18, r24
    5ba4:	39 07       	cpc	r19, r25
    5ba6:	70 f4       	brcc	.+28     	; 0x5bc4 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5ba8:	80 91 32 07 	lds	r24, 0x0732
    5bac:	90 91 33 07 	lds	r25, 0x0733
    5bb0:	20 91 ce 06 	lds	r18, 0x06CE
    5bb4:	30 91 cf 06 	lds	r19, 0x06CF
    5bb8:	2e 5f       	subi	r18, 0xFE	; 254
    5bba:	3f 4f       	sbci	r19, 0xFF	; 255
    5bbc:	b9 01       	movw	r22, r18
    5bbe:	0e 94 23 0c 	call	0x1846	; 0x1846 <vListInsert>
    5bc2:	1e c0       	rjmp	.+60     	; 0x5c00 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5bc4:	40 91 30 07 	lds	r20, 0x0730
    5bc8:	50 91 31 07 	lds	r21, 0x0731
    5bcc:	80 91 ce 06 	lds	r24, 0x06CE
    5bd0:	90 91 cf 06 	lds	r25, 0x06CF
    5bd4:	9c 01       	movw	r18, r24
    5bd6:	2e 5f       	subi	r18, 0xFE	; 254
    5bd8:	3f 4f       	sbci	r19, 0xFF	; 255
    5bda:	ca 01       	movw	r24, r20
    5bdc:	b9 01       	movw	r22, r18
    5bde:	0e 94 23 0c 	call	0x1846	; 0x1846 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    5be2:	20 91 da 06 	lds	r18, 0x06DA
    5be6:	30 91 db 06 	lds	r19, 0x06DB
    5bea:	8b 81       	ldd	r24, Y+3	; 0x03
    5bec:	9c 81       	ldd	r25, Y+4	; 0x04
    5bee:	82 17       	cp	r24, r18
    5bf0:	93 07       	cpc	r25, r19
    5bf2:	30 f4       	brcc	.+12     	; 0x5c00 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    5bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    5bf8:	90 93 db 06 	sts	0x06DB, r25
    5bfc:	80 93 da 06 	sts	0x06DA, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    5c00:	27 96       	adiw	r28, 0x07	; 7
    5c02:	0f b6       	in	r0, 0x3f	; 63
    5c04:	f8 94       	cli
    5c06:	de bf       	out	0x3e, r29	; 62
    5c08:	0f be       	out	0x3f, r0	; 63
    5c0a:	cd bf       	out	0x3d, r28	; 61
    5c0c:	cf 91       	pop	r28
    5c0e:	df 91       	pop	r29
    5c10:	08 95       	ret

00005c12 <__udivmodqi4>:
    5c12:	99 1b       	sub	r25, r25
    5c14:	79 e0       	ldi	r23, 0x09	; 9
    5c16:	04 c0       	rjmp	.+8      	; 0x5c20 <__udivmodqi4_ep>

00005c18 <__udivmodqi4_loop>:
    5c18:	99 1f       	adc	r25, r25
    5c1a:	96 17       	cp	r25, r22
    5c1c:	08 f0       	brcs	.+2      	; 0x5c20 <__udivmodqi4_ep>
    5c1e:	96 1b       	sub	r25, r22

00005c20 <__udivmodqi4_ep>:
    5c20:	88 1f       	adc	r24, r24
    5c22:	7a 95       	dec	r23
    5c24:	c9 f7       	brne	.-14     	; 0x5c18 <__udivmodqi4_loop>
    5c26:	80 95       	com	r24
    5c28:	08 95       	ret

00005c2a <memcpy>:
    5c2a:	fb 01       	movw	r30, r22
    5c2c:	dc 01       	movw	r26, r24
    5c2e:	02 c0       	rjmp	.+4      	; 0x5c34 <memcpy+0xa>
    5c30:	01 90       	ld	r0, Z+
    5c32:	0d 92       	st	X+, r0
    5c34:	41 50       	subi	r20, 0x01	; 1
    5c36:	50 40       	sbci	r21, 0x00	; 0
    5c38:	d8 f7       	brcc	.-10     	; 0x5c30 <memcpy+0x6>
    5c3a:	08 95       	ret

00005c3c <memset>:
    5c3c:	dc 01       	movw	r26, r24
    5c3e:	01 c0       	rjmp	.+2      	; 0x5c42 <memset+0x6>
    5c40:	6d 93       	st	X+, r22
    5c42:	41 50       	subi	r20, 0x01	; 1
    5c44:	50 40       	sbci	r21, 0x00	; 0
    5c46:	e0 f7       	brcc	.-8      	; 0x5c40 <memset+0x4>
    5c48:	08 95       	ret

00005c4a <_exit>:
    5c4a:	f8 94       	cli

00005c4c <__stop_program>:
    5c4c:	ff cf       	rjmp	.-2      	; 0x5c4c <__stop_program>
